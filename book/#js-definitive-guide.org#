#+title: Js Definitive Guide

* 자바스크립트 완벽 가이드
*** 서문
이 책의 목표는 자바스크립트 언어를 포괄적이고 완벽하게 문서화하고, 자바스크립트 프로그램에서 사용할 수 있는 클라이언트 및 서버사이드 API를 자세히 소개하는 것입니다

책을 읽다가 코어 자바스크립트 또는 클라이언트 사이드 자바스크립트에 대해 찾아보고 싶다면 MDN 웹사이트를 추천합니다
서버 사이드 노드 API에 궁금한 것이 있다면 노드 참조 문서를 추천합니다
** 자바스크립트 소개
자바스크립트는 웹의 프로그래밍 언어입니다

ECMAScript 명세는 ES6을 마지막으로, 버전번호 대신 년도를 사용하기로 결정했습니다
(e.g. ES2016, ES2017, ES2018 ...)

하위 호환성 유지 문제 때문에 제거할 수 없는 구식 기능이 있습니다
- ES5 이후 버전에서는 초기 버전의 실수를 대부분 해결한 스트릭트 모드를 사용할 수 있습니다
- ES6 이후에는 새로운 기능을 사용할 때 묵시적으로 스트릭트 모드에 진입하는 경우가 잦습니다
  (e.g. class 키워드[클래스 내부 코드], ES6 모듈[모듈 내부 코드])

자바스크립트 코어에는 입출력에 관한 부분은 정의되어 있지 않습니다
- 입출력, 네트워크, 스토리지, 그래픽 같은 기능은 자바스크립트가 임베드된 '호스트 환경'이 담당합니다
  - 웹브라우저 환경: 사용자의 마우스와 키보드 입력을 받고 HTTP 요청을 보내고 HTML과 CSS 표시
  - 노드: 운영체제 전체에 접근해 파일을 읽고 쓰고, 네트워크를 통해 데이터 송수신, HTTP 요청을 보내고 받기

이 장은 소개 목적이므로 이어질 장을 이해하는 데 필수적인 핵심 기능을 간단히 훑어 나가기만 합니다
*** 자바스크립트 탐험
*** Hello World
*** 자바스크립트 여행
객체는 문자열과 값의 연결입니다
- 객체의 프로퍼티는 . 또는 []로 접근합니다
- 할당을 통해 프로퍼티를 새로 만들 수 있습니다


자바스크립트는 배열, 즉 *숫자로 인덱스된* 리스트도 지원합니다


자바스크립트에서 표현식이란 어떤 값으로 평가(evaluate)되는 구절입니다


표현식은 값을 계산할 뿐 프로그램의 상태를 바꾸지 않습니다
문은 값을 갖지 않지만 프로그램의 상태를 바꿉니다
- 변수 이름 역시 표현식입니다


함수(function)는 한 번 정의하면 몇 번이고 호출할 수 있는, 이름이 있고 매개변수를 받을 수 있는 자바스크립트 코드 블록입니다


객체와 함께 사용하는 함수를 *메서드*라고 부릅니다
- 객체 프로퍼티로 할당된 함수를 메서드라고 부릅니다
- 자바스크립트의 객체는 모두 (배열도 포함하여 ) 메서드를 갖습니다


"this" 키워드는 메서드를 정의하는 대상 객체입니다
*** 예제: 글자 빈도 히스토그램
*** 요약
** 어휘구조
어휘구조는 그 언어로 프로그램을 작성할 때 지켜야 할 기본적인 규칙의 집합입니다
- 대소문자 구분, 스페이스, 줄바꿈
- 주석
- 리터럴
- 식별자와 예약어
- 유니코드
- (선택사항)세미콜론
*** 자바스크립트 프로그램의 텍스트
자바스크립트는 토큰 사이의 공백을 무시합니다
- 자바스크립트는 일반적인 스페이스 문자(~\u0020~) 외에 탭, ASCII 제어문자, 다양한 유니코드 스페이스 문자를 모두 공백으로 인식합니다
*** 주석
*** 리터럴
리터럴은(literal)은 프로그램 안에 직접 쓴 데이터 값입니다
*** 식별자와 예약어
식별자는 상수, 변수, 프로퍼티, 함수, 클래스, 루프의 라벨로 사용합니다

식별자 규칙
- 시작
  - 글자(알파벳 권장)
  - 밑줄(`_`)
  - 달러기호($)
- 나머지
  - 글자, *숫자*, 밑줄, 달러기호
첫 자리에 숫자를 허용하지 않는 이유는 식별자와 숫자를 쉽게 구별하기 위해서입니다
*** 유니코드
자바스크립트 프로그램은 유니코드 문자셋으로 작성됩니다
**** 유니코드 이스케이프 시퀀스
이스케이프 시퀀스
- ASCII 문자만으로 유니코드를 표현
- `\u` 문자로 시작하고 그 뒤에 16진수 숫자를 4개 사용하거나 중괄호 안에 1~6개 사용가능
- 자바스크립트 문자열 리터럴, 정규표현식 리터럴, 식별자에 사용할 수 있습니다
**** 유니코드 정규화
유니코드에 그 문자를 인코딩 방법이 하나 이상 있음을 인지해야합니다
- e.g. é
  - 단일 유니코드 ~\u00E9~
  - ASCII문자 e + 악센트 조합기호 ~\u0301~

유니코드 정규화 과정
- 유니코드 표준에는 모든 문자에 대해 선호하는 인코딩이 있다
- 텍스트를 비교에 적합한 정식(canonical) 형태로 변환

자바스크립트는 해석하고 있는 소스코드가 이미 정규화를 마친 상태라고 가정
- 스스로 정규화를 수행하지 않는다
- 자바스크립트 프로그램에서 유니코드 문자를 쓸 계획이라면 소스코드를 따로 유니코드 정규화해야한다
*** 선택사항인 세미콜론
자바스크립트는 세미콜론(;)을 사용해 *문*을 구분합니다

자바스크립트는 두 문 사이에 *줄바꿈*이 있을 때는 *대부분* 세미콜론을 생략해도 됩니다
- 프로그램 끝에서도 생략할 수 있음
- 그 다음 토큰이 닫는 중괄호(})일 때도 생략할 수 있음

자바스크립트가 줄바꿈을 *전부* 세미콜론으로 취급하지 않습니다
자바스크립트가 줄바꿈을 세미콜론으로 취급하는 경우
- 줄바꿈 다음에 오는 공백 아닌 문자를 현재 문에 이어진다고 판단할 수 없을 때 줄바꿈을 세미콜론으로 취급
  - 3가지 예외
    - ~return, throw, yield, break, continue~ 문
    - ~++~, ~--~ 연산자
    - 화살표 함수 ~=>~
- 일반적으로 문이 ~(, [, /, +~로 시작한다면 그 문은 이전 문이 계속되는 것으로 해석될 가능성이 있습니다
*** 요약
** 타입, 값, 변수
*** 개요와 정의
자바스크립트 타입은 기본타입과 객체타입으로 나뉩니다

기본타입
- 숫자
- 문자열
- 불(boolean)
- null
- undefined
- symbol
객체타입
- 기본타입이 아닌 모든 것

객체
- 프로퍼티의 집합
- 종류
  - 일반적인 객체: 이름 붙은 값의 *순서 없는* 집합
  - 배열: 숫자가 붙은 값의 *순서 있는* 집합
  - Set: 값의 집합
  - Map: 키와 값의 연결
  - 형식화배열: 바이트배열과 다른 *이진데이터* 연결
  - RegExp: 텍스트 패턴
  - Date: 날짜와 시간 표현
  - Error:
  - 함수:
  - 클래스:

 자바스크립트의 기본 타입은 불변(immutable)이고 객체 타입은 가변(mutable)입니다
*** 숫자
숫자타입 Number은 정수와 함께 실수를 대략적으로 표현합니다

IEEE754 표준에서 정의하는 64비트 부동소수점 형식을 사용해 숫자를 표현합니다
- 배열인덱싱이나 비트연산자는 32비트 정수를 사용합니다

**** 정수 리터럴
16진수: ~0x~ ~0X~
2진수: ~0b~ ~0B~
8진수: ~0o~ ~0O~

**** 부동 소수점 리터럴
실수 또는 지수표기법으로 표현할 수 있습니다
- 지수표기법은 실수에 10의 지수 승을 곱하는 방식으로 표현합니다

**** 자바스크립트의 산술 연산
#+begin_src javascript
  Math.pow(2, 53)         // => 2의 53승
  Math.round(.6)        // => 1.0: 가장 가까운 정수로 반올림
  Math.ceil(.6)         // => 1.0: 정수로 올림
  Math.floor(.6)        // => 0.0: 정수로 올림
  Math.abs(-5)          // => 5: 절댓값
  Math.max(x,y,z)       // 인자 중 가장 큰 것을 반환
  Math.min(x,y,z)       // 가장 작은 인자를 반한합니다
  Math.random()
  Math.PI
  Math.E                // e: 자연 로그의 밑
  Math.sqrt(3)          // => 3**0.5: 3의 제곱근
  Math.pow(3, 1/3)      // => 3**(1/3): 3의 세제곱근
  Math.sin(0)
  Math.log(10)          // 10의 자연로그
  Math.log(100)/Math.LN10       // 100의 상용로그
  Math.log(512)/Math.LN2        // 512의 이진로그
  Math.exp(3)           // Math.E의 세제곱

  // ES6에서 추가된 함수들
  Math.cbrt(27)         // => 3: 세제곱근
  Math.hypot(3,4)       // => 5: 인자의 제곱의 합의 제곱근
  Math.log10(100)       // => 2: 상용로그
  Math.log2(1024)       // => 10: 이진로그
  Math.expm1(x)         // Math.exp(x)-1
  Math.sign(x)          // 인자의 부호에 따라 -1, 0, 1을 반환
  Math.imul(2,3)        // => 6: C언어의 방식을 차용한 32비트 정수의 곱셈
  Math.clz32(0xf)       // => 28: 32비트 정수에서 맨 앞의 0비트 개수
  Math.trunc(3.9)       // => 3: 소수점 아래를 잘라내어 정수로 변환
  Math.fround(x)        // 가장 가까운 32비트 부동소수점 숫자로 반올림
  Math.sinh(x)          // 하이퍼볼릭 사인
  Math.asinh(x)         // 하이퍼볼릭 아크사인
#+end_src

***** 에러
산술연산 과정에 0으로 나누거나, 오버플로, 언더플로가 발생해도 에러를 일으키지 않습니다

~Infinity~와 ~NaN~은 전역상수이며 이들은 ~Number~ 객체의 프로퍼티로도 존재합니다
****** Infinity, -Infinity
~Infinity~
- 오버플로(자바스크립트가 표현할 수 있는 가장 큰 숫자보다 큰 경우)

~-Infinity~
- 가장 큰 음수의 절댓값보다 큰 경우

무한한 값에 다른 숫자를 더하거나, 빼거나, 곱하거나, 나누더라도 결과는 여전히 무한한 값입니다 (부호는 바뀔 수 있습니다)
****** 언더플로
자바스크립트가 표현할 수 있는 가장 작은 숫자보다도 0에 가까울 때 0을 반환합니다

음수에서 언더플로가 일어나면 '음의 0'이라는 특별한 값을 반환합니다
- 이 값은 0과 거의 완전히 같으며 자바스크립트 프로그래머가 여기에 신경쓸 필요는 없습니다
****** 0으로 나누기
0이 아닌 값을 0으로 나누면 무한대 또는 음의 무한대를 반환합니다

0을 0으로 나누면 NaN를 반환합니다
****** NaN
- 0을 0으로 나누면 NaN를 반환합니다
- 무한대를 무한대로 나누기
- 음수의 제곱근을 구하기
- 숫자로 변환할 수 없는 피연산자에 산술연산자를 적용할 때
- NaN 값은 자기 자신을 포함해 어떤 값과도 같지 않습니다
  - ~x === NaN~ 을 쓸 수 없습니다
  - ~x != x~ 또는 ~Number.isNaN(x)~ 을 써야 합니다
****** Number.isFinite()
- 인자가 ~NaN~, ~Infinity~, ~-Infinity~ 가 아닐 때 true를 반환
- 전역함수 ~isFinite()~ 와는 다르게 첫번째 매개변수를 변환시키지 않음
****** Example
#+begin_src javascript
  Infinity                      // 표현하기엔 너무 큰 양수
  Number.POSITIVE_INFINITY      // 같은 값
  1/0                           // => Infinity
  Number.MAX_VALUE * 2          // => Infinity; 오버플로

  -Infinity                     // 표현하기엔 절댓값이 너무 큰 음수
  Number.NEGATIVE_INFINITY      // 같은 값
  -1/0                          // => -Infinity
  -Number.MAX_VALUE * 2         // => -Infinity

  NaN                           // 숫자가 아닌 값
  Number.NaN                    // NaN과 같은 값이며 표현만 다릅니다
  0/0                           // => NaN
  Infinity/Infinity             // => NaN

  Number.MIN_VALUE / 2          // => 0: 언더플로
  -Number.MIN_VALUE / 2         // => -0: 음의 0
  -1 / Infinity                 // => -0: 음의 0
  -0

  // 다음 Number 프로퍼티는 ES6에서 정의했습니다.
  Number.parseInt()             // 전역 함수 parseInt()와 같습니다
  Number.parseFloat()           // 전역 함수 parseFloat()과 같습니다.
  Number.isNaN(x)               // x는 NaN인가?
  Number.isFinite(x)            // x는 유한한 숫자인가?
  Number.isInteger(x)           // x는 정수인가?
  Number.isSafeInteger(x)       // x는 -(2**53)보다 크고 2**53보다 작은 정수인가?
  Number.MIN_SAFE_INTEGER
  Number.MAX_SAFE_INTEGER
  Number.EPSILON                // 2**-52: 숫자를 구별할 수 있는 가장 작은 차이
#+end_src
****** 음의 0
이 값은 일치 연산자(===)로 양의 0과 비교해도 true를 반환

#+begin_src javascript
  let zero = 0;                 // 일반적인 0
  let negz = -0;                // 음의 0
  zero === negz                 // => true: 0과 음의 0은 일치합니다.
  1/zero === 1/negz             // => false: Infinity와 -Inifinity는 일치하지 않습니다.
#+end_src
**** 이진 부동 소수점 숫자와 반올림 오류
자바스크립트의 IEEE 754 부동소수점 표현은 이진 표현이며, ~0.1~ 같은 단순한 숫자를 정확히 표현하지 못합니다

부동 소수점 근삿값 때문에 문제가 생긴다면 정수로 변환하는 것을 고려해보십시오
- 돈을 계산할 때 0.1 달러 대신 10센ㅌ로 계산하는 것입니다
**** BigInt로 임의 정확도를 부여한 정수
~BigInt~는 ES2020에서 정의한 기능입니다
- 값이 정수인 숫자 타입입니다
- 64비트 정수를 표현하기 위해 추가됐습니다
- 타이밍 공격을 방지 할 수 없으므로 암호화에는 사용할 수 없습니다

~BigInt~ 리터럴은 연속된 숫자 다음에 소문자 n을 붙인 형식입니다
- ~1234n~

~BigInt()~로 숫자나 문자열을 ~BigInt~로 변환할 수 있습니다

***** 연산자
~+, -, *, /, %, **~ 와 같은 표준 연산자를 쓸 수 있지만,
*일반적인 숫자* 피연산자를 섞어 쓸 수 없습니다

비교연산자는 일반적인 숫자를 피연산자로 섞어도 괜찮습니다
**** 날짜와 시간
~Date~ 클래스는 날짜와 시간에 대응하는 *숫자*를 표현하고 조작합니다
- ~Date~ 는 *타임스탬프* 인 숫자 표현을 가지고 있습니다
*** 텍스트
문자열
- 부호 없는 16비트 값이 *순서에 따라 이어진* 형태
- 기본값(primitive)이므로 불변입니다
- 길이(length)는 문자열에 포함된 16비트 값의 개수입니다
- 유니코드 문자셋의 UTF-16인코딩을 사용합니다


자바스크립트의 문자열 메서드는 대부분 문자가 아니라 *16비트 값* 단위로 동작합니다
- 문자열 메서드는 써로케이트 페어를 특별 취급하지 않습니다
- 따로 정규화하지도 않고,문자열이 정확한 UTF-16 형식인지 검사하지 않습니다


ES6에서 문자열은 ~이터러블(iterable)~ 이고
for/of 루프나 ~...~ 연산자를 사용하면 16비트 값이 아닌 실제 문자를 순회합니다


문자열은 읽기 전용 배열로 취급할 수도 있으며
~charAt()~ 메서드 대신 대괄호를 써서 문자열의 개별문자(16비트 값)에 접근할 수 있습니다
**** 문자열 리터럴
보간(interpolation)
- 백틱으로 감싼 문자열
- ES6 기능
- 문자열 리터럴 안에 자바스크립트 표현식을 넣을 수 있다

#+begin_src javascript
  // 두 행을 한 행으로 표현했습니다.
  'two\nlines'

  // 한 행을 세 행으로 나눠 썼습니다.
  "one\
   long\
   line"

  // 두 행 문자열을 두 행에 나눠 썼습니다.
  `이 행의 마지막에 있는 줄바꿈 문자는
  있는 그대로 문자열의 일부입니다`
#+end_src

HTML도 문자열에 작은따옴표와 큰따옴표를 모두 쓸 수 있습니다
- 따라서 자바스크립트와 HTML을 섞어 쓸 때는 따옴표를 구분하는 규칙을 정해 두는게 좋습니다
#+begin_src html
  <button onclick="alert('Thank you')">Click Me</button>
#+end_src
**** 문자열 리터럴 안의 이스케이프 시퀀스
역슬래시는 그 다음 문자와 조합해서 일반적인 방법으로는 문자열에 표시할 수 없는 문자를 표현합니다

| 시퀀스 | 문자                                                |
|--------+-----------------------------------------------------|
| \xnn   | 16진수 숫자 두개 nn으로(인코딩) 표현하는 유니코드 문자    |
| \unnnn | 16진수 숫자 네 개 nnnn으로(인코딩) 표현하는 유니코드 문자 |
| \u{n}  | 코드포인트 n으로 표현하는 유니코드 문자                                              |
**** 문자열 다루기
연산자를 문자열에 쓰면 두번째 문자열을 첫번째 문자열 뒤에 이어 붙입니다

문자열 비교 `===`, `!==`
- 두 문자열이 정확히 같은 16비트 값의 연속으로 이루어졌을 때에 일치
- 문자열 비교는 16비트 값을 비교하는 방식으로 이루어집니다
**** 문자열 API
#+begin_src javascript
  let s = "Hello, world";       // 이 텍스트를 예제에 사용합니다.

  // 문자열의 일부를 가져옵니다.
  s.substring(1,4)              // => "ell": 두 번째, 세 번째, 네 번째 문자
  s.slice(1,4)                  // => "ell": 같은 결과입니다.
  s.split(", ")                 // => ["Hello", "world"] 구분자를 기준으로 나눕니다.

  // 문자열 검색
  s.indexOf("l")                // => 2: l이 처음 나타나는 위치
  s.indexOf("l", 3)             // => 3: 3번 문자부터 시작해 l이 처음 나타나는 위치
  s.indexOf("zz")               // => -1: s에는 zz라는 문자열이 들어 있지 않습니다.
  s.lastIndexOf("l")            // => 10: l이 마지막으로 나타나는 위치

  // 불을 반환하는 검색 함수는 ES6에서 추가됐습니다.
  s.startsWith("Hell")          // true: s는 Hell로 시작합니다.
  s.endsWith("!")               // false: s는 !로 끝나지 않습니다.
  s.includes("or")              // true: s에는 or이 들어 있습니다.

  // 문자열을 변경합니다.
  s.replace("llo", "ya")        // => "Heya, world"
  s.toLowerCase()               // => "hello, world"
  s.toUpperCase()               // => "HELLO, WORLD"
  s.normalize()                 // 유니코드 NFC 정규화는 ES6에서 추가됐습니다.
  s.normalize("NFD")            // NFD 정규화, NFKC, NFKD도 있습니다.

  // 문자열의 각 16비트 문자를 검사합니다.
  s.charAt(0)                   // => "H": 첫 번째 문자
  s.charAt(s.length-1)          // => "d": 마지막 문자
  s.charCodeAt(0)               // => 72: 주어진 위치의 16비트 숫자
  s.codePointAt(0)              // => 72: 16비트보다 큰 코드 포인트에서 동작하는 ES6 기능

  // 패딩 함수는 ES2017에서 추가됐습니다.
  "x".padStart(3)               // => "   x": 왼쪽에 스페이스를 두 개 더합니다.
  "x".padEnd(3)                 // => "x   ": 오른쪽에 스페이스를 두 개 더합니다
  "x".padStart(3, "*")          // => "**x": *를 왼쪽에 붙여 길이를 3에 맞춥니다
  "x".padEnd(3, "-")            // => "x--": -를 오른쪽에 붙여 길이를 3에 맞춥니다.

  // 공백 제거. trim()은 ES5, 나머지는 ES2019 기능입니다.
  " test ".trim()               // => "test": 앞뒤 공백을 제거합니다.
  " test ".trimStart()          // => "test ": 왼쪽 공백을 제거합니다. trimLeft도 있습니다.
  " test ".trimEnd()            // => " test": 오른쪽 공백을 제거합니다. trimRight도 있습니다.

  // 그 외의 문자열 메서드
  s.concat("!")                 // => "Hello, world!": + 연산자를 쓰는 게 더 간단합니다.
  "<>".repeat(5)                // => "<><><><><>": n번 복사합니다. ES6에서 추가됐습니다.
#+end_src
**** 템플릿 리터럴
백틱으로 둘러싼 문자열 리터럴의 최종값은
- 그 안에 포함된 표현식을 평가해서
- 그 표현식의 값을 문자열로 변환한 다음,
- 변환된 문자열을 백틱 안에 들어있는 리터럴 문자와 결합한 값으로 결정됩니다

***** 태그된 템플릿 리터럴
여는 백틱 바로 앞에 함수 이름(태그)이 있으면 템플릿 리터럴의 텍스트와 표현식 값이 함수에 전달됩니다
그리고 이 '태그된 템플릿 리터럴'의 값이 함수의 반환 값입니다
- 이 기능은 HTML이나 SQL을 텍스트에 붙이기 전에 이스케이프 하는 용도로 사용할 수 있습니다

**** 패턴 매칭
정규표현식(RegExp)
- 자바스크립트의 데이터 타입
  - 기본적인 데이터 타입은 아니지만 리터럴 문법이 있으므로 기본적인 데이터 타입처럼 보입니다
- 문자열 내부의 패턴을 정의하고 매칭합니다

***** 정규표현식 리터럴
슬래시 한 쌍 사이에 텍스트를 씁니다
두 번째 슬래시 뒤에도 글자 하나 이상 쓸 수 있으며 이 글자는 *패턴의 의미*를 수정합니다

#+begin_src javascript
  /^HTML/;                      // 문자열의 시작 부분에 있는 H T M L 에 일치합니다
  /[1-9][0-9]*/;                // 0이 아닌 숫자가 하나 있어야 하고 그 뒤의 숫자는 제한이 없습니다.
  /\bjavascript\b/i;            // javascript가 한 단어로 들어가야 하고 대소문자를 구분하지 않습니다.
#+end_src
***** 정규표현식 API
#+begin_src javascript
  let text = "testing: 1, 2, 3";                // 샘플 텍스트
  let pattern = /\d+/g;                         // 연속된 숫자 전체에 일치합니다.
  pattern.test(text)                            // => true: 패턴에 맞는 것이 있습니다.
  text.search(pattern)                          // => 9: 첫 번째로 일치하는 부분의 위치
  text.match(pattern)                           // => ["1", "2", "3"]: 일치하는 부분이 모두 포함된 배열
  text.replace(pattern, "#")                    // => "testing: #, #, #"
  text.split(/\D+/)                             // => ["", "1", "2", "3"]: 숫자 아닌 것에서 나눕니다.
#+end_src
*** 불 값
자바스크립트 값은 모두 불 값으로 변환될 수 있습니다

falsy
- undefined
- null
- 0
- -0
- NaN
- ""(빈 문자열)
truthy
- falsy 외에 모든 값
*** null과 undefined
~null~ 은 값이 없음을 나타낼 때 사용하는 값입니다

~null~에 ~typeof~ 연산자를 사용하면 문자열 "object"를 반환합니다
- 이를 미루어 ~null~은 '객체가 없다'라는 것을 나타내는 특별한 *객체* 값이라고 볼 수 있습니다
  - 객체뿐만 아니라 숫자나 문자열에도 '값이 없다'를 의미할 수 있습니다
- ~null~ 은 해당 타입의 유일한 멤버로 인식됩니다

~undefined~
- 초기화되지 않은 변수의 값
- 객체의 존재하지 않는 프로퍼티에 접근했을 때
- 존재하지 않는 배열요소에 접근했을 때
- 값을 명시적으로 반환하지 않는 함수의 반환 값
- 전달되지 않은 인자의 값

~undefined~ 는 미리 정의된 전역 상수이며, 그 값은 ~undefined~로 초기화됩니다
~undefined~ 에 ~typeof~ 연산자를 적용하면 문자열 "undefined"를 반환합니다
~undefined~ 는 특별한 타입이고 멤버는 그 하나뿐입니다
*** 심벌
심벌은 프로퍼티 이름으로 ES6에서 추가됐습니다

심벌 타입에는 리터럴 문법이 없습니다
심벌은 객체가 아니라 기본 값이므로 ~Symbol()~ 은 new와 함께 호출되는 생성자 함수가 아닙니다

심벌은 자바스크립트 언어를 확장하는 메커니즘
- 특정 문자열 이름을 표준화(메서드, 프로퍼티)하면 기존 코드가 깨질 수 있음
- ~Symbol()~ 를 호출해 심벌 값을 얻었다면 객체의 기존 프로퍼티를 같은 이름으로 *덮어 쓸 염려 없이* 그 값을 프로퍼티 이름으로 추가할 수 있습니다
**** 심벌 값
심벌 값(value)를 가져올 때는 ~Symbol()~ 함수를 호출합니다
- 이 함수는 같은 인자로 호출하더라도 다른 값을 반환합니다

~Symbol()~ 함수는 선택사항 인자로 문자열을 받고 고유한 심벌 값을 반환합니다
- 문자열 인자를 전달하면 그 문자열은 심벌의 ~toString()~ 메서드 결과에 포함됩니다
- 하지만 같은 문자열을 전달해 ~Symbol()~ 을 다시 호출하더라도 결과는 완전히 다릅니다
**** 전역 심벌 레지스트리
목적
- 다른 코드에서도 쓸 수 있도록 심벌을 정의하고 공유하고 싶을 때 사용합니다

~Symbol.for()~
- 문자열 인자를 받고 그 문자열과 연관된 심벌 값을 반환합니다
- 그 문자열과 연관된 심벌이 존재하지 않으면 새 심벌을 생성해 반환하고, 존재하면 기존 심벌을 반환합니다

~Symbol.keyFor()~
- 반환된 심벌에 호출하면 해당 문자열을 얻을 수 있습니다
*** 전역 객체
전역 객체의 프로퍼티는 전역으로 정의된 식별자이며, 모든 자바스크립트 프로그램에서 사용할 수 있습니다

자바스크립트 인터프리터를 시작할 때마다(또는 웹 브라우저가 새 페이지를 로드할 때마다)
아래의 프로퍼티를 가진 새 전역 객체를 생성합니다
- undefined,Infinity, NaN 같은 전역 상수
- isNaN(), parseInt(), eval() 같은 전역 함수
- Date(), RegExp(), String(), Object(), Array() 같은 생성자 함수
- Math와 JSON 같은 전역 객체

전역 객체의 초기 프로퍼티는 예약어로 간주해야 합니다


노드의 전역 객체에는 global이라는 프로퍼티가 있으며, 그 값은 전역객체 자체입니다
- 따라서 노드 프로그램에서는 ~global~로 전역객체를 참조할 수 있습니다

웹 브라우저에서는 Window 객체가 모든 자바스크립트 코드의 전역 객체입니다.
이 전역 Window 객체에서는 자신을 참조하는 window 프로퍼티가 있으므로 이 프로퍼티를 통해 전역 객체를 참조할 수 있습니다

웹 워커 스레드의 전역 객체는 다릅니다.
- 워커의 코드는 ~self~ 로 전역객체를 참조합니다

globalThis
- 어떤 환경에서든 전역 객체를 참조하는 표준입니다
*** 불변인 기본 값과 가변인 객체 참조
기본 값은 객체와 달리 불변입니다
- 변경하는 방법이 없습니다
객체는 가변입니다
- 값을 변경할 수 있습니다

기본 값은 값으로 비교합니다
객체는 값으로 비교하지 않습니다
- 객체는 참조로 비교합니다. 두 객체 값이 같은 객체를 참조할 때만 성립합니다
- 두 객체의 프로퍼티와 값이 같다고 해서 같은 객체가 아닙니다
- 또한 두 배열에 같은 요소가 같은 순서로 존재한다 해도 같은 배열이 아닙니다
*** 타입 변환
| 값                      | 문자열로          |       숫자로 | 불 값으로 |
|-------------------------+------------------+--------------+----------|
| undefined               | "undefined"      |          NaN | false    |
| null                    | "null"           |            0 | false    |
| true                    | "true"           |            1 |          |
| false                   | "false"          |            0 |          |
| ""(빈문자열)             |                  |            0 | false    |
| "1.2"(숫자)             |                  |          1.2 | true     |
| "one"                   |                  |          NaN | true     |
| 0                       | "0"              |              | false    |
| -0                      | "0"              |              | false    |
| 1(0이 아닌 유한한 숫자)   | "1"              |              | true    |
| Infinity                | "Infinity"       |              | true     |
| -Infinity               | "-Infinity"      |              | true     |
| NaN                     | "NaN"            |              | false    |
| {}(객체)                | 3.9.3절 참조     | 3.9.3절 참조 | true     |
| [](빈배열)              | ""               |            0 | true     |
| [9](숫자요소하나)        | "9"              |            9 | true     |
| ['a'](임의의 배열)       | join()메서드 사용 |          NaN | true     |
| function(){}(임의의함수) | 3.9.3절 참조     |          NaN | true     |
**** 변환과 일치
**** 명시적 변환
#+begin_src javascript
  Number("3")           // => 3
  String(false)         // => "false": false.toString()과 같습니다
  Boolean([])           // => true

  let n = 17;
  let binary = "0b" + n.toString(2);    // binary == "0b10001"
  let octal = "0o" + n.toString(8);     // octal == "0o21"
  let hex = "0x" + n.toString(16);      // hex == "0x11"

  let n = 123456.789;
  n.toFixed(0)          // => "123457"
  n.toFixed(2)          // => "123456.79"
  n.toFixed(5)          // => "123456.78900"
  n.toExponential(1)    // => "1.2e+5"
  n.toExponential(3)    // => "1.235e+5"
  n.toPrecision(4)      // => "1.235e+5"
  n.toPrecision(7)      // => "123456.8"
  n.toPrecision(10)     // => "123456.7890"

#+end_src
~Number()~
- 문자열을 정수나 부동소수점 리터럴로 변환 시도
- 10진수 정수에만 동작
- 리터럴의 일부가 아닌 문자는 모두 무시

~parseInt()~
- 정수 부분만 유지
- 0x 또는 0X로 시작할 경우 16진수로 해석
- 시작부분의 공백은 무시, 숫자를 최대한 해석한 두 숫자 아닌 부분은 무시
- 첫번째 숫자가 유효한 숫자 리터럴이 아니라면 NaN 반환
- 선택으로 두번째 인수로 기수를 받습니다

~parseFloat()~
- 정수와 부동소수점 숫자 모두 유지
- 시작부분의 공백은 무시, 숫자를 최대한 해석한 두 숫자 아닌 부분은 무시
- 첫번째 숫자가 유효한 숫자 리터럴이 아니라면 NaN 반환
**** 객체를 기본 값으로 변환
자바스크립트가 객체를 기본 값으로 변환하는 규칙이 복잡한 이유 중 하나는 일부 객체는 *여러 가지* 기본 값으로 표현될 수 있다는 점입니다

객체를 기본 값으로 변환하는 알고리즘
- 문자열 선호
  - 기본 값을 반환할 때 문자열로 변환할 수 있다면 문자열 값을 우선합니다
- 숫자 선호
  - 기본 값을 반환할 때 숫자로 변환할 수 있다면 숫자 값을 우선합니다
- 선호 없음
  - 어떤 기본 타입을 선호하는지 정해 놓지 않았으며, 클래스에서 변환 방법을 정의할 수 있습니다

Date를 제외한 모든 타입: 숫자 선호
Date클래스: 문자열 선호
***** 객체를 불로 변환
모든 객체는 true로 변한됩니다
***** 객체를 문자열로 변환
객체를 문자열로 변한해야 할 때
문자열 선호 알고리즘을 사용해 기본 값으로 변환한 다음, 규칙에 따라 그 기본 값을 문자열로 변환합니다
- 문자열 인자를 예상하는 내장 함수에 객체를 전달할 때
- String()을 변환 함수로 호출할 때
- 템플릿 리터럴에 객체를 사용할 때
***** 객체를 숫자로 변환
객체를 숫자로 변환해야할 때
숫자 선호 알고리즘에 따라 기본 값으로 변환한 다음, 규칙에 따라 그 가본 값을 숫자로 변환합니다
- 숫자 인자를 예사하는 내장 함수에 객체를 전달할 때
- 숫자 피연산자를 예상하는 연산자 대부분
***** 특별한 케이스인 연산자 변환
****** + 연산자
~+~ 연산자의 피연산자 중 하나가 객체라면 자바스크립트는 해당 피연산자를 선호 없음 알고리즘에 따라 기본 값으로 변환합니다
알고리즘을 적용해서 두 개의 기본 값이 남으면 타입을 체크합니다
- 피연산자 중 하나라도 문자열이면 다른 하나도 문자열로 변환한 다음 병합합니다
- 피연산자 모두 문자열이 아니라면 둘 다 숫자로 변환한 다음 더합니다
****** ==, !=
~==~, ~!=~ 연산자는 타입 변환을 허용합니다
피연산자 중 하나가 객체이고 다른 하나가 기본 값이라면 선호 없음 알고리즘을 써서 객체를 기본 값으로 변한한 다음 비교합니다
****** <, <=, >, >=
피연산자 중 하나가 객체라면 숫자 선호 알고리즘을 통해 기본값으로 변환합니다
여기서 숫자 선호 알고리즘이 반환하는 기본 값은 숫자로 변환되지 않습니다
***** toString(), valueOf() 메서드
~toString()~
- 객체의 문자열 표현을 반환합니다


~valueOf()~
- 객체를 표현하는 기본 값이 존재한다면 그 값으로 객체를 변환합니다
  - 아니라면 기본 값이 아니라 객체 자체를 반환합니다
****** 객체에서 기본 값으로 변환하는 알고리즘
******* 문자열 선호 알고리즘
1. ~toString()~ 메서드를 시도합니다
2. ~toString()~ 이 존재하지 않거나 객체를 반환한다면
   ~valueOf()~ 메서드를 시도합니다
3. ~valueOf()~ 이 존재하지 않거나 객체를 반환한다면
   ~TypeError~ 가 일어납니다
******* 숫자 선호 알고리즘
문자열 선호 알고리즘과 비슷하지만 ~valueOf()~ 를 먼저 시도하고 ~toString()~ 을 두번째로 시도 합니다
******* 선호 없음 알고리즘
Date 객체일 경우 문자열 선호 알고리즘
그 외의 알고리즘은 숫자 선호 알고리즘
*** 변수 선언과 할당
자바스크립트 프로그램에서 변수나 상수를 쓰기 전엔 반드시 선언을 먼저 해야합니다

상수의 값을 바꾸려 하면 ~TypeError~ 가 일어납니다
**** 변수와 상수 스코프
변수의 *스코프*(scope)는 프로그램 소스 코드에서 해당 변수가 정의된 영역


***** 전역변수/상수
선언이 어떤 코드 블록에도 속하지 않고 최상위 레벨에 있을 경우 전역 변수/상수 라고 부르며
이들은 전역 스코프를 가집니다
**** var를 사용한 변수 선언
[ var ]
- 함수 바디를 스코프로 가집니다
- var로 선언된 전역 변수는 전역객체의 프로퍼티로 존재합니다
  - var로 선언된 전역 변수는 ~delete~ 연산자로 삭제할 수 없습니다
- 같은 변수를 중복 선언 가능
- 호이스팅
  - 초기화는 코드상의 위치에 그대로 존재하지만 정의만 함수 맨 위로 올라가는 것
  - 결과적으로 ~var~ 로 선언한 변수는 함수 어디에서든 에러 없이 사용할 수 있음


[ const, let ]
- 블록 스코프로 가집니다
- let과 const로 선언한 전역변수/상수는 전역 객체의 프로퍼티가 아닙니다
**** 분해 할당(destructuring assignment)
선언과 할당을 합친 복합 문법


할당 연산자의 오른쪽의 값은 배열, 객체 같은 *구조적인* 값
할당 연산자의 왼쪽의 값은 배열이나 객체 *리터럴* 문법


오른쪽 값에서 하나 이상의 값을 *추출(분해)* 해서 왼쪽에 있는 변수에 할당

분해 할당은 함수의 매개변수를 정의할 때도 사용할 수 있음
#+begin_src javascript
function printMovie({ title, director }) {
  console.log(`Title: ${title}, Director: ${director}`);
}

const movie = {
  title: "Inception",
  director: "Christopher Nolan",
  year: 2010
};

printMovie(movie); // Title: Inception, Director: Christopher Nolan

#+end_src

왼쪽의 변수 숫자와 오른쪽의 값 숫자가 꼭 일치할 필요가 없습니다
- 왼쪽의 변수가 남으면 ~undefined~ 가 할당되고
  - 왼쪽 변수 리스트에 콤마를 추가로 넣어서 일부를 무시할 수 있습니다
- 오른쪽의 값이 남으면 무시됩니다

*마지막* 변수 이름 앞에 점 세개(...)를 써서 배열을 분해하고 남은 값을 변수 하나에 모을 수 있습니다

분해 할당의 오른쪽에는 *이터러블 객체* 면 무엇이든 쓸 수 있습니다
- for/of 루프에 사용할 수 있는 객체는 분해할당 역시 가능합니다

객체 분해 할당의 왼쪽에 있는 각 식별자에는 콜론(:)으로 구분한 *식별자 쌍* 을 쓸 수 있습니다
- 첫번째는 분해하는 *객체의 프로퍼티 이름* , 두번째는 그 프로퍼티의 값을 *할당받을 변수 이름* 입니다
***** 예제
#+begin_src javascript
  let [x,y] = [1,2];    // let x=1, y=2와 같습니다.
  [x,y] = [x+1,y+1];    // x = x + 1, y = y + 1과 같습니다.
  [x,y] = [y,x];        // 두 변수의 값을 바꿉니다.
  [x,y]                 // => [3,2]: 값을 증가시킨 후 서로 바꿨습니다

  // [x,y] 좌표를 [r,theta] 극좌표로 변환합니다
  function toPolar(x, y) {
      return [Math.sqrt(x*x+y*y), Math.atan2(y,x)];
  }

  // 극좌표를 카르테시안 좌표로 변환합니다.
  function toCartesian(r, theta) {
      return [r*Math.cos(theta), r*Math.sin(theta)];
  }

  let [r,theta] = toPolar(1.0, 1.0);    // r == Math.sqrt(2); theta = Math.PI/4
  let [x,y] = toCartesian(r,theta);     // [x,y] == [1.0, 1.0]

  let o = { x: 1, y: 2};        // 순회할 객체
  for(const [name, value] of Object.entries(o)) {
      console.log(name, value); // "x 1", "y 2"
  }

  let [x,y] = [1];      // x == 1; y == undefined
  [x,y] = [1, 2, 3];    // x == 1; y == 2
  [,x,,y] = [1,2,3,4];  // x == 2, y == 4

  let [x, ...y] = [1,2,3,4];    // y == [2,3,4]

  let [a, [b, c]] = [1, [2,2.5], 3];    // a == 1; b == 2; c == 2.5

  let [first, ...rest] = "Hello";       // first == "H"; rest == ["e","l","l","o"]

  let transparent = {r: 0.0, g: 0.0, b: 0.0, a: 1.0};   // RGBA 색깔
  let {r, g, b} = transparent;  // r == 0.0, g == 0.0; b == 0.0

  // const sin=Math.sin, cos=Math.cos, tan=Math.tan과 같습니다
  const {sin, cos, tan} = Math;

  // const cosine = Math.cos, tangent = Math.tan과 같습니다.
  const { cos: cosine, tan: tangent } = Math;

  let points = [{x: 1, y: 2}, {x: 3, y: 4}];    // 좌표 객체가 두 개 있는 배열
  let [{x: x1, y: y1}, {x: x2, y: y2}] = points;        // 변수 네 개로 분해했습니다.
  (x1 === 1 && y1 === 2 && x2 === 3 && y2 === 4)        // => true

  let points = { p1: [1,2], p2: [3,4] };        // 배열 두 개가 있는 객체
  let { p1: [x1,y1], p2: [x2,y2] } = points;
  (x1 === 1 && y1 === 2 && x2 === 3 && y2 === 4)        // => true
#+end_src
*** 요약
- 자바스크립트에서 숫자와 문자열을 만들고 조작하는 법
- 자바스크립트의 다른 기본 타입인 불, 심벌, null, undefined 를 다루는 법
- 불변인 기본타입과 가변인 참조타입이 차이
- 자바스크립트가 묵시적으로 타입을 변환하는 과정, 그리고 프로그램에서 직접 변환하는 법
- 상수와 변수를 선언하고 초기화하는 법(분해할당 포함), 선언하는 변수와 상수의 어휘적 스코프
** 표현식과 연산자
표현식이란 어떤 값으로 평가(evaluate) 되는 구절입니다
*** 기본 표현식
단독으로 존재하며 자신보다 더 단순한 표현식을 포함하지 않습니다
- e.g. 상수, 리터럴 값, 일부 키워드, 변수 참조(전역 객체의 프로퍼티)
*** 객체와 배열 초기화 표현식
초기화 표현식(initializer)는 그 값이 새로 생성된 객체나 배열인 표현식
- 프로퍼티와 요소 값을 지정하는 다양한 하위 표현식으로 구성됨로 기본 표현식은 아니다
**** 배열 초기화 표현식
콤마 사이의 값을 생략하면 정의되지 않은 요소가 그 자리에 들어갑니다
*** 함수 정의 표현식
함수를 정의하며 그 값은 함수입니다
*** 프로퍼티 접근 표현식
객체 프로퍼티나 배열 요소의 값으로 평가됩니다

*expression . identifier*
- 표현식(expression)은 객체를 나타내고 식별자(identifier)는 원하는 프로퍼티 이름입니다
*expression [ expression ]*
- 표현식(expression)은 객체나 배열을 나타내고 표현식(expression)는 프로퍼티 이름이나 배열 요소 인덱스입니다

첫번째 값이 null이나 undefined이면 이 둘은 프로퍼티를 가질 수 없는 값이므로 표현식은 TypeError를 일으킵니다

프로퍼티 이름에 스페이스나 구두점이 들어 있거나, 숫자인 경우(배열)에는 *대괄호 사용*
**** 조건부 프로퍼티 접근
ES2020에서 추가된 새로운 프로퍼티 접근 표현식
*expression?.identifier*
*expression?.[expression]*

왼쪽에 있는 표현식이 null이나 undefined로 평가될 때 TypeError가 일어납니다
이런 에러를 막고자 다음의 문법이 추가되었습니다
- null이나 undefined라면 표현식 결과값은 undefined로 평가됩니다

옵션 체인: 단축 평가
- ~?.~ 의 왼쪽에 있는 하위표현식이 null이나 undefined로 평가되면 더는 프로퍼티에 접근하려 시도하지 않고 전체표현식이 *즉시* undefined로 평가합니다
*** 호출 표현식
호출표현식은 함수나 메서드를 호출(실행)하는 문법입니다

호출표현식 맨 앞에 있는 표현식이 프로퍼티 접근 표현식이라면 이 호출식은 *메서드 호출* 입니다
- 메서드 호출에서 프로퍼티 접근 대상인 *객체 또는 배열* 은 함수 바디가 실행되는 동안 *this* 키워드의 값이 됩니다

이렇게 함수가 자신이 속한 객체에 작용하는 객체지향프로그래밍 패러다임을 자바스크립트에서도 사용할 수 있습니다
**** 조건부 호출
() 대신 ?.() 를 통해 함수를 호출할 수 있습니다
- 왼쪽 값이 null인지 undefined인지만 체크합니다. 이 값이 실제로 함수인지까지는 체크하지 않습니다
*** 객체 생성 표현식
객체를 생성하고 함수(생성자)를 호출해 객체 프로퍼티를 초기화합니다
- 호출 표현식과 같지만 그 앞에 ~new~ 키워드 붙입니다

객체 생성 표현식에서 생성자 함수에 전달할 인자가 없다면 다음과 같이 빈 괄호는 생략할 수 있습니다

객체 생성 표현식의 값은 새로 생성된 객체입니다
*** 연산자 개요
자바스크립트에서 왼쪽값(lvalue)는 변수, 객체 프로퍼티, 배열 요소에 해당합니다
**** 연산자 우선순위
연산자 우선순위는 동작 순서를 결정합니다

우선순위가 높은 연산자는 우선순위가 낮은 연산자보다 먼저 실행됩니다

#+begin_src javascript
  // 우선순위 '*' > '+' > '='
  w = x + y * z;
#+end_src
**** 연산자 결합성
결합성은
- 왼쪽에서 오른쪽으로 연산하는 좌결합성
- 오른쪽에서 왼쪽으로 연산하는 우결합성

연산자의 결합성은 우선순위가 같은 동작을 수행할 때의 순서입니다
**** 평가 순서
하위 표현식은 항상 왼쪽에서 오른쪽으로 평가합니다
#+begin_src javascript
  // w를 첫 번째 평가하고, 그 다음 x, y, z를 순서대로 평가합니다
  // 그런 다음 y와 z의 값을 곱하고, x의 값을 더하고 w에 할당합니다
  w = x + y * z
#+end_src
*** 산술 표현식
**** / 연산자
자바스크립트에서는 모든 숫자가 부동소수점이므로 나눗셈의 결과 역시 항상 부동소수점입니다
**** % 연산자
결과의 부호는 첫번째 피연산자를 따릅니다
**** + 연산자
'+' 연산자의 변환 규칙은 문자열 병합에 우선순위가 있습니다
- 피연산자 중 하나가 문자열, 또는 문자열로 변환할 수 있는 객체라면 다른 피연산자를 문자열로 변환하고 둘을 병합합니다
- 두 피연산자 모두 문자열로 판단할 수 없을 때에만 덧셈을 수행합니다
**** 단항 산술 연산자
단항 산술 연산자는 필요하다면 피연산자를 숫자로 변환합니다
**** 비트 연산자
비트 연산자는 숫자의 이진 표현의 비트를 대상으로 저수준 조작을 수행합니다

비트 연산자는 피연산자 값이 64비트 부동 소수점 값이 아니라 32비트 정수인 것처럼 동작합니다
- 피연산자를 숫자로 변환하고, 그 숫자 값에서 소수 부분과 32번째 이후의 비트를 모두 버려서 32비트 정수로 강제변환(coerce) 합니다

시프트 연산자의 오른쪽 피연산자는 0 이상 31 이하여야 합니다.
- 시프트 연산자는 이 피연산자를 부호 없는 32비트 정수 로 변환한 다음 다섯 번째를 넘어가는 비트를 모두 버려서 적절한 범위의 숫자로 
만듭니다

*** 관계 표현식
**** 비교 연산자
비교는 숫자와 문자열에 대해서만 가능하므로, 피연산자는 숫자나 문자열로 변환됩니다
- 피연산자 중 하나가 객체로 평가되면 그 객체를 기본값으로 변환합니다
- 문자열이 아닌 피연산자가 있다면 두 피연산자를 숫자로 변환한 후 비교합니다
- 비교연산자는 숫자와 BigInt 비교를 허용합니다
**** in 연산자
왼쪽 피연산자가 문자열, 심벌, 문자열로 변환될 수 있는 값이라고 예상합니다
오른쪽 피연산자가 객체라고 예상합니다
in 연산자는 왼쪽 피연산자가 오른쪽 객체의 프로퍼티 이름일 경우 ~true~ 를 반환합니다
**** 'instanceof' 연산자
~instanceof~ 연산자는 왼쪽 피연산자가 객체, 오른쪽 피여산자는 객체의 클래스라고 예상합니다

~o instance of f~
- f.prototype 을 평가한 후 o 의 프로토타입 체인에서 그 값을 찾습니다
- 그런 값을 찾으면 o 는 f 의 인스턴스(서브클래스) 이며 연산자는 true 를 반환합니다
*** 논리 표현식
**** 불 OR(||)
이 연산자는 몇 가지 변수 중에서 첫번째로 등장하는 true 같은 값을 선택하려 할 때 자주 사용합니다
#+begin_src javascript
  // maxWidth 가 true 같은 값이면 그걸 사용합니다. 그렇지 않으면
  // preferences 객체에서 값을 찾습니다. 그 역시 true 같은 값이 아니면 상수 리터럴을 사용합니다.
  let max = maxWidth || preferences.maxWidth || 500;
#+end_src
0 은 falsy 이기 때문에 정확히 동작하지 않을 수 있습니다
**** 불 NOT(!)
! 연산자는 피연산자를 불 값으로 변환한 다음 부정합니다
- 따라서 ! 은 항상 true 또는 false를 반환합니다
*** 할당 표현식
할당 표현식의 값은 오른쪽 피연산자의 값입니다
*** 평가 표현식
~eval()~
문자열을 자바스크립트 코드로 해석하고 평가해서 값을 얻을 수 있습니다
*** 기타 연산자
**** null 병합 연산자 (??)
왼쪽 피연산자가 null 이나 undefined 로 평가될 때만 두번째 피연산자를 반환합니다

~??~ 는 truthy 값이 아닌(||) '정의된' 피연산자를 확인하고자 할 때 사용할 수 있는 연산자입니다

#+begin_src javascript
  let options = { timeout: 0, title: "", verbose: false, n: null };
  options.timeout ?? 1000       // => 0: 객체에 정의된 대로
  options.title ?? "Untitled"   // => "": 객체에 정의된 대로
  options.verbose ?? true       // => false: 객체에 정의된 대로
  options.quiet ?? false        // = false: quiet 프로퍼터가 정의되지 않았으므로 오른쪽 값
  options.n ?? 10               // => 10: 프로퍼티가 null 이므로 오른쪽 값
#+end_src

필자는 nullish coalescing(null을 병합하는) 연산자 보다는
first-defined(첫 번째 정의된)라는 이름을 사용합니다
이 연산자는 피연산자 중 하나를 선택할 뿐 '병합'하지는 않는다고 생각하기 때문입니다
**** typeof 연산자
~typeof~ 은 단항 연산자이며 피연산자의 타입을 가리지 않습니다
값은 피연산자의 타입을 나타내는 문자열입니다

피연산자의 값이 ~null~ 일 때 "object"를 반환합니다
- ~null~ 과 객체를 구별하고 싶다면 직접 테스트해야 합니다

함수도 일종의 객체이지만 "function"을 반환합니다
그 외의 함수가 아닌 객체 전체(배열포함)을 "object" 라고 평가합니다
**** delete 연산자
~delete~ 는 피연산자로 지정된 객체 프로퍼티나 배열 요소를 삭제하는 단항 연산자입니다
~delete~ 는 피연산자가 프로퍼티 또는 인덱스라고 예상합니다
피연산자가 그런 값이 아니라면 연산자는 아무 행동을 취하지 않고 true 를 반환합니다
성공적으로 삭제하면 true를 반환합니다

변경 불가 프로퍼티는 삭제할 수 없습니다

삭제된 배열 요소나 프로퍼티에 ~undefined~ 값이 할당되는 것이 아니라
해당 프로퍼티는 더는 존재하지 않게 됩니다

배열 요소를 삭제하면 그 자리에 '구멍'이 생기지만 배열 길이가 달라지지는 않습니다
**** await 연산자
await 는 프라미스 객체를 피연산자로 예상하고, 프로그램이 (비동기)연산이 끝나길 기다리는 것처럼 동작합니다
- 실제로 기다리지는 않고 넘어가며 다른 비동기 동작도 동시에 일어날 수 있습니다
- await 연산자의 값은 프라미스 객체가 어떻게 이행됐는지 나타내는 값입니다
- await 는 오직 async 키워드로 선언된 비동기 함수 안에서만 동작합니다
**** void 연산자
void 는 피연산자를 평가한 후 그 값을 버리고 undefined 를 반환합니다
- 피연산자의 값이 버려지므로, void 연산자는 피연산자에 부수효과가 있을때에만 의미가 있습니다
**** 콤마 연산자 (,)
연산자는 왼쪽 피연산자를 평가하고, 오른쪽 피연산자를 평가한 후 오른쪽 피평가자의 값을 반환합니다
*** 요약
- 표현식은 자바스크립트 프로그램의 구절(phrase) 와 같습니다
- 표현식은 모두 자바스크립트 값으로 평가될 수 있습니다
- 표현식에는 값으로 평가되는 것 외에도 변수할당 같은 부수 효과가 있을 수 있습니다
** 문
표현식을 자바스크립트의 구절이라고 설명한다면
문은 자바스크립트의 문장이나 명령어라고 할 수 있습니다

자바스크립트 문은 세미콜론으로 끝납니다


표현식은 '평가'를 통해 값으로 바뀌지만
문은 '실행'을 통해 어떤 동작을 수행합니다


할당이나 함수호출처럼 부수효과가 있는 표현식은 그 자체로 문이 될 수 있으므로
이런 표현식을 표현문(expression statement)라고 부릅니다

자바스크립트 프로그램은 문의 모음입니다

제어문(control structure): 기본 실행 순서를 변경합니다
- 조건문: 표현식의 값에 따라 다른 문을 실행하거나 실행하지 않습니다
- 루프: 다른 문을 반복적으로 실해하는 문
- 점프
*** 표현문
할당식
delete 연산자를 포함한 식
함수 호출
*** 복합문과 빈 문
문 블록은 문 여러 개를 묶어 *복합문* 으로 만듭니다
복합문은 문 하나를 예상하는 곳이라면 어디든 쓸 수 있습니다
블록은 세미콜론으로 끝나지 않습니다


**** 빈 문
#+begin_src javascript
  // 배열 a를 초기화합니다
  for(let i = 0;i < a.length; a[i++] = 0) ;
#+end_src
루프가 하는 일은 전부 a[i++] = 0 표현식에 들어 있으므로
루프바디는 필요하지 않습니다
하지만 자바스크립트 문법은 루프 바디 안에 문이 있을 것을 요구하므로
세미콜론 하나만 써서 빈 문을 만들었습니다
*** 조건문
**** switch
모든 분기점이 같은 표현식의 값에 좌우된다면 else if 가 최선의 선택은 아닙니다

형태
- switch 문은 switch 키워드 뒤에 괄호로 둘러싼 표현식을 쓰고 그 뒤에 중괄호로 감싼 코드 블록을 쓰는 형태
- 코드 블록 곳곳에 case 키워드를 쓰고 그 뒤에 표현식과 콜론을 붙일 수 있습니다
- switch 문이 실행되면 먼저 expression 의 값을 평가한 후, case 라벨의 표현식 중에서 expression 과 같은 값으로 평가되는 것을 찾습니다
  - 이때 `===` 연산자를 기준으로 판단합니다
  - 일치하는 것을 찾으면 해당 case 의 코드블록을 실행합니다
  - 일치하는 것을 못찾았으면 default: 라벨을 찾습니다
    - default: 라벨조차 없으면 switch 문은 코드블록전체를 건너뜁니다
*** 반복문
**** for/of
ES6에서 정의한 반복문
이터러블 객체에서 동작
- 동적으로 순회합니다
  - 반복 중간에 배열 자체에 변화가 발생한다면 반복 결과가 바뀌기도 합니다
- 객체는 이터러블이 아닙니다
  - 객체의 프로퍼티를 순회하고자 한다면 for/in 루프를 사용하거나 Object.keys() 메서드에 for/of 를 사용해야 합니다
- 문자열을 *문자 단위* 로 순회합니다
  - UTF-16 문자가 아니라 유니코드 코드 포인트로 순회합니다
- Set과 Map 클래스는 이터러블 입니다
  - Map 객체의 이터레이터는 키-값 쌍(배열)을 순회합니다
***** for/await 를 사용한 비동기 순회
비동기 이터레이터를 도입하면서
for/of 루프를 변형한 for/await 루프를 도입했습니다
**** for/in
지정된 객체의 프로퍼티 이름을 순회합니다
- for/in 루프 대신 Object.keys() 와 for/of 루프를 선호하는 프로그래머도 있습니다

for (variable in object)
  statement
- variable에는 변수 이름, 변수 선언 등 lvalue의 무엇이든 가능합니다
- object 표현식이 null이나 undefined 로 평가되면 루프를 건너뜁니다
- variable 표현식을 평가하고 이름이 문자열인 *열거가능한(enumerable) 프로퍼티 이름* 을 할당하고
  각각에 루프바디를 실행합니다
  - 자바스크립트에서 정의하는 내장 메서드는 열거가능하지 않습니다
  - 열거 가능한 상속된 프로퍼티도 순회대상입니다

#+begin_src javascript
  for(let p in o) {             // o의 프로퍼티 이름을 변수 p에 할당합니다
      console.log(o[p]);        // 각 프로퍼티 값을 출력합니다
  }
#+end_src
*** 점프 문
점프문은 인터프리터가 소스 코드의 다른 위치로 이동하게 합니다

break문은 인터프리터를 루프를 비롯한 다른 문의 *끝으로* 이동시킵니다
continue문은 루프 바디의 나머지를 생략하고 루프 맨 위로 돌아가 새 반복을 시작하게 합니다
- 자바스크립트는 문에 라벨을 붙일 수 있게 허용하고 break와 continue은 이 라벨을 인식합니다
**** 라벨 붙은 문
어떤 문이든 그 앞에 식별자와 콜론을 붙여 라벨을 만들 수 있습니다
identifier: statement

문 라벨을 이용하는 문은 break 와 continue 뿐입니다

라벨의 네임스페이스는 변수나 함수의 네임스페이스와는 다릅니다
- 같은 식별자를 문 라벨에 쓰고 다시 변수와 함수의 이름에 쓸 수 있습니다
**** break
break 문은 단독으로 사용하면  자신을  포함하고  있는  가장  가까운  루프  또는 switch 문을 즉시 빠져나갑니다.
- 루프나 switch 문이 아니더라도 자신을 둘러싼 문이면 어떤 형태든 빠져나갈 수 있습니다
- break 문은 함수 외부에 있는 라벨을 볼 수 없습니다

break labelname;
- break 문에 라벨을 사용하면 해당 라벨이 붙은 문을 종료합니다
- break 를 포함하는 문에 라벨이 없을 때는 문법 에러가 일어납니다
**** continue
continue 문은 라벨이 있든 없든 루프 바디 안에서만 사용할 수 있습니다.
**** throw
throw expression
- expression 은 어떤 타입의 값으로든 평가될 수 있습니다
- 인터프리터는 에러를 일으킬 때 Error 클래스와 그 서브클래스를 사용합니다

예외가 일어나면 인터프리터는 프로그램 실행을 멈추고 가장 가까운 예외 핸들러(catch 절)로 점프합니다
**** try/catch/finally
catch 와 finally 블록은 모두 선택 사항이지만 try 블록 뒤 에 둘 중 하나는 반드시 써야 합니다

#+begin_src javascript
  try {
}
catch(e) {
    // 이 블록의 문은 try 블록에서 예외를 일으켰을 때만 실행됩니다 .
    // 이 문은 로컬 변수 e 를 사용할 수 있으며 이 변수는
    // Error 객체 또는 전달받은 값을 참조합니다
    // 이 블록은 예외를 처리할 수도 있고 ,
    // 아무 일도 하지 않고 무시할 수도 있으며 ,
    // throw 를 통해 다시 예외를 일으킬 수도 있습니다 .
}
finally {
    // 이 블록은 try 블록에서 무슨 일이 있었든 항상 실행됩니다 .
    // 경우의 수는 다음과 같습니다
    //   1) 정상적으로 try 블록의 끝에 도달한 경우
    //   2) break, continue, return 문을 통해 try 블록을 빠져나가는 경우
    //   3) 위 catch 절에서 처리한 예외 때문에 try 블록이 종료된 경우
    //   4) 예외가 캐치되지 않고 계속 전파되는 경우
}
#+end_src

예를 들어 finally 절에서 예외를 일으키면 그 예외는 처리 중이 던 예외를 모두 무시하고 우선권을 갖습니다.
finally 절에 return 문이 포함되어 있으면 처리 중이던 예외가 완전히 처리되지 않았더라도 함수 실행을 종료합니다
***** 단순 catch 절
ES2019 이후에는 괄호와 식별자를 생략하고 catch 키워드만 쓸 수 있습니다

#+begin_src javascript
  // JSON.parse() 를 실행하지만 에러를 일으키지 않고 undefined 를 반환합니다
  function parseJSON(s) {
      try {
          return JSON.parse(s);
      } catch {
          // 뭔가 문제가 있지만 신경 쓰지 않습니다.
          return undefined;
      }
  }
#+end_src
*** 기타 문
**** with
이 문은 폐기된 것으로 간주하고 사용하지 말아야합니다
with 를 사용하는 자바스크립트 코드는 최적화하기 어려우며 느리게 동작하게 됩니다
**** debugger
debugger 문은 디버거 프로그램이 존재하고 실행중이라면 실행 환경에 따라서 일종의 디버깅동작(중단점)을 수행할 수 있습니다
**** "use strict"
"use strict"은 ES5에서 도입한 지시자(directive)입니다
- 이 지시자는 스크립트나 함수 바디의 맨 처음에만 존재할 수 있습니다
- 이 지시자는 이후의 코드가 스트릭트 모드를 따르는 코드라는 선언입니다
- class 바디나 모듈 안에 있는 코드는 자동으로 스트릭트 모드가 됩니다

스트릭트 모드는 자바스크립트의 중요한 결함을 수정하고 더 강력히 에러를 체크하며 보안을 강화한 것입니다
***** 지시자
- 지시자는 문이 아니지만, 문과 가깝습니다
- 지시자에는 아무란 키워드가 없습니다. 특별한 문자열 리터열로 구성된 *표현문* 입니다
*** 선언
const, let, var, function, class, import, export 키워드는 문이 아닙니다
선언은 프로그램에서 코드 실행을 시작하기 전에 처리하는 부분이라 생각할 수도 있습니다
**** 함수
함수 선언은 어떤 블록에 있든 해당 블록의 코드보다 먼저 처리되며,
함수 이름은 그 블록을 통틀어 함수 객체에 묶입니다
**** 클래스
함수와 달리 클래스 선언은 끌어올려지지 않습니다
**** 가져오기와 내보내기
import 와 export 선언은 다른 모듈에서 정의한 값을 사용할 수 있게 합니다

한 모듈에서 정의한 값(함수나 클래스)를 다른 모듈에서 사용하는 방법은
정의한 모듈에서 export로 값을 내보내고,
사용할 모듈에서 import 로 가져오는 방법 밖에 없습니다

***** 모듈
모듈은 자바스크립트 코드로 구성된 파일이며 독자적인 전역 네임스페이스를 갖고, 다른 모듈에 완전히 독립적입니다
***** import 지시자
import 지시자는 다른 모듈에서 하나 이상의 값을 가져오고, 현재 모듈에서 사용 할 이름을 부여합니다

#+begin_src javascript
  import Circle from './geometry/circle.js';
  import {PI, TAU} from './geometry/constants.js';
  import {magnitude as hypoteneuse} from './vectors/utils.js';
#+end_src
***** export 지시자
모듈의 갑은 비공개이며 명시적으로 내보내지 않는 한 다른 모듈에서 가져올 수 없습니다
#+begin_src javascript
  // geometry/constants.js
  const PI = Math.PI;
  const TAU = 2 * PI;
  export {PI, TAU};

  export const TAU = 2 * Math.PI;
  export function magnitude(x,y) {return Math.sqrt(x*x + y*y);}
  // 모듈에서 내보내는 값이 단 하나뿐일 때는 export default 를 사용합니다
  export default class Circle {}
#+end_src
*** 자바스크립트 문 요약
** 객체
*** 객체 소개
객체는 여러가지 값을 모아서 *이름* 을 통해 값을 저장하고 가져올 수 있게 합니다
객체는 '프로토타입'으로 불리는 다른 객체에서 프로퍼티를 상속하기도 합니다
객체는 프로퍼티의 *순서 없는 집합* 이며 각 프로퍼티에는 이름과 값이 있습니다
- 같은 이름의 프로퍼티는 존재할 수 없습니다
- 값은 자바스크립트 값이며, getter, setter 또는 둘 다 될 수 있습니다

**** 자체 프로퍼티(own property)
자바스크립트에서 상속되지 않은 (직접 정의한) 프로퍼티
**** 프로퍼티 속성
- 쓰기가능 속성은 프로퍼티에 *값을 설정할 수 있는지 없는지* 를 나타냅니다
- 열거가능 속성은 for/in 루프에 프로퍼티 이름을 반한할지 안 할지 나타냅니다
- 변경가능 속성은 프로퍼티를 *삭제* 할 수 있는지 없는지, *속성을 바꿀* 수 있는지 없는지를 나타냅니다
*** 객체 생성
객체를 생성할 때는 객체 리터럴, new 리터럴, ~Object.create()~ 함수를 사용합니다
**** 객체 리터럴
객체 리터럴은 *콜론* 으로 구분한 키-값 쌍을 *콤마* 로 구분해 *중괄호* 로 감싼 형태입니다

프로퍼티 이름은 식별자, 문자열 리터럴(빈문자열 포함)을 허용합니다
프로퍼티 값은 자바스크립트 표현식 무엇이든 가능합니다
**** new
새 객체를 생성하고 초기화합니다
new 키워드 뒤에는 반드시 함수(생성자) 호출이 있어야 합니다
- 생성자는 생성된 객체를 *초기화* 하는 목적으로 사용합니다
**** 프로토타입
자바스크립트 객체 대부분은 자신과 연결된 두번째 객체(프로토타입)를 갖습니다
- 첫번째 객체는 프로토타입에서 *프로퍼티를 상속* 합니다
- 거의 모든 객체에 프로토타입이 있지만, ~prototype~ 프로퍼티가 있는 객체는 비교적 적습니다
- ~prototype~ 프로퍼티를 갖는 객체가 다른 객체의 프로토타입을 정의합니다

*객체 리터럴* 를 사용해 생성한 객체는 모두 같은 프로토타입 객체를 갖습니다
- 이 프로토타입 객체는 ~Object.prototype~ 이라는 코드로 참조 가능합니다

*new* 키워드와 생성자를 사용해 만든 객체는 *생성자 함수의 prototype 프로퍼티* 값을 자신의 프로토타입으로 사용합니다
- new Object() => Object.prototype 값
- new Array() => Array.prototype 값

Object.create() 는 첫번째 인자를 프로토타입 삼아 새 객체를 생성합니다
선택사항으로 새 객체의 프로퍼티를 설명하는 두번째 인자를 받을 수 있습니다
Object.create() 의 목적 중 하나는 객체를 변경하는 사고를 막는 것입니다
***** 프로토타입 체인
프로토타입 객체 사이의 연결
- e.g. Date.prototype 은 Object.prototype 에서 프로퍼티를 상속하므로 new Date()로 생성한 Date 객체는 Date.prototype 과 Object.prototype 양쪽에서 프로퍼티를 상속합니다
*** 프로퍼티 검색과 설정
프로퍼티 값에 접근할 때는 점(.)이나 대괄호([]) 연산자를 사용합니다
- 점 연산자의 오른쪽 피연산자는 식별자여야합니다
- 대괄호 연산자의 피연산자는 문자열(또는 심벌)로 평가되는 표현식이어야합니다

**** 연관배열
문자열을 인덱스로 사용하는 배열

자바스크립트 객체는 연관배열입니다
**** 상속
객체의 prototype 속성은 자신이 어디에서 프로퍼티를 상속했는지 나타내는 체인을 형성합니다

프로퍼티 할당
- 프로퍼티 할당은 실패하거나, *원래 객체* 에 프로퍼티를 생성 또는 설정합니다
  - x 프로퍼티가 세터 메서드가 있는 접근자 프로퍼티라면 원래 객체에 세터 메서드를 호출합니다
**** 프로퍼티 접근 에러
자체 프로퍼티나 상속된 프로퍼티에서 x 프로퍼티를 찾지 못한다면 접근식은 undefined로 평가됩니다

- 자체 프로퍼티가 있고, 읽기 전용일 때
  - 읽기 전용 프로퍼티의 값은 바꿀 수 없습니다
- 상속된 프로퍼티가 있고, 읽기 전용일 때
  - 상속된 읽기전용 프로퍼티를 가릴 수 없습니다
- 세터 메서드로 프로퍼티를 상속하지 않고 프로퍼티 확장가능 속성이 false 일 때
*** 프로퍼티 삭제
delete 연산자의 피연산자는 프로퍼티 접근 표현식입니다
값을 삭제하는 것이 아니라 프로퍼티 자체를 삭제합니다

delete 연산자는 자체프로퍼티만 삭제할 뿐 상속된 프로퍼티는 삭제하지 않습니다
delete는 변경가능속성이 false 인 프로퍼티는 제거하지 않습니다
*** 프로퍼티 테스트
주어진 이름을 가진 프로퍼티가 객체에 존재하는지 확인해야할 때
- in 연산자, ~hasOwnProperty()~, ~propertyIsEnumerable()~, 프로퍼티 검색

**** in 연산자
propertyName in object

객체에 그런 propertyName 을 가진 자체 프로퍼티나 상속된 프로퍼티가 있다면 true 를 반환합니다

검색과 달리 값이 undefined 인 프로퍼티를 구분할 수 있습니다
**** hasOwnProperty()
자체 프로퍼티가 있는지 테스트합니다
**** propertyIsEnumerable()
자체 프로퍼티이며 열거 가능 속성이 true일 때만 true 를 반환합니다
*** 프로퍼티 열거
**** for/in
객체의 열거 가능 프로퍼티마다 그 이름을 루프 변수에 할당하면서 바디를 실행합니다
**** 프로퍼티 이름을 배열로 반환
- ~Object.keys()~ *열거 가능한 자체 프로퍼티 이름* 을 배열로 반환합니다
  - 열거불가 프로퍼티, 상속된 프로퍼티, 이름이 심벌인 프로퍼티는 내보내지 않습니다
- ~Object.getOwnPropertyNames()~ 이름인 문자열인 자체 프로퍼티이름을 배열로 반환합니다
- ~Object.getOwnPropertySymbols()~ 이름이 심벌인 자체 프로퍼티를 배열로 반환합니다
- ~Reflect.ownKeys()~ 문자열인지 심벌인지도 구분하지 않고 자체 프로퍼티이름은 모두 배열로 반환합니다
**** 프로퍼티 열거 순서
*** 객체 확장
객체의 프로퍼티를 다른 객체에 복사합니다
**** Object.assign()
ES6에 도입되었습니다
- 두 개 이상의 객체를 받습니다
  - 첫 번째 인자는 수정해서 반환할 대상(target) 객체이지만,
  - 두 번째 또는 그 이후의 인자는 소스(source) 객체입니다
- 각 소스 객체의 *열거가능한 자체 프로퍼티(심볼 포함)* 을 대상 객체에서 복사합니다
- 소스 객체에 게터메서드가 있거나 대상 객체에 세터 메서드가 있다면 복사 도중에 이들이 호출되지만 메서드 자체는 복사하지 않습니다

*** 객체 직렬화
객체 직렬화는 객체를 문자열로 변환하는 작업입니다
(~JSON.stringify()~, ~JSON.parse()~)

**** JSON
JSON은 데이터 교환 형식입니다
JSON은 자바스크립트 객체 표기법입니다(JavaScript Object Notation)

~JSON.stringfy()~ 는 *열거 가능한 자체 프로퍼티* 만 직렬화합니다
~JSON.parse()~, ~JSON.stringfy()~ 는 모두 직렬화와 복원 방법을 지정하는 두 번째 인자를 선택사항으로 받을 수 있습니다
- 직렬화에 포함할 프로퍼티 리스트, 직렬화에 사용할 값 등을 지정할 수 있습니다

JSON 문법은 자바스크립트 문법의 부분집합이며
자바스크립트 값 전체를 표현하지 못합니다
- 객체, 배열, 문자열, 유한한 숫자, true, false, null 은 모두 지원됩니다
- NaN, Infinity, -Infinity 는 null 로 직렬화됩니다
- Date 객체는 ISO 형식 날짜 문자열로 직렬화딥니다
  - JSON.parse() 는 이 문자열을 그대로 문자열로 둘 뿐 Date 객체로 복원하지 않습니다
*** 객체 메서드
**** ~toString()~ 메서드
이 메서드는 호출한 객체의 값을 나타내는 문자열을 반환합니다

자바스크립트는 객체를 문자열로 변환해야 할 때마다 이 메서드를 호출합니다
- e.g. + 연산자로 문자열과 객체를 병합할 때, 문자열을 예상하는 함수에 객체를 전달할 때 ...
**** ~toLocalString()~ 메서드
이 메서드의 목적은 지역에 맞는 문자열 표현을 반환하는 것입니다
**** ~valueOf()~ 메서드
객체를 문자열이 아닌 다른 기본 타입(e.g. 숫자)로 변환하려 할 때 호출합니다
**** ~toJSON()~ 메서드
~JSON.stringify()~ 메서드는 직렬화할 객체에서 ~toJSON()~ 메서드를 검색합니다
*** 확장된 객체 리터럴 문법
**** 단축 프로퍼티
객체의 프로퍼티에 프로퍼티 이름과 똑같은 식별자로 할당하고자 할 때 사용가능 합니다
**** 계산된 프로퍼티 이름
대괄호 안에는 임의의 자바스크립트 표현식이 들어갑니다.
표현식을 평가한 값을 프로퍼티 이름으로 사용하며, 필요하다면 문자열로 반환합니다
**** 프로퍼티 이름인 심벌
**** 분해 연산자
*객체 리터럴 안에서* 분해 연산자 ~...~ 를 사용해 기존 객체의 프로퍼티를 새 객체에 복사할 수 있습니다
- 자체 프로퍼티만 분해할 뿐 상속된 프로퍼티에는 적용되지 않습니다
**** 단축 메서드
ES6 전에는 객체 리터럴 안에 함수 정의 표현식을 써서 메서드를 정의했습니다
ES6 에서는 객체 리터럴 안에서 function 키워드와 콜론을 생략할 수 있습니다

#+begin_src javascript
  // ES6 이전
  let square = {
      area: function() {return this.side * this.side;},
      side: 10
  };

  // ES6 이후
  let square = {
      area() {return this.side * this.side; },
      side: 10
  };
#+end_src
**** 프로퍼티 게터와 세터
자바스크립트는 접근자 메서드 게터(getter), 세터(setter)를 갖는 접근자 프로퍼티(accessor property)


프로그램이 접근자 프로퍼티의 값을 *검색* 하면
인자 없이 게터 메서드를 호출합니다. 이 메서드의 반환 값이 프로퍼티 접근 표현식의 값입니다

프로그램이 접근자 프로퍼티의 값을 *설정* 하면
세터 메서드를 호출하고 할당 표현식의 오른쪽 값을 인자로 전달합니다
이 메서드가 프로퍼티 값 '세팅'을 담당합니다. 메서드의 반환 값은 무시합니다

메서드 이름은 프로퍼티 이름과 같습니다
접근자 프로퍼티는 데이터 프로퍼티와 마찬가지로 상속됩니다
***** 유스케이스
- 프로퍼티에 쓸 때(write) 유효성 검사를 하고
- 프로퍼티를 읽을 때마다 다른 값을 반환하는 경우

#+begin_src javascript
  // 이 객체는 점점 증가하는 시리얼 번호를 만듭니다.
  const serialNum = {
      // 이 데이터 프로퍼티에는 다음 시리얼 번호가 들어갑니다.
      // 프로퍼티 이름에 있는 _는 이 프로퍼티를 내부에서만 사용한다는 힌트입니다.
      _n: 0,

      // 현재 값을 증가시켜 반환합니다.
      get next() {return this._n++;},

      // n에 새 값을 할당하지만 현재 값보다 커야 합니다.
      set next(n) {
          if (n > this._n) this._n = n;
          else throw new Error("serial number can only be set to a larger value");
      }
   };
#+end_src
*** 요약
- 객체용어(열거 가능, 자체 프로퍼티 ...)
- (확장된)객체 리터럴 문법
- 프로퍼티를 읽고, 쓰고, 삭제하고, 열거하고, 확인하는 방법
- 프로토타입 기반 상속이 동작하는 방법, Object.create() 를 통해 다른 객체를 상속하는 객체를 만드는 방법
- Object.assign() 을 통해다른 객체로 프로퍼티를 복사하는 방법
** 배열
배열에는 모두 ~length~ 프로퍼티가 있습니다
- 성기지(sparse) 않은 배열에서 이 프로퍼티는 배열에 포함돈 요소 숫자입니다
- 성긴 배열에서는 배열 내 가장 큰 인덱스보다 큽니다

배열 인덱스(프로퍼티)는 0 이상 2^23 - 2 이하 범위에 속해야만 합니다

배열은 모두 객체이므로 어떤 프로퍼티든 만들 수 있습니다
배열 인덱스인 프로퍼티를 사용하면 배열에서 ~length~ 프로퍼티를 업데이트 합니다
*** 배열 생성
배열 생성방법
- 배열 리터럴
- 이터러블 객체에 분해 연산자 ~...~ 적용
- ~Array()~ 생성자
- ~Array.of()~ 와 ~Array.from()~ 팩토리 메서드
**** 배열 리터럴
배열 리터럴은 배열 요소를 대괄호 안에서 콤마로 구분한 리스트 형태
**** 분해 연산자
분해 연산자 ~...~ 를 써서 ~배열 리터럴 안에~ 다른 배열 요소를 넣을 수 있습니다
- 배열을 '분해'해서 그 요소를 배열 리터열 요소로 만듭니다

분해 연산자는 배열을 얕게 복사할 때 유용합니다

분해 연산자는 모든 *이터러블* 객체에 동작합니다
- 이터러블 객체는 ~for/of~ 루프의 대상이 될 수 있는 객체입니다

분해 연사자는 함수 호출에서 사용할 수 있습니다
**** 배열에서 중복된 요소 제거하기
배열을 세트로 변환한 다음 분해연산자를 써서 배열로 되돌리기

#+begin_src javascript
  let letters = [..."hello world"];
  [...new Set(letters)]
#+end_src
**** Array() 생성자
- 인자 없이 호출
  - 요소 없는 빈 배열을 생성하며 배열 리터럴 ~[]~ 과 동등합니다
- 배열 길이를 나타내는 숫자 인자 하나로 호출
  - 지정된 길이를 갖는 배열을 생성합니다
- 인자를 둘 이상 쓰거나, 숫자가 아닌 인자 하나로 호출
  - 인자가 새 배열의 요소가 됩니다
**** Array.of()
~Array()~ 생성자로는 숫자 요소가 하나만 있는 배열은 생성할 수 없습니다

이 함수는 인자의 개수를 따지지 않고 각 인자를 새 배열의 요소로 사용합니다
**** Array.from()
첫번째 인자로 *이터러블 객체* 나 *배열 비슷한 객체* 를 받고 해당 요소로 새 배열을 만들어 반환합니다
두번째 인자로 함수를 전달하면, 소스 객체의 각 요소를 이 함수에 전달하고 반환 값을 배열에 저장합니다
**** 배열 비슷한 객체
숫자인 ~length~ 프로퍼티가 있고
이름이 정수인 프로퍼티에 값이 저장된 객체
*** 배열 요소 읽기와 쓰기
*** 성긴 배열
성긴 배열은 인덱스가 연속적이지 않은 배열입니다

성긴 배열에서 요소를 검색하는 시간은 일반 객체 프로퍼티 검색에 필요한 시간과 비슷합니다
*** 배열 길이
배열의 ~length~ 프로퍼티를 현재 값보다 작은 양의 정수 n으로 지정할 때 인덱스가 ~n~ 이상인 배열요소는 모두 삭제합니다
*** 배열 요소 추가와 삭제
~push()~ 메서드는 배열 마지막에 값을 추가합니다
~pop()~ 메서드는 배열의 마지막 요소를 제거하고 그 값을 반환합니다
~shift()~ 메서드는 배열의 첫 번째 요소를 제거해 반환합니다

~delete~ 연산자로 배열 요소를 삭제할 수 있습니다
- ~length~ 프로퍼티는 변하지 않고 빈 공간을 메우지 않습니다
~length~ 프로퍼티를 수정해서 *배열의 맨 뒤에서부터* 요소를 삭제할 수 있습니다

~splice()~ 메서드
배열 요소를 삽입, 삭제, 대체하는 범용 메서드입니다
*** 배열 순회
~for/of~ 루프와 달리 ~forEach()~ 는 성긴배열을 인식하고 존재하지 않는 요소에 대해서는 함수를 호출하지 않습니다
*** 다차원 배열
*** 배열 메서드
배열 메서드를 다음의 그룹으로 나눕니다
- 배열 요소를 순회하는 이터레이터 메서드
- 배열의 앞/뒤에 요소를 추가하거나 삭제하는 스택,큐 메서드
- 큰 배열을 추출,삭제,삽입,충당,복사하는 하위배열 메서드
- 배열을 검색하고 정렬하는 메서드
**** 배열 이터레이터 메서드
배열 요소를 순서대로 함수에 전달하는 방식으로 동작합니다
배열 요소를 순회, 변환, 필터, 체크, 축소(reduce) 합니다

첫 번째 인자로 함수를 받으며 각 배열 요소에 대해 그 함수를 한 번씩 호출합니다
- 배열 요소의 값, 배열 요소의 인덱스, 배열 자체를 인자로 전달합니다
두 번째 인자로 객체를 받아 첫 번째 인자인 함수가 두 번째 인자의 메서드인 것처럼 호출됩니다
- 두 번째 인자가 첫 번째 인자 함수의 ~this~ 가 됩니다

성긴 배열이라면 존재하지 않는 요소에 대해서는 함수를 호출하지 않습니다
***** forEach()
~forEach()~ 메서드는 배열을 순회하며 각 요소에서 함수를 호출합니다

~forEach()~ 모든 요소를 함수에 전달하기 전에 반복을 멈추는 방법은 없습니다
***** map()
새 배열을 반환하며 기존 배열은 수정하지 않습니다
***** filter()
기존 배열의 일부만 포함하는 부분 집합을 반환합니다

성긴 배열에서 존재하지 않는 값은 건너뛰므로
반환하는 배열은 *항상* 빽빽한 배열입니다
***** find() 와 findIndex()
기준을 만족하는 첫 번째 요소를 찾는 즉시 순회를 멈춥니다
***** every() 와 some()
~every()~ 모든 요소에 대해 true 를 반환할 때만 true 를 반환합니다
~some()~ 은 하나라도 true 를 반환할 때 true 를 반환합니다

수학적인 관습에 따라
*빈 배열* 에 대해 ~every()~ 은 true 를 반환하고 ~some()~ 은 false 를 반환합니다
***** reduce() 와 reduceRight()
제공하는 함수를 사용해 배열 요소를 값 하나로 만듭니다

첫 번째 인자는 '축소' 동작을 행하는 함수입니다
이 함수는 값 두 개를 받아서 하나를 반환합니다
인자
- 여태까지 행한 '축소' 작업 결과
- 요소 값
- 인덱스
- 배열

두 번째 인자는 함수(첫 번째 인자)에 전달할 초깃값입니다


축소 함수를 다른 객체의 메서드로 호출해야 한다면 ~Function.bind()~ 메서드를 확인하십시오
***** flat() 과 flatMap() 을 사용한 배열 평탄화
~flat()~ 메서드는 기존 배열과 *같은 요소* 로 이루어진 '평탄한'(*중첩되지 않은*) 새 배열을 반환합니다

인자 없이 ~flat()~ 을 호출하면 한 단계만 평탄화합니다
평탄화 레벨을 늘리려면 인자를 전달하면 됩니다

~a.flatMap(f)~ 는 ~a.map(f).flat()~ 과 동등합니다
~flatMap()~ 을 배열의 각 요소를 결과 배열로 분해하는 일반화된 ~map()~ 이라고 볼 수 있습니다
기존 배열의 요소 일부를 빈 배열로 바꿔 평탄화 이후 남지 않게 할 수 있습니다
***** concat() 으로 배열 병합
기존 배열의 요소를 포함하고 그 뒤에 ~concat()~ 인자를 포함하는 새 배열을 만들어 반환합니다
인자에 배열이 있으면 배열 요소를 추가합니다
기존 배열을 수정하지 않습니다
**** 스택과 큐 메서드
~push()~ 와 ~pop()~ 메서드는 배열을 스택처럼 다루는 메서드입니다
두 메서드 모두 기존 배열을 수정합니다

~unshift()~ 와 ~shift()~
**** 하위 배열
***** slice()
배열의 하위 배열을 반환합니다
두 개의 인자는 반환될 슬라이스의 시작과 끝 위치를 나타냅니다
인자에 음수를 사용한다면 그 값에 배열 길이를 더한 값을 적용합니다
원래 배열을 수정하지 않습니다
***** splice()
배열에 요소를 삽입하거나 제거하는 범용 메서드입니다

첫 번째 인자는 삽입이나 제거를 시작할 위치입니다
두 번째 인자는 제거할 요소의 개수입니다
- 두번째 인자를 생략하면 시작지점부터 배열 마지막까지의 요소를 제거합니다
그 뒤에는 개수 제한 없이 인자를 쓸 수 있으며, 이들은 지정한 위치에서부터 배열에 삽입됩니다

제거된 요소로 이루어진 배열을 반환하며, 제거한 것이 없다면 빈 배열을 반환합니다
원래 배열을 *수정* 합니다

#+begin_src javascript
let a = [1,2,3,4,5,6,7,8];
a.splice(4);    // => [5,6,7,8];

a = [1,2,3,4];
a.splice(1,2);  // => [2,3];

a = [1,4];
a.splice(1,1);  // => [4]; a => [1]

a = [1,2,3,4,5];
a.splice(2,0,"a","b");  // => []; a => [1,2,"a","b",3,4,5]
a.splice(2,2,[1,2],3);  // => ["a", "b"];

#+end_src
***** fill()
배열의 요소 또는 슬라이스를 지정된 값으로 바꿉니다
원래 배열을 수정해 반환합니다


첫 번째 인자는 배열 요소로 사용할 값입니다
(선택사항) 두 번째 인자는 시작 인덱스입니다
(선택사항) 세 번째 인자는 마지막 인덱스입니다
***** copyWithin()
배열의 슬라이스를 복사해 새 위치에 붙여 넣습니다
배열을 수정해 반환하지만 길이는 바뀌지 않습니다

첫 번째 인자는 복사될 위치의 인덱스입니다
두 번째 인자와 세 번째 인자는 슬라이스 범위를 설정합니다

형식화 배열에 유용하며, C 표준 라이브러리 ~memmove()~ 함수를 모델로 만들어졌습니다
**** 배열 검색과 정렬 메서드
***** indexOf() 와 lastIndexOf()
~indexOf()~ 와 ~lastIndexOf()~ 는 인자와 배열 요소를 비교할 때 ~===~ 연산자를 사용합니다

객체 콘텐츠를 검색하려는 목적이라면 ~find()~ 메서드와 판별 함수를 사용하십시오
***** includes()
인자 하나를 받고 배열에 그 값이 포함되어 있으면 true 를, 그렇지 않다면 false 를 반환합니다
~includes()~ 메서드는 Set 객체의 포함 관계 테스트를 배열에 도입한 것이라고 생각할 수 있습니다

~indexOf()~ 는 NaN 을 못찾지만, ~includes()~ 는 NaN을 찾습니다
***** sort()
인자 없이 sort()를 호출하면 배열 요소를 알파벳순으로(문자열로 변환해서) 정렬합니다

비교함수
- 첫 번째 인자가 두 번째보다 앞에 있어야 한다면 0보다 작은 숫자를 반환합니다
- 첫 번째 인자가 두 번째보다 뒤에 있어야 한다면 0보다 큰 숫자를 반환합니다
***** reverse()
**** 배열을 문자열로 변환
재사용할 목적으로 배열 콘텐츠를 텍스트 형태로 바꾸기
- ~JSON.stringify()~
***** join()
배열 요소 전체를 문자열로 변환한 다음, 이들을 병합한 결과를 반환
각 요소를 구분하는 문자열을 선택사항으로 지정할 수 있습니다
- 지정하지 않으면 콤마가 사용됩니다
***** toString()
~join()~ 메서드를 인자 없이 호출하는 것과 동등합니다
**** 정적 배열 함수
~Array.isArray()~
~Array.of()~
~Array.from()~
*** 배열 비슷한 객체
배열의 특징
- 새 요소를 추가할 때마다 ~length~ 프로퍼티가 자동으로 업데이트 됩니다
- ~length~ 를 더 작은 값으로 변경하면 배열 요소를 그에 맞게 버립니다
- ~Array.prototype~ 에서 상속합니다
- ~Array.isArray()~ 가 true 를 반환합니다

배열 비슷한 객체
- ~length~ 프로퍼티가 있고 음이 아닌 정수 프로퍼티가 있습니다

클라이언트 사이트 자바스크립트에는 HTML 문서에서 *배열 비슷한 객체를 반환하는* 메서드가 많이 있습니다

배열 비슷한 객체는 ~Array.prototype~ 을 상속하지 않으므로 배열 메서드를 직접적으로 호출할 수 없습니다
~Function.call()~ 를 통해 간접적으로 호출할 수 있습니다
*** 배열인 문자열
자바스크립트 문자열은 UTF-16 유니코드 문자로 구성된 읽기전용배열 처럼 동작합니다
*** 요약
** 함수
함수는 한 번 정의하면 몇 번이고 호출할 수 있는 자바스크립트 코드 블록입니다

자바스크립트 함수는 매개변수화(parameterized) 됩니다
함수 정의에는 매개변수(parameter)라고 불리는 *식별자* 리스트가 있습니다
이들은 함수 바디에서 로컬 변수처럼 동작합니다
함수를 호출할 때는 매개변수에 값을 전달하는 이를 인자(argument) 라고 합니다

각 호출에는 호출 컨텍스트가 존재하며 이것이 'this' 키워드의 값입니다
객체를 통해 함수를 호출하면 그 객체가 호출 컨텍스트(this)가 됩니다
객체를 새로 만들 목적으로 설계한 함수를 *생성자* 라고 합니다

자바스크립트 함수는 객체입니다
- 프로퍼티를 정의하고 함수의 메서드를 호출하는 것도 가능합니다

클로저
- 자바스크립트 함수는 다른 함수 안에서 정의할 수 있으며
- 이렇게 정의된 함수는 자신이 정의된 *스코프의 변수* 에 접근할 수 있습니다
*** 함수 정의
*function* 키워드는 선언으로도 표현식으로도 사용할 수 있습니다
function 키워드 없이 '화살표 함수'로 함수를 정의할 수 있습니다
**** 함수 선언
<function identifier([parameter ...]) {} >

함수의 이름(identifier)는 변수이며
그 값은 함수 자체입니다
함수 선언문은 호이스팅 됩니다
**** 함수 표현식
표현식이나 문의 일부로서 존재하고 이름을 붙이지 않아도 됩니다
- 함수 표현식에 이름이 있으면, 로컬 함수 스코프에서 그 이름으로 함수 객체를 참조합니다 (e.g. 재귀호출)
**** 화살표 함수
화살표 함수는 문이 아니라 표현식입니다
*function* 키워드는 사용하지 않으며 함수 이름도 필요 없습니다
'=>'을 사용해 함수 매개변수와 함수 바디를 구분합니다

간결한 문법
- 함수 바디가 return 문 하나라면
  - return 키워드와 중괄호를 모두 생략하고 값을 반환하는 표현식 하나만으로 함수바디를 구성할 수 있습니다
  - 반환할 표현식이 객체 리터럴이라면 객체 리터럴을 명시적으로 괄호 안에 써서 함수 바디 중괄호와 객체 리터럴의 중괄호를 혼동하지 않게 합니다
    - 라벨 붙은 문으로도 분석할 수 있습니다
- 매개변수가 하나라면
  - 매개변수를 감싼 괄호도 생략할 수 있습니다
  - 매개변수를 받지 않을 때는 빈괄호를 써야합니다

함수 선언, 함수 표현식은 *자신만의 호출 컨텍스트* 를 정의하지만
화살표 함수는 *자신이 정의된 환경* 의 'this' 키워드 값을 *상속* 합니다

화살표 함수는 'prototype' 프로퍼티가 없으므로 새로운 클래스의 *생성자* 함수로 사용할 수 없습니다
---
**** 중첩된 함수
중첩된 함수는 자신을 포함하는 함수(들)의 매개변수와 변수에 접근할 수 있습니다
*** 함수 호출
함수 바디를 구성하는 코드는 호출할 때 실행됩니다

호출하는 방법
- 함수로 호출
- 메서드로 호출
- 생성자로 호출
- ~call()~, ~apply()~ 메서드를 통해 *간접적* 으로 호출
- 묵시적 호출

**** this
*this* 는 변수나 프로퍼티 이름이 아니라 키워드 입니다
this 에 값을 할당하는 것을 허용하지 않습니다

this 키워드는 변수의 스코프 규칙을 따르지 않습니다
- 중첩된 함수는 포함하는 함수의 this 값을 상속하지 않습니다

**** 함수로 호출
함수는 호출 표현식을 통해 함수 또는 메서드로 호출됩니다
괄호 안에 들어 있는 각 인자 표현식을 호출 시점에서 평가한 값이 인자가 됩니다

*함수* 의 호출 컨텍스트는 일반모드에서는 전역객체, 스트릭트 모드에서는 undefined 입니다
메서드가 아니라 함수로 호출되도록 설계된 함수는 'this' 키워드를 사용할 일이 없습니다
***** 조건부 호출
#+begin_src javascript
f?.(x);
(f !== null && f !== undefined) ? f(x) : undefined
#+end_src
**** 메서드로 호출
함수 표현식이 프로퍼티 접근 표현식이면 그 함수는 메서드로 호출됩니다
프로퍼티 접근 표현식에서 객체가 호출 컨텍스트가 되고 함수 바디는 키워드 'this'를 통해 객체(호출 컨텍스트 )를 참조할 수 있습니다
**** 생성자로 호출
함수나 메서드를 호출할 때 앞에 키워드 ~new~ 를 붙이면 생성자로 호출됩니다
생성자 호출은 인자처리, 호출 컨텍스트, 반환 값 등에서 다릅니다
- 괄호 안에 인자리스트가 있으면 같은 방법으로 함수에 전달합니다
- 생성자 호출에는 빈 괄호를 생략해도 됩니다

생성자를 호출하면
- 생성자의 prototype 프로퍼티에서 지정된 객체를 상속하는 빈 객체를 생성합니다
- 새로 생성된 객체가 호출 컨텍스트로 사용되므로 이 *(새)객체* 를 'this' 키워드로 참조할 수있습니다
- 생성자 함수 바디의 끝에 도달하면 종료됩니다. 이 경우 새 객체가 생성자 호출 표현식의 값이 됩니다
**** 간접적 호출
함수는 객체이고 메서드가 있습니다

~call()~, ~apply()~ 메서드는 호출 시점에 ~this~ 값을 명시할 수 있습니다
- 함수를 어떤 객체의 메서드로도 호출할 수 있습니다
- ~call()~ 은 인자 리스트를 받고
- ~apply()~ 은 인자로 배열을 받습니다
**** 묵시적 함수 호출
- 객체의 게터나 세터
- ~toString()~, ~valueOf()~
- 이터러블
- 태그된 템플릿 리터럴
- 프록시 객체
*** 함수 매개변수
**** 선택 사항인 매개변수와 기본값
ES6 이후에는 *함수를 정의할 때* 함수 매개변수의 기본 값을 정의할 수 있습니다
매개변수 이름 뒤에 등호(=)를 쓰고, 그 매개변수가 생략됐을 때 사용할 기본 값을 쓰면 됩니다

기본 값 표현식은 정의할 때가 아니라 *호출할 때* 평가됩니다
**** 나머지 매개변수와 가변 길이 인자 리스트
나머지 매개변수(rest parameter)로 정의된 매개변수보다 더 많은 인자를 써서 함수를 호출할 수도 있습니다
함수 선언에서 *마지막으로* 정의된 매개변수여야 합니다
나머지 매개변수는 값이 없으면 빈 배열이 됩니다
***** 가변 함수
가변함수(variadic function)은 인자 개수에 제한이 없는 함수
**** Argument 객체
나머지 매개변수 도입 이전에는 Arguments 객체를 써서 가변 함수를 만들었습니다
~arguments~ 는 해당 호출의 Arguments 객체를 참조합니다

Arguments 객체는 배열 비슷한 객체입니다

비효율적이며 최적화하기 어렵습니다
**** 함수 호출과 분해 연산자
분해 연산자는 개별 값이 예상되는 컨텍스트에서 이터러블 객체를 분해합니다
분해 연산자는 평가를 통해 값을 얻을 수 없다는 점에서 '연산자'로 볼 수 없습니다
**** 함수 인자를 매개변수로 분해
인자로 받는 객체,배열,이터러블을 매개변수로 분해할 수 있습니다
#+begin_src javascript
function vectorAdd([x1,y1], [x2,y2]) {  // 인자 두 개를 매개변수 네 개로 분해합니다
    return [x1 + x2, y1 + y2];
}
vectoradd([1,2], [3,4])         // => [4, 6]
#+end_src

- 매개변수 분해와 매개변수 기본 값을 섞어 쓸때
#+begin_src javascript
// {x,y} 또는 {x,y,z} 벡터에 스칼라 값을 곱합니다
function vectorMultiply({x, y, z=0}, scalar) {
    return {x: x*scalar, y:y*scalar, z:z*scalar};
}
vectorMultiply({x:1, y:2},2)    // => {x:2, y:4, z:0}
#+end_src


- 기본값이 있고 인자순서를 기억하기 어려울 때
#+begin_src javascript
function arraycopy({from, to=from, n=from.length, fromIndex=0, toIndex=0}) {
    let valuesToCopy = from.slice(fromIndex, fromIndex + n);
    to.splice(toIndex, 0, ...valuesToCopy);
    return to;
}
#+end_src

배열 나머지 매개변수 사용
#+begin_src javascript
function f([x,y,...coords],...rest) {
    return [x+y, ...rest, ...coords];
}
#+end_src

객체 나머지 매개변수 사용
#+begin_src javascript
function vectorMultiply({x, y, z=0, ...props}, scalar) {
    return { x:x*scalar, y:y*scalar, z:z*scalar, ...props };
}
vectorMultiply({x:1, y:2, w:-1}, 2);
#+end_src
**** 인자 타입
함수를 정의한 곳 근처에서 호출하는 함수가 아닌 한, 인자 타입을 체크하는 코드를 추가하는 편이 낫습니다.
함수가 잘못된 값을 받은 채 실행을 시작하고 명확하지 않은 에러 메시지를 보내며 실패하는 것보다는, 예측 가능한 형태로 즉시 실패하는 편이 더 좋습니다
*** 값인 함수
**** 함수 프로퍼티 직접 정으
함수는 객체이므로 프로퍼티를 가질 수 있습니다

함수를 언제 호출하든 일정한 '정적'변수가 필요하다면 그 변수를 함수 자체의 프로퍼티로 정의하는게 편리합니다
*** 네임스페이스인 함수
함수 안에서 선언한 변수는 함수 바깥에서 보이지 않습니다
따라서 임시 네임스페이스 기능을 하느 함수를 정의할 수 있습니다

표현식 하나에서 함수를 정의하고 호출하는 기법은 많이 사용됩니다
이를 '즉시 호출하는 함수 표현식(IIFE)'라고 합니다
#+begin_src javascript
(function() {
    // 이 네임스페이스 안에 변수를 사용하고
    // 함수를 정의해서 정의된 함수를 반환값으로 사용합니다
}());
#+end_src

function 앞에 여는 괄호가 없으면 자바스크립트 인터프리터가 function 키워드를 함수 선언으로 분석하기 때문에 필요로 합니다
- 괄호가 있으면 이를 함수 정의 표현식으로 인식합니다

*** 클로저
**** 어휘적 스코프(lexical scope)
어휘적 스코프란 함수가 호출 시점의 스코프가 아니라 자신이 *정의된 시점의* 변수 스코프를 사용하여 실행된다는 뜻입니다
이를 구현하기 위해서는 함수 바디 안에 정의된 스코프에 대한 참조도 포함되어 있어야합니다
이렇게 함수 객체와 스코프를 조합한 것을 클로저라고 합니다


자바스크립트 함수는 자신이 정의된 스코프에서 실행됩니다
클로저는 자신을 정의한 스코프의 로컬변수와 매개변수를 그대로 캡쳐합니다
이 연결은 함수를 어디서 실행하든 계속 유지됩니다

#+begin_src javascript
let uniqueInteger = (function() {       // 다음 함수의 비공개 상태를
    let counter = 0;                    // 정의하고 호출합니다
    return function() {return counter++;};
}());
uniqueInteger();        // => 0
uniqueInteger();        // => 1
#+end_src
IIFE를 사용했으므로 변수에 할당되는 값을 살펴보면 내부 함수입니다
내부 함수는 자신의 스코프에 있는 변수에 접근할 수 있으므로 counter에 접근할 수 있습니다
외부 함수가 종료되면 다른 코드에서는 변수를 볼 수 없습니다
- 오직 내부 함수만이 counter 변수에 접근할 수 있습니다
***** 예제) 클로저를 사용한 비공개 프로퍼티 접근자 메서드
#+begin_src javascript
// 이 함수는 지정된 이름의 프로퍼티에 대한 프로퍼티 접근자 메서드를 객체 o에 추가합니다.
// 메서드 이름은 get<name>과 set<name>으로 지정됩니다. 판별 함수가 제공됐다면
// 세터 메서드는 인자를 저장하기 전에 판별 함수를 사용해 유효성을 테스트합니다
// 판별 함수가 false를 반환한다면 세터 메서드는 예외를 일으킵니다

// 이 함수의 독특한 점은 게터와 세터 메서드가 조작하는 프로퍼티 값이
// 객체 o에 저장되지 않는다는 점입니다. 값은 이 함수의 로컬 변수에마 저장됩니다 .
// 게터와 세터 메서드는 함수에 로컬로 정의됐으므로 로컬 변수에 접근할 수 있습니다
// 따라서 값은 두 접근자 메서드에서만 사용할 수 있으며, 세터 메서드를 통하지 않고서는
// 값을 수정하거나 저장할 수 없습니다

function addPrivateProperty(o, name, predicate) {
    let value;  // 프로퍼티 값입니다

    // 게터 메서드는 단순히 그 값을 반환합니다.
    o[`get${name}`] = function() {return value;};

    // 세터 메서드는 판별 함수의 판단에 따라 값을 저장하거나 예외를 일으킵니다
    o[`set${name}`] = function(v) {
        if (predicate && !predicate(v)) {
            throw new TypeError(`set${name}: invalid value ${v}`);
        } else {
            value = v;
        }
    };
}
#+end_src

*** 함수 프로퍼티, 메서드, 생성자
**** length 프로퍼티
읽기 전용인 length 프로퍼티는 함수의 정의된 매개변수 개수입니다
함수에 나머지 매개변수가 있다면 그 매개변수는 length 프로퍼티에 포함되지 않습니다
**** name 프로퍼티
읽기 전용인 name 프로퍼티는
정의될 때의 이름 또는 할당된 변수, 프로퍼티 이름입니다
**** prototype 프로퍼티
화살표 함수를 제외하면 모든 함수에는 프로토타입 객체를 참조하는 prototype 프로퍼티가 있습니다

함수를 생성자로 사용하면 새로 생성된 객체는 프로토타입 객체에서 프로퍼티를 상속합니다
**** call() 과 apply() 메서드
call() 과 apply() 의 첫번 째 인자는 함수를 호출할 객체입니다(호출 컨텍스트)

화살표 함수는 자신이 정의된 컨텍스트의 this 값을 상속합니다
이 값은 call() 과 apply() 로 덮어 쓸 수 없습니다
**** bind() 메서드
bind() 의 주요 목적은 함수를 객체에 결합하는 것입니다

bind() 로도 화살표함수의 this 값은 덮어지지 않습니다

bind() 호출의 목적은 함수를 화살표 함수처럼 사용하는 것입니다
bind() 에 전달된 인자 중 첫 번째를 제외한 나머지는 this 와 함께 결합됩니다
이러한 부분적용을 커링이라고도 부릅니다

bind() 가 반환하는 함수의 name 프로퍼티는 호출한 함수의 name 앞에 "bound"를 붙인 값입니다
**** toString() 메서드
내장함수는 일반적으로 "[native code]" 같은 문자열을 함수바디로 반환합니다
**** Function 생성자
Function() 생성자는 문자열 인자를 개수 제한 없이 받습니다
마지막 인자는 함수 바디인 텍스트입니다
다른 인자는 모두 함수가 받을 매개변수 이름입니다

Function() 생성자는 전역 스코프를 사용하는 eval() 이고
자신만의 비공 개 스코프에 새 변수와 함수를 정의한다고 생각하면 됩니다.
이 생성자를 사용할 일은 아마 없을 겁니다
*** 함수형 프로그래밍
**** 함수로 배열 처리
**** 고계 함수
*** 요약
- function 키워드나 화살표 문법으로 함수를 정의할 수 있습니다
- 함수는 메서드나 생성자로 사용할 수 있습니다
- 함수 매개변수에 기본 값을 할당하는 기능, 나머지 매개변수, 분해 할당을 사용할 수 있습니다
- 분해 연산자를 통해 배열이나 이터러블 객체의 요소를 함수 인자로 전달해 호출할 수 있습니다
- 외부 함수 안에서 정의되고 반환된 함수는 외부 함수의 어휘적 스코프에 대한 접근을 유지하고 있으므로, 외부 함수에서 정의한 변수에 접근할 수 있습니다

** 클래스
*** 클래스와 프로토타입
*** 클래스와 생성자
*** class 키워드를 사용하는 클래스
*** 기존 클래스에 메서드 추가
*** 서브클래 스
*** 요약
** 모듈
*** 클래스, 객체, 클로저를 사용하는 모듈
*** 노드모듈
*** ES6 모듈
*** 요약
** 자바스크립트 표준 라이브러리
*** 세트와 맵
*** 형식화 배열과 이진 데이터
*** 정규 표현식과 패턴 매칭
*** 날짜와 시간
*** Error 클래스
*** JSON 직렬화와 분석
*** 국제화 API
*** 콘솔 API
*** URL API
*** 타이머
*** 요약
** 이터레이터와 제너레이터
*** 이터레이터의 동작방법
*** 이터러블 객체 만들기
*** 제너레이터
*** 고급 제너레이터 기능
*** 요약
** 비동기 자바스크립트
*** 콜백과 비동기 프로그래밍
*** 프라미스
*** async와 await
*** 비동기 순회
*** 요약
** 메타프로그래밍
*** 프로퍼티 속성
*** 객체 확장성
*** 프로토타입 속성
*** 잘 알려진 심벌
*** 템플릿 태그
*** 리플렉트 API
*** 프록시 객체
*** 요약
** 웹 브라우저의 자바 스크립트
*** 웹 프로그래밍 기본
*** 이벤트
*** 문서 스크립트
*** CSS 스크립트
*** 문서 지오메트리와 스크롤
*** 웹 컴포넌트
*** SVG
*** <canvas>의 그래픽
*** 오디오 API
*** 위치, 내비게이션, 히스토리
*** 네트워크
*** 스토리지
*** 워커 스레드와 메시지
*** 만델브로트 세트
*** 요약 및 추천문서
** 노드와 서버 사이드 자바스크립트
*** 노드 프로그래밍 기본
*** 노드는 기본적으로 비동기적입니다
*** 버퍼
*** 이벤트와 이벤트이미터
*** 스트림
*** 프로세스, CPU, 운영체제 세부사항
*** 파일 작업
*** HTTP 클라이언트와 서버
*** HTTP를 사용하지 않는 네트워크 서버와 클라이언트
*** 자식 프로세스
*** 워커 스레드
*** 요약
** 자바스크립트 도구와 확장
*** ES린트를 이용한 린팅
*** 프리티어를 사용한 자바스크립트 포맷
*** 제스트를 통한 단위 테스트
*** npm을 통한 패키지 관리
*** 코드 번들링
*** 바벨을 이용한 트랜스파일
*** JSX: 자바스크립트의 마크업 표현식
*** 플로를 이용한 타입체크
*** 요약
