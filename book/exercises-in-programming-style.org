* 프로그래밍 패턴
대상독자
- 프로그래밍 형식을 음미하고 배우기 위해서

집필동기
- 학생들이 특정 프로그래밍 언어에서 권장하는 형식만 이해하며 다른 형식을 이해하는데 어려움을 느낀다
  - 그래서 똑같은 계산 작업을 여러 형식으로 작성하는 프로젝트를 시작하였다

프로그래밍 형식이란?
- 제약조건 집합에 따라 프로그램을 작성한 결과물
  - 제약조건: 어떤 것은 허용하지 않고 어떤 것은 반드시 존재해야 하며 어떤 것은 제한적이어야 한다는 등
- 고급 프로그래머는 다양한 목적에 따라 그 프로그램을 표현하는 적절한 형식을 택할 수 있어야 한다

단어빈도
- 가장 빈도가 높은 단어 N개와
- 그에 해당하는 빈도를 내림차순으로 출력
- 대문자는 모두 소문자로 정규화하고
- 'the', 'for' 등과 같은 의미 없는 단어는 무시
** [1부] 전통적 형식
수십 년 전 프로그래밍이 어땠는지,
최신 시스템의 내부 계층이 어떤지 보여준다
*** 01장: 그리운 옛날
**** 제약조건
- 주기억 장치의 양이 매우 적다
  - 처리/생성할 데이터에 비해 매우 적다
- 식별자가 없다. 숫자로 가리킬 수 있는 메모리만 있다
**** 해설
- 메모리 한계로 인해 사용 가능한 메모리 전체에 걸쳐 데이터를 회전시킨다
  계산 작업을 복잡하게 할 수 밖에 없다
  특정 시점에 메모리에 존재하는 데이터가 얼마나 되는지 신경써야한다
- 식별자가 없어 주석과 문서화를 추가했다
- 하드웨어를 직접 다루거나 메모리 사용을 최적화할 때 사용한다
- 예제에서는 자체적으로 메모리 크기를 1024로 한정했다
  - 1024보다 훨씬 많은 입력값이 제공되면 데이터를 작은 덩어리로 나눠 읽고 처리하며
  - 보조기억장치(파일)을 과도하게 사용하는 방법을 생각해낼 필요가 있다
- 코드 작성을 시작하기 전에
  - 주기억 장치에 둘 것
  - 보조 기억 장치에 넣을 것
  - 언제 그렇게 할 것인지
    여러 다른 선택에 간단히 계산해볼 필요가 있다
    주 기억 장치에 접근하는 것은 보조 기억 장치에 접근하는 것에 비해 매우 빠르므로 이러한 계산은 성능 최적화와 관련이 있다
- 첫번째 부분
  - 입력 파일을 처리하고
  - 나온 단어를 세며
  - 데이터를 단어 빈도 파일에 기록한다
- 두번째 부분
  - 25개의 가장 자주 나온 단어를 찾기 위해 중간의 단어 빈도 파일을 처리하고 단어를 출력한다
**** 프로그램 해설
***** 첫번째 부분
- 대략 500자에 달하는 의미 없는 단어를 주기억 장치에 담는다(#33~36)
- 입력 파일을 한 번에 한 줄씩 읽는데, 각 줄은 최대 80자에 불과하다(#50~95)
- 각 줄에 대해 문자를 걸러내고 단어를 식별하며, 그 단어를 소규모로 정규화한다(#60~95)
- 단어와 그 빈도를 보조 기억 장치에서 가져오거나 그 메모리에 기록한다(#73~90)
***** 두번째 부분
- 현재 가장 자주 나타나는 단어 25개와 그 빈도를 담고 있는 메모리를 순서 있는 리스트로 유지한다
- 파일에서 한 번에 한 줄씩 읽는다. 각 줄에는 단어와 그에 해당하는 빈도가 있다(#108~120)
- 새 단어가 메모리에 있는 어떤 단어보다도 빈도가 더 크면 그 리스트 내의 적절한 위치에 삽입하고 리스트 끝에 있는 단어를 제거한다(#116~120)
- 마지막으로 상위 25개 단어와 그 빈도를 출력(#122~124)하고 중간 파일을 닫는다(#126)
**** 시스템 설계 관점에서 본 이러한 형식
- 프로그래밍 형식에 따른 메모리 사용량에 대해 어느정도 인식하는 것은 바람직하다

  데이터를 모두 메모리에 넣을 수 없다면
  - 어떤 특정 시점에 메모리에 맞게 넣을 수 있도록 데이터를 나타내고
  - 주기억 장치와 보조기억장치에 걸쳐 데이터를 회전시키기 위한 계획을 고안해야한다
*** 02장: 포스로
**** 제약조건
- 데이터 스택(stack)이 존재한다. 조건, 산술 등의 모든 연산은 스택에 있는 데이터를 대상으로 이뤄진다
- 나중에 연산해야 하는 데이터를 저장할 힙(heap)이 존재한다. 힙 데이터는 이름(변수)와 연관될 수 있다.
  연산은 스택에 있는 데이터에 대해 이뤄지므로 연산해야 하는 모든 힙 데이터는 먼저 스택으로 옮겨야 하고 최종적으로 다시 힙으로 옮긴다
- 사용자 정의 '프로시저'(명령 집합을 가리키는 이름) 형태의 추상화가 존재한다
** [02부] 기본 형식
*** 03장: 일체식
**** 제약조건
- 명명된 추상화가 없다
- 라이브러리를 전혀 또는 거의 사용하지 않는다
**** 해설
- 설계 관점에서 주된 관심사는 문제를 분할하는게 아닌 원하는 출력을 얻는 것이다
- 프로그래밍 작업은 문제를 지배하는 *데이터* 와 *제어흐름* 으로 구성된다
- 유지보수 관점에서 잠재적으로 나쁜 것은 적절한 고수준 추상화를 제공하지 못하는 프로그램 본문이 긴 구역으로 존재한다는 것
  - 프로그램을 이해하기 어렵게 할 수 있다
- 순환 복잡도(cyclomatic complexity)
  - 프로그램 본문의 복잡도 (제어흐름 경로의 양)의 측정 지표
*** 04장: 요리책
*** 05장: 파이프라인
*** 06장: 코드 골프
** [03부] 함수 합성
*** 07장: 무한 거울
*** 08장: 앞으로 차기
*** 09장: 유일
** [04부] 객체와 상호작용
*** 10장: 사물
*** 11장: 우편함
*** 12장: 닫힌 맵
*** 13장: 추상사물
*** 14장: 할리우드
*** 15장: 게시판
** [05부] 반영과 메타프로그래밍
*** 16장: 자기관찰
*** 17장: 반영
*** 18장: 애스펙트
*** 19장: 플러그인
** [06부] 재난
*** 20장: 구성주의
*** 21장: 발끈하기
*** 22장: 수동공격
*** 23장: 선언한 의도
*** 24장: 격리
** [07부] 데이터 중심
*** 25장: 영속 데이터
*** 26장: 스프레드시트
*** 27장: 게으른 강
** [08부] 병행성
*** 28장: 행위자
*** 29장: 데이터 공간
*** 30장: 맵리듀스
*** 31장: 이중 맵리듀스
** [09부] 쌍방향성
*** 32장: 삼위일체
*** 33장: REST 방식

