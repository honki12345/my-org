* 깐깐하게 배우는 C
*** 옮긴이의 글
*** 감사의 글
*** 서문
**** 이 책은 사실 C에 대한 책이 아니다
:PROPERTIES:
:CATEGORY:      book
:END:
*철저한 방어적 프로그래밍* (rigorous defensive programming)를 배운다
여러분은 악의적인 행동이나 공격으로부터 보호하는 프로그램을 작성하는 방법을 배우게 될 것이다

C는 불완전한 언어이다
모든 것이 C를 공격하는 거의 모든 보안 공격에 해당되기 때문이다
**** UB주의자(Undefined Behaviorists)
이 책을 다 읽은 시점에서는 C프로그램을 *디버그 하고, 읽고, 고칠* 수 있게 될 것이다
그리고 *견고한 코드* 를 구사하게 될 것이다
**** C는 예쁘면서 까다로운 언어
코드를 작성할 때 견고함을 추구
- 제대로 동작하는 것은 아무 것도 없다고 생각
**** 이 책을 읽는 방법                                            :advice:
- 모든 코드는 그대로 직접 입력할 것, 복사하여 붙여넣기하지 말 것
- 실행 시 동일한 결과가 나타나는지 확인할 것
- 버그가 있다면 수정할 것
- '더 해보기'를 하되, 잘 모르겠다면 일단 넘어갈 것
- 도움을 청하기 전에 항상 먼저 스스로 알아내기 위해 노력할 것

최소한 시도는 해 보아야 한다
적어도 노력하는 것만으로도 여러분은 더 나은 프로그래머로 성장할 수 있을 것이다
**** 핵심 역량
***** 읽기와 쓰기                                                :advice:
대충 넘기는 성향을 지닌 프로그래머들은 코드를 이해하는데 어려움을 겪는다
- 그냥 건너뛰는 것

모든 사람이 어려움을 겪고 있다는 것을 이해한 다음
*좀 더 집중해서 꼼꼼하게 읽고 쓰도록 노력* 하는 것이다
처음에는 고통스럽고 성가시겠지만 *자주 휴식을 취하면서 하다 보면* 마침내 읽고 쓰는 일이 쉬워질 것이다
***** 설계와 디버깅
C언어가 어려운 이유는 코딩을 하기 전에 먼저 무엇을 만들 것인지 *설계* 해야한다는 것이다
엉성하게 코드를 작성할 수 없을뿐더러, 만일 그렇게 한다면 아무것도 동작하지 않을 것이다
** 설정하기
*** 리눅스
*** Mac OS X
*** 윈도우
*** 텍스트 편집기
** 간만에 써보는 컴파일러
*** 코드 분석                                                      :advice:
줄 단위로 공부하여 *최소한 어떤 일이 일어나는지는* 알아야 한다

*추측* 하고 *고민* 한 후 다음으로 진행할 수 있을 것이다
- 기록해놓으면 나중에 제대로 추측했는지 확인할 수 있다
*** 실행 결과
~make~ 는 소프트웨어별로 어떻게 빌드하는지를 안다
*** 프로그램 깨뜨리기
프로그램 깨뜨리는 방법
- 프로그램에 이상한 내용을 넣어보기
- 프로그램을 이상하게 실행시키기
- 코드를 변경하여 충돌 일으키기
- 코드를 변경하여 컴파일러 오류 일으키기
** Makefile 사용법
*** Make 사용하기
make 동작
- 의존성을 선언하고, 빌드하는 방법을 기술한다
- 프로그램의 기본 지식에 의존하게 만든다
*** 실행결과
*** 프로그램 깨뜨리기
*** 더 해보기
** 서식 있는 출력
Makefile은 오류를 찾아내는 데 도움이 되므로
*자동화가 필요한 것* 들을 *Makefile* 에 추가할 것이다
*** 외부 조사                                                      :advice:
여러분은 *스스로* 관련 정보를 찾아가며 *개념들을 구체화* 하게 될 것이다

먼저 자신이 *직접 질문에 대답하려고 노력해야 한다*
그런 다음 *자신이 내린 답이 맞는지를 확인해야 한다.*
이를 위해 *여러분은 내용을 쪼개고, 자신의 가설을 실험하고, 직접 관련 자료를 조사하게 될 것이다*
** 디비거 사용
*** GDB 사용
GDB를 이용하면
- 중단점을 지정하고, 프로그램을 줄단위로 실행하면서
  - 사용하는 변수 값도 확인할 수 있고
- 중단되는 경우 백트레이스를 통해 원인을 찾는데 도움을 받음
*** GDB 트릭
**** gdb --args
프로그램에 파라미터 제공
**** thread apply all bt
모든 스레드에 대해 백트레이스 정보를 덤프한다
**** gdb --batch --ex r --ex bt --ex q --args
실행 중인 프로그램이 죽을 때 백트레이스 정보를 얻도록 한다
*** GDB 명령 리스트
**** run [args]
디버깅할 프로그램을 파라미터 [args]와 함께 실행시킨다
**** break
~[file:]function~ 함수에 중단점을 지정한다
**** backtrace
현재 호출 스택에 대한 백트레이스를 덤프한다
**** print expr
~expr~ 값을 출력한다
**** continue
프로그램 실행을 계속한다
**** next
다음 줄까지만 실행한다
함수 호출시 함수 안으로 진입하지 않는다
**** step
다음 줄까지만 실행한다
함수 호출시 함수 안으로 진입한다
**** quit
종료한다
**** help
**** cd, pwd, make
셸에서와 같이 동작한다
**** shell
**** clear
중단점을 지운다
**** info break, info watch
**** attach pid
**** detach
**** list
** C 연산자 외우기
SCHEDULED: <2025-03-21 금>
*기본 기호* 와 *구문* 을 모두 *외운 다음*
일련의 연습을 통해 적용하는 것이다
** C 문법 외우기
** 변수와 타입
SCHEDULED: <2025-03-23 일>
다른 변수 타입 간 연산이 어떻게 일어나는지 보여준다

C에서는 charater 역시 integer(숫자) 일 뿐이다
- 연산에 사용할 수 있다
** If, Else-if, Else
integer(숫자) 를 이용하여 0인 경우에만 false로 하고 그 외의 나머지는 true로 간주한다
** While 루프와 Boolean 표현식
while 루프는 TEST 결과가 참인 동안 CODE를 반복해서 실행한다
** Switch 명령문
C언어에서 ~switch~ 명령문은 점프(jump) 표처럼 동작한다
정수 값으로 결과가 나타나는 표현식을 사용해야만 한다
- 이 정수 값은 switch 의 맨 위에서 정확하게 일치하는 정수 값으로 점프하는 위치를 계산하는데 사용한다

*** 규칙
- 항상 ~default:~ 분기점을 포함시키자
- 필요한 경우가 아니면 아래 ~case~ 로 넘어가도록 프로그램을 작성하지 말라
  - 그렇게 작성시 주석을 달아놓는 것이 좋다
  - ~/* intentional fallthrough */~
- ~case~ *내부 코드* 를 작성하기 전에 먼저 ~case~ 와 ~break~ 를 적어놓자
- 가급적 ~if~ 명령문을 사용하자
** 배열과 문자열
C는 문자열을 ~'\0'~ 바이트로 끝나는 바이트 배열에 저장한다

C 언어의 버그는
1. 충분한 공간을 만들지 않거나
2. 문자열 마지막에 '\0' 을 넣지 않아
생긴다


*** 배열 초기화
한 개의 요소 값만 제공하면 나머지 요소는 0 으로 채운다

*** 문자열 지정
#+begin_src c
  char *another = "Literal";
#+end_src
*** "변수 있는 곳에 버그 있다"
디버거로 원인을 찾기 어려울 때는 *변수를 선언한 곳* 으로 가서 오류가 있는지 확인
** 크기와 배열
C는 어떤 위치에 얼마의 크기의 메모리를 점유하고
그것을 어떻게 사용하는지를 나타내는 프로그래밍 언어이다
*** sizeof
~sizeof~ 키워드는 얼마나 많은 메모리 공간을 사용하는지 *바이트 단위* 로 보여준다
*** 배열 초기화: type name[] = {initializer};
데이터 타입 type 배열을 만들면서 초기 값으로 {initializer}로 지정한다
** For 루프와 문자열 배열
여러 문자열이 들어있는 배열 다루기

#+begin_src c
  for(INITIALIZER; TEST; INCREMENTER) {
      CODE;
  }
#+end_src

운영체제가 argc, argv를 만들어 전달해준다
** 함수 작성 및 사용
전방선언(forward declaration)
** 포인터, 무서운 포인터
*** C는 컴퓨터 전체를 하나의 커다란 바이트 배열로 생각한다
C가 하는 일은 커다란 바이트 배열의 꼭대기에서부터 타입과 그 타입의 크기라는 개념으로 나누는 것이다
*** C의 배열 작업
- 컴퓨터 내에 메모리 블록을 만든다
- 블록의 시작점을 ~ages~ 라는 이름으로 포인팅한다
- ~ages~ 의 기준 주소에서 ~i~ 만큼 떨어진 요소를 취하는 방식으로 블록을 인덱싱한다
- ~ages+i~ 주소의 내용을 정확히 ~int~ 크기만큼 꺼내는 것이 인덱스 ~i~ 에 해당하는 ~int~ 값을 조회할 때 일어나는 과정
*** 포인터

가급적 배열을 사용하고 꼭 필요한 상황(최적화)를 위해서 포인터를 사용하도록 하자
**** 포인터란
포인터는 컴퓨터 메모리의 위치를 가리킨다

C는 포인터가
- *어디* 를 가리키는지
- 가리키는 곳의 *데이터 타입 은 무엇* 인지
- *데이터 타입의 크기* 는 얼마나 되는지
- *데이터를 가져오는 방법* 은 무엇인지
알 고 있다
-> 포인터를 ( 증감 ), ( 감소 )하거나, ( 값을 얻거나 ) ( 값으로 지정 ), ( 배열 연산 )을 할 수 있다

**** 포인터를 사용하는 이유
블록이나 메모리에 있는 데이터를 직접 인덱싱하기 위해서다
배열로는 이 작업을 정교하게 하기 어려울 땍 있음
**** 유용한 포인터 사용케이스
- 운영체제에 메모리 덩어리를 할당받고 포인터를 이용하여 할당받은 메모리 블록 작업
- 커다란 메모리 블록을 통째로 전달할 필요없이 포인터를 이용하여 함수에 전달
- 함수의 주소를 구하여 동적 콜백 함수로 사용
- 복잡한 메모리 덩어리를 스캔하여 데이터 구조를 변환, 파싱하기
**** 포인터 어휘
~type *ptr~
- 타입이 ~type~ 이고 이름이 ~ptr~ 인 포인터

~*ptr~
- ptr이 가리키는 곳(주소)에 들어있는 값

~*(ptr + 1)~
- ptr이 가리키는 곳에서 i만큼 더한 곳에 들어있는 값

~&thing~
- thing의 주소

~type *ptr = &thing~
- 타입이 type이고 이름이 ptr인 포인터에 thing의 주소를 지정함

~ptr++~
- ptr이 가리키는 곳(주소)를 하나 증가시킴
** 구조체와 이를 가리키는 포인터
*** 구조체
구조체는 *여러 데이터타입의 묶음* 을 나타낸다
이 묶음은 *하나의 메모리 덩어리* 에 저장되며
구조체의 *필드 변수 이름* 으로 해당 타입의 데이터에 접근할 수 있다
*** 구조체의 필드 접근
포인터: ~x->y~
구조체: ~x.y~
** 힙,스택 메모리 할당
#+begin_src c
  // conn 안에 있는 db 안에 있는 rows 의 i번째 요소를 구한 다음 이것에 해당하는 주소(&)를 얻는다
  &conn->db->rows[i]
#+end_src
*** 힙과 스택의 구분
변수든 함수든 ~malloc~ 을 통해 가져온 것이 아니라면 모두 스택에 있다
** 함수를 가리키는 포인터
C언어에서 함수는 해당하는 코드가 프로그램 내 어디에 있는지를 가리키는 포인터이다

함수 포인터는 인수형태로 전달하기가 어렵다. 그러므로 ~typedef~ 를 사용한다
** 제드의 끝내주는 디버그 매크로
** 고급 디버깅 기술
** 고급 데이터 타입과 흐름 제어
** 스택, 범위, 전역
** 더프의 장치 알고리즘
** 입력, 출력, 파일
** 가변 인수 함수
** logfind 프로젝트
** 창의적 프로그래밍, 방어적 프로그래밍
** 중급 Makefile
** 라이브러리와 링크
** 테스트 자동화
** 일반적인 미정의 동작
** 이중 연결 리스트
** 연결 리스트 알고리즘
** 동적 배열
** 정렬과 탐색
** 더 안전한 문자열
** 해시맵
** 해시맵 알고리즘
** 문자열 알고리즘
** 이진 탐색 트리
** devpkg 프로젝트
** 스택과 큐
** 간단한 통계 엔진
** 원형 버퍼
** 간단한 TCP/IP 클라이언트
** 3진 탐색 트리
** 빠른 URL 라우터
** 간단한 네트워크 서버
** 통계 서버
** 통계 라우팅
** 통계 저장
** 해킹하고 개선하기
** 다음 단계
