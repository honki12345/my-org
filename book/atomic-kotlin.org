* Atomic kotlin
** 1부 프로그래밍 기초
*** 01 소개
우리는 한 장에서 하나의 개념만 소개함으로써 각 장을 더 작은 단위로 나누지 못하게 노력했다
- 그래서 각 장을 '아톰'이라고 부른다
**** 이 책의 콘셉트
코틀린은 강력하다
- 제공하는 *특성이 다양* 하다
- 특성을 *다양한 방법으로 표현* 할 수 있다
***** 작은 단계를 거치면서 작은 성취를 맛보게 함
***** 전방 참조가 없다
***** 다른 언어를 참조하지 않는다
***** 설명하지 않는다
***** 이론보다는 연습
언어가 작동하는 모습을 먼저 보여주고,
왜 이런 특성이 존재하는지 설명
*** 02 왜 코틀린인가?
코틀린은 어떤 분야에 어울리는가?
코틀린은 왜 배워야할까?

프로그래밍 언어 설계는 기계의 요구에 맞추는 것에서 *프로그래머의 요구* 에 맞추는 쪽으로 진화해왔다
- 역사적으로 프로그래밍 언어 설계는 *프로그래머를 더 생산적으로 만들기 위해 필요한 기능* 이 무엇인지 계속 추측하고 가정하는 것
**** 컴파일러와 인터프리터
코틀린은 해석(interpret) 되지 않고 컴파일(compile)된다
- 컴파일되는 언어의 소스 코드는 하드웨어 프로세서에서 직접 실행되거나,
  프로세서를 본 딴 가상머신에서 실행될 수 있는 다른 표현으로 변환된다
**** 코틀린에 영향을 미친 언어
**** 왜 코틀린인가?
**** 코틀린의 두 가지 특징
*** 03 Hello, World!
키워드는 언어에 의해 예약되어 있고 특별한 의미를 지닌 단어이다
*** 04 var와 val
SCHEDULED: <2025-03-24 월>
*** 05 데이터 타입
*** 06 함수
**** 함수 시그니처
이름, 파라미터, 반환타입
**** 블록본문(block body)
#+begin_src kotlin
  fun 함수이름(p1: 타입1, p2: 타입2, ...): 반환타입 {
    // 여러 줄의 코드
    return 결과
  }
#+end_src
**** 식본문(expression body)
~fun 함수이름(p1: 타입1, p2: 타입2, ...): 반환타입 = 식~

식본문의 반환타입은 추론한다
**** 반환타입을 명시하지 않으면 함수의 반환타입이 Unit가 된다
*** 07 if 식
if 뒤에 있는 괄호 안의 식은 ~true~ 또는 ~false~ 로 평가되어야 한다

if 블록의 마지막에 있는 식의 결과가 if 전체의 결과가 된다

**** if 식(expression)
#+begin_src kotlin
  fun main() {
      val num = 10
      val result = if (num > 100) 4 else 42
      println(result)
  }
#+end_src
*** 08 문자열 템플릿
**** $
*식별자 이름* 앞에 ~$~ 를 붙이면 식별자의 값을 String에 넣어준다
~${expression}~ 을 평가해서 값을 String에 넣어준다
- ~$~ 다음에 오는 대상이 식별자로 인식되지 않으면 아무 일도 일어나지 않는다
*** 09 수 타입
**** 사칙연산
정수 나눗셈연산은 결과를 잘라서(버림) 정수로 돌려준다
정수 나머지연산은 정수 나눗셈연산의 나머지를 결과로 돌려준다
***** Int
코틀린 Int 타입은 32비트로 -2^31에서 2^31-1 까지 표현가능하다
***** Long
코틀린 Long 타입은 64비트로 -2^63에서 2^63-1 까지 표현가능하다
*** 10 불리언
*** 11 while로 반복하기
#+begin_src kotlin
  while (Boolean 식) {
      // code
  }
#+end_src

#+begin_src kotlin
  do {
      // code
  } while (Boolean 식)
#+end_src
*** 12 루프와 범위
#+begin_src kotlin
  for (v in 값들) {
      // code
  }
#+end_src
**** range
#+begin_src kotlin
  fun showRange(r: IntProgression) {
      for (i in r) {
          print("$i ")
      }
      print(" // $r")
      println()
  }

  fun main() {
      showRange(1..5)           // 1 2 3 4 5
      showRange(0 until 5)      // 0 1 2 3 4
      showRange(5 downTo 1)     // 5 4 3 2 1
      showRange(0..9 step 2)
      showRange(0 until 10 step 3)
      showRange(9 downTo 2 step 3)
  }
#+end_src
*** 13 in 키워드
~in~ 키워드는 값이 주어진 범위 안에 들어 있는지 검사한다

~for~ 루프 제어식에 있는 ~in~ 은 이터레이션
나머지                  ~in~ 은 검사

#+begin_src kotlin
  fun main() {
      val values = 1..3
      for (v in values) {
          println("iteration $v")
      }
      val v = 2
      if (v in values)
          println("$v is a member of $values")
  }
#+end_src
*** 14 식과 문
A Statement changes state(문은 상태를 변경한다)
An expression expresses(식은 값을 짜낸다)
*** 15 1부 요약
** 2부 객체 소개
*** 16 객체는 모든 곳에 존재한다
*** 17 클래스 만들기
*** 18 프로퍼티
*** 19 생성자
*** 20 가시성 제한하기
**** 모듈
*** 21 패키지
*** 22 테스트
**** 프로그램의 일부분인 테스트
*** 23 예외
*** 24 리스트
**** 파라미터화한 타입
**** 읽기 전용과 가변 List
**** +=의 비밀
*** 25 가변 인자 목록
**** 명령줄 인자
*** 26 집합
*** 27 맵
*** 28 프로퍼티 접근자
*** 29 2부 요약
** 3부 사용성
*** 30 확장 함수
*** 31 이름 붙은 인자와 디폴트 인자
*** 32 오버로딩
*** 33 when 식
*** 34 이넘
*** 35 데이터 클래스
**** HashMap과 HashSet
*** 36 구조 분해 선언
*** 37 널이 될 수 있는 타입
*** 38 안전한 호출과 엘비스 연산자
*** 39 널 아님 단언
*** 40 확장 함수와 널이 될 수 있는 타입
*** 41 제네릭스 소개
**** 제네릭 함수
*** 42 확장 프로퍼티
*** 43 break와 continue
**** 레이블
** 4부 함수형 프로그래밍
*** 44 람다
*** 45 람다의 중요성
*** 46 컬렉션에 대한 연산
*** 47 멤버 참조
**** 함수 참조
**** 생성자 참조
**** 확장 함수 참조
*** 48 고차 함수
*** 49 리스트 조작하기
**** 묶기
**** 평평하게 하기
*** 50 맵 만들기
**** 맵에 연산 적용하기
*** 51 시퀀스
*** 52 지역 함수
**** 레이블
**** 지역 함수 조작하기
*** 53 리스트 접기
*** 54 재귀
** 5부 객체 지향 프로그래밍
*** 55 인터페이스
**** SAM 변환
*** 56 복잡한 생성자
*** 57 부생성자
*** 58 상속
*** 59 기반 클래스 초기화
*** 60 추상 클래스
*** 61 업캐스트
*** 62 다형성
*** 63 합성
**** 합성과 상속 중 선택하기
*** 64 상속과 확장
**** 관습에 의한 인터페이스
**** 어댑터 패턴
**** 멤버 함수와 확장 함수 비교
*** 65 클래스 위임
*** 66 다운캐스트
**** 스마트 캐스트
**** 변경 가능한 참조
**** as 키워드
**** 리스트 원소의 타입 알아내기
*** 67 봉인된 클래스
**** sealed와 abstract 비교
**** 하위 클래스 열거하기
*** 68 타입 검사
**** 외부 함수에서 타입 검사하기
*** 69 내포된 클래스
**** 지역 클래스
**** 인터페이스에 포함된 클래스
**** 내포된 이넘
*** 70 객체
*** 71 내부 클래스
**** 한정된 this
**** 내부 클래스 상속
**** 지역 내부 클래스와 익명 내부 클래스
*** 72 동반 객체
** 6부 실패 방지하기
*** 73 예외 처리
**** 오류 보고
**** 복구
**** 예외 하위 타입
**** 자원 해제
**** AtomicTest의 예외 처리
**** 가이드라인
*** 74 검사 명령
**** require()
**** requireNotNull()
**** check()
**** assert()
*** 75 Nothing 타입
*** 76 자원 해제
*** 77 로깅
*** 78 단위 테스트
**** 테스트 프레임워크
**** 모킹과 통합 테스트
**** 인텔리J IDEA에서 테스트하기
** 7부 파워 툴
*** 79 확장 람다
**** 확장 람다를 사용해 빌더 작성하기
*** 80 영역 함수
**** 영역 함수는 인라인된다
*** 81 제네릭스 만들기
**** Any
**** 제네릭스 정의하기
**** 타입 정보 보존하기
**** 타입 파라미터 제약
**** 타입 소거
**** 함수의 타입 인자에 대한 실체화
**** 타입 변성
*** 82 연산자 오버로딩
**** 동등성
**** 산술 연산자
**** 비교 연산자
**** 범위와 컨테이너
**** 컨테이너 원소 접근
**** 호출 연산자
**** 역작은따옴표로 감싼 함수 이름
*** 83 연산자 사용하기
**** 구조 분해 연산자
*** 84 프로퍼티 위임
*** 85 프로퍼티 위임 도구
*** 86 지연 계산 초기화
*** 87 늦은 초기화
** 부록
*** A 아토믹 테스트
*** B 자바 상호 운용성
**** 코틀린에서 자바 호출하기
**** 자바에서 코틀린 호출하기
**** 자바를 코틀린에 도입하기
**** 자바의 검사 예외와 코틀린
**** 널이 될 수 있는 타입과 자바
**** 널 가능성 애너테이션
**** 컬렉션과 자바
**** 자바 원시 타입
*** C 인텔리J에서 코틀린 코드를 실행하는 법
**** 인텔리J IDEA 설치하기
**** 깃허브에서 예제 내려받기
**** 인텔리J에서 예제 실행하기
*** D 인텔리J에서 이 책의 연습 문제를 푸는 법
**** EduTools 플러그인 설치하기
**** 학습 코스 선택하기
**** 예제와 연습 문제 실행하기
