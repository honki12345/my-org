#+title: 테스트 주도 개발

* 테스트 주도 개발
*** 역자의 글
테스트 주도 개발은 하나의 기술이지만 그 이면에는 사고의 근원적 변화가 있습니다.
프로그래머가 자기 작업의 품질에 대한 우선적 책임을 져야 한다는 깨달음이죠
TDD를 실천법으로 적용하는 것은 도움이 될 수 있습니다만, 책임을 맡는 방법으로 사용하면 강력해질 것입니다

컴퓨터 화면 속 이상으로 중요한 곳이 있습니다.
바로 우리의 머릿속입니다.
테스트를 돌렸습니다. 당연히 성공하리라 생각했습니다.
어, 실패합니다. 당황합니다.
이럴 때 우선 "지금 무슨 일이 일어났지?"라고 자문합니다.
마음을 차분히 하고 주변을 살핍니다.
**목표를 우선 현 상황을 파악하는 데에 둡니다.**
에러 메시지는 무슨 뜻이고, 컴퓨터는 나에게 어떤 메시지를 전달하려고 노력하고 있는 거지?
**그 다음에는 눈을 감고 생각해 봅니다**
어디에서 왜 이런 오류가 났을까. 소스코드를 보지 않고 머릿속에서 소스코드를 탐색해 봅니다.
그리고 에러가 났음직한 부분을 차분히 짐작해 봅니다.
그러고는 그 부분을 어떻게 간단히 고치면 테스트를 통과할지(혹은 어떻게 간단히 고치면 그 실패 상황에 대해 더 잘 이해하게 될지) 생각합니다.
이제 눈을 뜹니다. 모니터에 해당 부분을 띄웁니다.
자신이 머릿속에서 생각한 모습의 코드가 펼쳐졌나요?
잘 살펴본 뒤에, 자기가 생각한 대로 코드를 고쳐봅니다. 테스트를 돌리기 전에 마음을 비우고 다시 상상해 봅니다.
어떤 결과가 나올까?
정말 돌려봅니다. 어떤 결과가 나왔나요?
자신의 생각과 컴퓨터가 보여주는 것이 서로 다르다고 해서 절대 낙심하지 마세요. 다름을 느끼고 즐기려고 하세요
빨리 테스트를 통과시키려고, 혹은 프로그램을 빨리 작성하려고 너무 조바심 내지 마세요.
자신감을 가지세요. TDD를 쫓아가려고 하지 마시고 TDD가 자신을 따라오게 하세요
*이렇게 해서 심리적인 안정 속에서 프로그래밍을 할 수 있게 되면 놀라운 일들을 경험하게 됩니다*
전에는 보지 못하던 것들을 보게 되며, 내가 생각하지 못하던 것들을 생각해 내게 됩니다

TDD의 특성상 완성된 프로그램 코드를 보거나, 간단한 메뉴얼 정도로는 TDD를 익힐 수 없습니다.
**그 과정을 하나하나 따라가야 합니다**

공력을 쌓는 것은 속성이 어렵고 또 남의 동작을 보고 관찰하는 것만으로 자기화할 수 없습니다
분명 자기 수련이 필요합니다
이 책을 읽고 그대로 따라해보고 또 자기만의 방식을 찾아보기도 하는 등 실험을 하고 수련법을 따르거나 스스로 단순한 규칙을 정해놓고 지키기 위해 노력하면서 자기만의 노하우를 구축해야 합니다
이와 동시에 실무에서 조금씩 적용 범위를 넓혀가야 합니다
분명 엄청나게 좌절할 것입니다. 하지만 그 좌절을 하나 둘 넘어가면서 시야가 점점 넓어져 갈 것입니다
TDD 관련 서적에서는 실무에서 맞닥뜨릴 만한 문제의 몇 가지 해결안을 보여주는 책도 있습니다.
참고는 하되 복사하지는 마십시오
더 나은 방법들이 있습니다. 편견을 버리고 순수한 마음, 아무것도 모른다는 마음으로 문제에 접근하면서 나날이 톱니바퀴를 돌려나가시길,
또 주변에서 도반을 찾아 함께 고민하고 공부해 나가시길 당부드립니다
*** TDD 수련법
처음 훈련방법
- 간단하고 쉬운 문제들을 TDD로 시도
  - 가능하면 전에 접하고, 프로그래밍해본 문제
- 초록 막대 주기는 가능하면 짧도록 한다
- 초록 막대 주기의 최대 시간을 정해놓고 진행하다가 시간을 초과하면 직전 초록 막대 상태로 돌린 다음(그 동안의 코드는 포기 ) 새로 시작
- '진짜로 만들기 전까지만 가짜로 구현하기'를 적극 사용
- 같은 문제를 여러번 풀어본다
- 초기에는 리팩토링 툴을 사용하지 않는다
  - 초보에겐 순서와 과정이 중요한데 그걸 성큼 건너뛰게 만든다

다음 훈련방법
- 여유를 가지세요
  - '학습'과 '개선'의 필수적 요소는 자기를 돌아보기(self-reflectivity)와 자기가 생각하는 것을 생각하는 메타인식(meta-cognition)
  - 자신이 하는 것을 관조, 관찰하고, 기록하고 분석하세요
    - 프로토콜 분석도 좋은 방법입니다 (사고과정 중 생각한 것을 직접 입으로 말하도록 하면서 진행하고, 이를 녹음한 것을 분석 )
- 자신이 TDD로 해보지 않았던 영역을 하나씩 실험해봅시다
  - 어려운가요? 왜 어려울까요? 쉬운 방법은 없을까요?
- 보폭을 조절해봅시다
  - 잘 된다 싶으면 속도를 높이고 뭔가 안 풀린다 싶으면 바로 속도를 늦추는 훈련을 합니다
  - 자신이 편한 속도를 찾습니다
- 작은 애플리케이션 하나를 오로지 TDD로 완성해봅니다
  - 일주일 정도 걸리는 것이면 좋습니다
- 다른 언어(가능하면 다른 패러다임의 언어 )로 TDD를 해봅시다
  - 이전에 많이 풀어봤던 문제를 시도해봅니다

다음 훈련방법
*** 한국어판 인터뷰
'테스팅'에 쓰는 시간 일부는 사실 분석 혹은 설계 결정에 쓰입니다
이것은 낭비가 아닙니다

제가 테스트를 작성하지 않는다면, 그건 제가 그렇게 할 수 없다고 생각하기 때문입니다
잠시 공포를 느끼는 것은 테스트를 어떻게 작성할지 알아내는 충분한 동기가 됩니다
정말로 테스트를 어떻게 작성할지 알 수 없는 문제는 아직 접하지 못했습니다

저는 가능하면 테스트 우선으로 작업하겠다고 다짐합니다
테스트를 어떻게 작성해야 할지 아는 경우, **전에 사용한 기술을 그대로 사용하면서 앞으로 나아갑니다**
**코드를 어떻게 테스트해야 할지 알아내기 전까지는 결코 만족하지 않습니다**
저는 이런 실천을 '끈기'라고 부르겠습니다
*** 저자의 글
작동하는 깔끔한 코드(clean code that works)
이 한마디가 바로 테스트 주도 개발의 궁극적인 목표다

어떻게 하면 작동하는 깔끔한 코드를 얻을 수 있을까?
자동화된 테스트로 개발을 이끌어간다 (이런 개발방식을 테스트 주도 개발이라고 부른다 )

테스트 주도 개발
- 오직 자동화된 테스트가 실패할 경우에만 새로운 코드를 작성한다
- 중복을 제거한다

프로그래밍 순서
1. 빨강 - 실패하는 작은 테스트를 작성한다. 처음에는 컴파일조차 되지 않을 수 있다
2. 초록 - '빨리' 테스트가 통과하게끔 만든다. 이를 위해 어떤 죄악을 저질러도 좋다
3. 리팩토링 - 일단 테스트를 통과하게만 하는 와중에 생겨난 모든 중복을 제거한다

왜 테스트 주도 개발을 해야할까? -> 용기 때문이다
**테스트 주도 개발은 프로그래밍하면서 나타나는 두려움을 관리하는 방법이다**
여기서 두려움이란 "정말 어려운 문제라서 시작단계인 지금은 어떻게 마무될지 알 수 없군"하고 생각하는 식의 합리적인 두려움을 말한다
두려움은 다음과 같은 일의 원인을 제공하기도 한다
- 두려움은 여러분을 망설이게 만든다
  -> 불확실한 상태로 있는 대신, 가능하면 재빨리 구체적인 학습을 하기 시작한다
- 두려움은 여러분이 커뮤니케이션을 덜 하게 만든다
  -> 침묵을 지키는 대신, 좀더 분명하게 커뮤니케이션한다
- 두려움은 여러분이 피드백을 받는 것을 피하도록 만든다
  -> 피드백을 회피하는 대신, 도움이 되고 구체적인 피드백을 찾는다
- 두려움은 여러분을 까다롭게 만든다

프로그래밍 문제가 어려울수록 각각의 테스트는 좀더 작은 부분을 커버해야 한다

**TDD란 프로그래밍 도중 내린 결정과 그 결정에 대한 피드백 사이의 간격을 인지하고, 또한 이 간격을 통제할 수 있게 해주는 기술을 말한다**

책을 읽고나면
- 단순하게 시작하고
- 자동화된 테스트를 만들고
- 새로운 설계 결정을 한번에 하나씩 도입하기 위해 리팩토링을 할 준비가 될 것이다
*** 감사의 글
*** 들어가는 글
** 화폐 예제
*** 다중 통화를 지원하는 Money 객체
어떤 기능들이 있어야 할까?
즉 어떤 테스트들이 있어야(이 테스트들이 모두 통과할 경우 ) 보고서에 제대로 계산되도록 하는 코드가 완성됐다는걸 확신할 수 있을까?

앞으로 어떤 일을 해야 하는지 알려주고, 지금 하는 일에 집중할 수 있도록 도와주며, 언제 일이 다 끝나는지 알려줄 수 있게끔 할일 목록을 작성해보자

첫 번째 테스트는 좀 복잡해보인다
작은 것부터 시작하든지, 아니면 아예 손을 대지 않는게 좋다
이번엔 다음 항목인 곱하기를 보자. 대단히 어렵진 않겠지? 이걸 **먼저** 하는게 좋겠다

테스트를 작성할 때는 오퍼레이션의 완벽한 인터페이스에 대해 상상해보는 것이 좋다
오퍼레이션이 외부에서 어떤 식으로 보일지에 대한 이야기를 테스트 코드에 적고 있는 것이다
가능한 최선의 API에서 시작해서 거꾸로 작업하는 것이 애초부터 일을 복잡하고 보기 흉하며 '현실적'이게 하는 것보다 낫다

한 번에 하나씩 정복하기로 하자(난 항상 작업의 진척도를 알려줄 수 있는 수치적인 척도를 찾기 위해 노력한다 )

스텁구현(stub implementation)
메서드의 서명부와 (반환값이 있을 경우 ) 반환명령만 적는 식으로 해서, 이 메서드를 호출하는 코드(이 경우엔 테스트 코드 )가 컴파일 될 수 있도록 껍데기만 만들어두는 것

이것도 일종의 진척이다
이제 실패에 대한 구체적인 척도를 갖게 된 것이다
막연히 실패했다는 사실만 아는 것보다 나아진 것이다
우리 문제는 '다중 통화 구현'에서 '이 테스트를 통과시킨 후 나머지 테스트들도 통과시키기'로 변형된 것
훨씬 간단하다
범위도 훨씬 적어서 걱정이 줄었다

당장의 목표는 완벽한 해법을 구하는 것이 아니라 테스트를 통과하는 것일 뿐이다

주기
1. 작은 테스트 하나를 추가한다
2. 모든 테스트를 실행해서 테스트가 실패하는 것을 확인한다
3. 조금 수정한다
4. 모든 테스트를 실행해서 테스트가 성공하는 것을 확인한다
5. 중복을 제거하기 위해 리팩토링을 한다

프로그램에서는 중복만 제거해 주면 의존성도 제거된다

TDD의 핵심은 이런 **작은 단계를 밟아야 한다는 것이 아니라**, **이런 작은 단계를 밟을 능력을 갖추어야 한다는 것이다**
일이 좀 묘하게 꼬이기 시작하면 난 작은 단계를 밟을 능력이 내게 있다는 사실을 기뻐하게 된다
여러분이 직접 예제를 선택하여 작은 단계로 구현하는 연습을 해보기 바란다.
만약 정말 작은 단계로 작업하는 방법을 배우면, 저절로 적절한 크기의 단계로 작업할 수 있게 될 것이다
그러나 큰 단계로만 작업했다면, 더 작은 단계가 적절한 경우에 대해 결코 알지 못하게 된다

이번 경우엔 중복이 테스트에 있는 데이터와 코드에 있는 데이터 사이에 존재한다
*** 타락한 객체
어떤 구현이 올바른가에 대한 우리 추측이 완벽하지 못한 것과 마찬가지로 올바른 인터페이스에 대한 추측 역시 절대 완벽하지 못하다

빨리 초록색을 보기 위한 전략
- 가짜로 구현하기: 상수를 반환하게 만들고 진짜 코드를 얻을때까지 단계적으로 상수를 변수로 바꾸어나가기
- 명백한 구현 사용하기: 실제 구현을 입력한다

명백한 구현
모든 일이 자연스럽게 잘 진행되고
내가 뭘 입력해야 할지 알 때는 명백한 구현을 계속 더해 나간다
(나에게 명백한 사실이 컴퓨터에게도 명백한 사실인지 확인하기 위해 각각의 명백한 구현 사이에 테스트를 한 번씩 실행한다 )
예상치 못한 빨간 막대를 만나게 되면 뒤로 한발 물러서서 가짜로 구현하기 방법을 사용하면서 올바른 코드로 리팩토링한다
그러다 다시 자신감을 되찾으면 명배한 구현 사용하기 모드로 돌아온다

느낌을 테스트로 변환하는 것은 TDD의 일반적 주제다
이런 작업을 오래 할수록 **미적 판단을 테스트로 담아내는 것**에 점점 익숙해지게 된다
우선 시스템이 이런 식으로 동작해야 하는지 저런 식으로 동작해야 하는지 논의할 수 있다
일단 올바른 행위에 대해 결정을 내린 후에, 그 행위를 얻어낼 수 있는 최상의 방법에 대해 이야기할 수 있다
*** 모두를 위한 평등
이것을 할 일 목록에 적어놓고 이것 때문에 문제가 생기면 그때 다루도록 하자

나는 어떻게 리팩토링해야 하는지 전혀 감이 안 올 때만 삼각측량을 사용한다
코드와 테스트 사이의 중복을 제거하고 일반적인 해법을 구할 방법이 보이면 그냥 그 방법대로 구현한다
왜 한번에 끝낼 수 있는 일을 두고 또다른 테스트를 만들어야 하는가?

그러나 설계를 어떻게 할지 떠오르지 않을 때면, 삼각측량은 문제를 조금 다른 방향에서 생각해볼 기회를 제공한다
지금 설계하는 프로그램이 어떤 변화 가능성을 지원해야 하는가?
몇몇 부분을 변경시켜보면 답이 좀 더 명확해질 것이다
*** 프라이버시
이 테스트는 일련의 오퍼레이션이 아니라 참인 명제에 대한 단언들이므로 우리의 의도를 더 명확하게 이야기해준다
*** 솔직히 말하자면
적절한 시기에 적절한 설계를,
돌아가게 만들고, 올바르게 만들어라
*** 돌아온 '모두를 위한 평등'
테스트를 빨리 통과하기 위해 몇 톤이나 되는 코드를 **복사해서 붙이는** 엄청난 죄를 저질렀다
이제 청소할 시간이다
가능한 방법 한 가지는 우리가 만든 클래스 중 하나가 다른 클래스를 상속받게 하는 것이다
내가 그렇게 해봤는데, 거의 어떤 코드도 구원하지 못했다
대신, 그림 6.1과 같이 두 클래스의 공통 상위 클래스를 찾아낼 생각이다

적절한 테스트를 갖지 못한 코드에서 TDD를 해야 하는 경우가 종종 있을 것이다
리팩토링하면서 실수했는데도 불구하고 테스트가 여전히 통과할 수도 있는 것이다
어떻게 할 텐가?
있으면 좋을 것 같은 테스트를 작성하라
그렇게 하지 않으면 결국에는 리팩토링하다가 뭔가 깨트릴 것이다.
그러면 여러분은 리팩토링에 대해 안 좋은 느낌을 갖게 되고, 리팩토링을 덜 하게 된다
리팩토링을 더 적게 하면 설계의 질이 저하되고, 결국 여러분은 해고될 것이다
*** 사과와 오렌지
떠오른 생각에 대해 얘기해보자
Franc과 Dollar를 비교하면 어떻게 될까?

모델 코드에서 클래스를 이런 식으로 사용하는 것은 좀 지저분해 보인다
자바 객체의 용어를 사용하는 것보다 재정 분야에 맞는 용어를 사용하고 싶다
하지만 현재는 통화(currency) 개념 같은게 없고, 통화 개념을 도입할 충분한 이유가 없어 보이므로 잠시 동안은 이대로 두자
*** 객체 만들기
*** 우리가 사는 시간
*** 흥미로운 시간
*** 모든 악의 근원
*** 드디어, 더하기
*** 진짜로 만들기
*** 바꾸기
*** 서로 다른 통화 더하기
*** 드디어, 추상화
*** Money 회고
** xUnit 예시
*** xUnit으로 가는 첫걸음
*** 테이블 차리기
*** 뒤정리하기
*** 셈하기
*** 실패 처리하기
*** 얼마나 달콤한지
*** xUnit 회고
** 테스트 주도 개발의 패턴
*** 테스트 주도 개발 패턴
*** 빨간 막대 패턴
*** 테스팅 패턴
*** 초록 막대 패턴
*** xUnit 패턴
*** 디자인 패턴
*** 리팩토링
*** TDD 마스터하기
