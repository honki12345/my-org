* 객체에서 함수로
SCHEDULED: <2025-03-25 화>
** 서문
*** 목표
함수형 프로그래밍을 처음 배울 때 읽으면 좋을 책
- 가변 상태와 부수 효과를 제거하는 방법
- 견고하고 적응 가능한 소프트웨어 구축이 목표
*** 경험
함수형 스타일에 대해 배우면서 *애플리케이션을 디자인 하는 방식* 이 변했다

추상적인 원칙보다 *단순성과 생산성* 을 추구하기로 결심

함수형이 필요한 작업량을 *줄이는 데* 도움이 될 수는 있다
** 왜 함수형 프로그래밍인가?
*** 왜 코틀린인가?
*** 함수형 프로그래밍의 진정한 의미는 무엇인가?
*** 객체 지향 프로그래밍 지식 일부러 잊어버리기
*** 요약
** 애플리케이션 준비하기
*** 예제 애플리케이션 정의하기
*** 제타이: 혁신적인 할 일 목록 애플리케이션
*** 테스트가 개발을 안내하게 하라
*** 프로젝트 설정하기
*** 단위 테스트를 함수형으로 만들기
*** 요약
*** 연습문제
** 부록A 함수형 프로그래밍이란 무엇인가?
함수형 프로그래밍은 어디에서 왔고 언제 시작되었는가
*** 기원
존 배커스가 주장하는 비함수형 언어들의 네가지 결함
- 상태 전이와 의미론적으로 밀접하게 결합되어 있다
  - 각 상태 변호에 구체적인 의미(의미론적 값)을 부여하면 상태 변하가 구체적 동작과 결합되기 때문에
    구성원소를 새로운 프로그램에 결합하고 재사용할 수 있는 유연성을 잃게 된다
- 프로그래밍을 식과 문의 세계로 나눈다
- 결합 형식을 사용할 능력이 없다
- 수학적 속성이 부족하다
  - 중간에서 변수의 값을 변경할 수 있는 대입문을 도입함으로써, 수학적 표기법의 기본 규칙을 깨트렸다
  - 프로그래밍 언어는 참조 투명하지 않게 되었다
**** 디자인패턴
재사용 필요성을 *예상* 하고 그에 맞게 코드를 디자인하거나 다시 리팩토링 해야한다
**** 람다 계산법
람다 계산법은 계산을 수학적으로 분석할 수 있는 방식으로 표현하는 형식적인 방법이다

람다 계산은 우리가 바인딩해야 할 변수를 선언하도록 요구한다
변수를 함수에 바인딩하는 것을 표현하기 위해 그리스 문자 람다를 사용한다
**** 참조 투명성
여러 번 호출해도 동일한 입력에 대해 동일한 결과를 반환해야 하며,
시스템 나머지 부분(애플리케이션의 상태)에 영향을 미치지 않아야 한다
**** 카테고리 이론
'일반적인 추상적 무의미함'
- 구조의 *실제 내용* 을 보지 않고 변환을 통해 구조가 어떻게 *유지되는지* 에 대해 연구
- 함수형 프로그래밍은 이러한 변환(=사상, morphism)의 합성을 통해 소프트웨어를 정의
*** 참조 투명성 달성하기
함수형 3가지 원칙
- 순수성
- 불변성
- 전체성

참조 투명성이 함수형 프로그래밍을 작동하게 만드는 요소

이 책에서 함수란 '불변 타입에서 동작하는 순수한 전체성 함수'
**** 함수를 순수하게 유지하라
순수함수
- 값을 반환해야한다
- 입력에만 의존해야한다
**** 가변 타입을 신뢰하지 마라
**** 가능한 입력을 모두 고려하라
전체성(totality): 모든 입력에 대해 유한 시간 내에 결과를 반환하는 함수
- 무한 루르르 가질 수 없다
- 모든 입력을 처리해야한다. 예외를 던질 수 없다
*** 사상으로 생각하기

**** 객체지향 vs 함수형
객체지향은 모든 것이 내부 상태를 숨긴 객체 간의 메시지 교환에 기반한다
함수형은 모든 것이 변환과 합성에 기반한다
**** 함수를 데이터로 취급하라
**** 타입을 정확하게 정의하라
**** 선언형 스타일을 선호하라
다른 사람에게 작업을 지시하는 방법
- 필요한 모든 단계를 정확히 지정하거나 (명령형)
- 최종 목표가 무엇인지 설명하기 (선언형)

선언형 객체지향코드도 가능하고 함수형 명령형 코드도 가능하다
하지만 함수형 프로그래밍은 선언형 스타일을 더 넓고 강력하게 사용할 수 있다
가능한 명령형 스타일보다 선언형 스타일을 채택해야 한다
**** 게으름을 피워라
지연계산이란 어떤 식의 평가를 가능한 마지막 순간까지, 그 결과가 필요할 때까지 미루는 것

지연성이 코드 디버깅을 어렵게 만들 수도 있다
호출이 생성한 장소와 다른 곳에서 발생할 수 있기 때문이다
*** 요약
**** 함수형 원칙
순수성: 동일한 입력은 동일한 결과를 만들어내야 한다
불변성: 모든 데이터 구조는 불변이어야 한다
전체성: 함수는 예외를 던지지 않고 모든 입력에 대해 결과를 반환해야 한다
**** 조언
선언형 스타일을 선호하라: 원하는 것을 달성하는 방법을 기술하지 말고 무엇을 달성하고 싶은지 표현하라
타입을 정확하게 정의하라: 함수의 시그니처를 의미 있게 만들어라
함수를 데이터로 취급하라: 더 간단한 함수를 결합해 행동 방식을 정의하라
게으름을 피워라: 가능한 마지막 순간까지 계산을 미뤄라
** 부록B 함수형 코틀린에 대하여
다른 언어의 기능을 잘 복사하고 자바에 최대한 가깝게 유지하자는 접근방식이 코틀린의 주요 강점
*** 코틀린 설정하기
*** 코틀린 개론
**** 함수
***** 함수참조
~::plusOne~ 과 같이 함수 이름 앞에 콜론을 두개 붙여서 함수를 직접 참조할 수 있다
**** Nothing
~Unit~ 이 코틀린에서 문(statement) 의 타입
- 프로그램이 정상적으로 돌면서 값은 만들어냈는데 그 값을 사용할 필요가 없을 때

반환을 하지 않는 함수의 타입은 ~Nothing~ 이다
- 값의 부재를 나타내는 특별한 타입
**** 람다변수
함수의 마지막 인자가 람다인 경우 이 람다를 함수 인자 목록을 표현하는 괄호 밖에 넣을 수 있다

#+begin_src kotlin
  val plusOneL = fun(x: Int): Int { return x + 1 }

  // fun 키워드와 명시적 return 생략
  val plusOneL: (Int) -> Int = {x: Int -> x + 1}

  // 파라미터가 한 개만 있는 경우 암시적 파라미터 it 사용
  val plusOneL: (Int) -> Int = {it + 1}
#+end_src
**** 확장함수
확장함수는 첫번째 파라미터를 수신 객체 위치에 두는 독립함수를 뜻한다
- 수신 객체 인자를 참조하기 위해 ~this~ 를 사용한다

확장함수는 정적 메서드에 대한 문법 설탕일 뿐이다

확장함수의 타입에서는 인자가 수신 객체임을 나타내기 위해 괄호 밖에 위치시킨다
#+begin_src kotlin
  val nextFn: Int.() -> Int = Int::next
#+end_src
**** 영역함수
영역함수는 모두 확장함수로 람다 하나를 인자로 받는다

let, run:
- 람다를 호출하고 결과를 *반환* 한다
- 람다 내부에서 전달받은 객체를 파라미터(it)로 사용한다


also, apply:
- 람다를 호출하고 결과를 *무시* 한다
- 람다 내부에서 전달받은 객체를 파라미터(this)로 사용한다
**** 클래스
주 생성자(primary constructor)의 파라미터 목록을 클래스 이름 바로 뒤에 선언한다

코틀린에서는 클래스, 메서드, 필드가 기본적으로 모두 ~final~ 이다
이를 변경할려면 ~open~ 키워드를 추가해야 한다
**** 객체와 동반 객체
코틀린에는 ~static~ 키워드가 없다
대신 클래스 이름으로 호출되는 암시적 싱글턴인 동반 객체(companion object) 안에 메서드를 넣을 수 있다
**** 데이터 클래스
데이터 클래스는 값 객체를 표현할 때 유용하다
데이터 클래스를 선언하기만 해도 비교와 동등성을 위한 메서드(equals, toString, hashCode) 를 생성한다

데이터 클래스의 필드는 기본적으로 불변이지만 ~var~ 키워드를 사용해 가변으로 만들 수 있다

데이터 클래스는 하나 이상의 필드만 수정한 인스턴스의 복사본을 만들 수 있는 메서드(~copy~)를 제공한다
**** 위임을 통한 구현
**** 위임 프로퍼티
**** 타입 별명
**** 내부 가시성
자바의 private, public, protected 가시성 한정자를 가진다
internal 가시성이 있다
이는 동일한 모듈 안에서만 볼 수 있는 가시성 한정자다
코틀린 모듈이란 프로젝트나, Intellij 모듈, 그레이들 소스 집합 처럼 함께 컴파일 되는 파일들의 집합을 뜻한다

코틀린 기본 가시성은 public 이며 자바처럼 패키지가 아니다
**** when
**** 봉인된 클래스
봉인된 클래스는 같은 패키지와 같은 모듈 안에서만 상속이 가능한 클래스다
봉인된 클래스 자체는 추상 클래스이며, 직접 인스턴스화 할 수 없다
**** 봉인된 인터페이스
봉인된 인터페이스는 봉인된 모든 인스턴스가 공통 필드를 가질 때 유용하다
**** 시퀀스
컬렉션처럼 동작하는 특수한 이터레이터:
무한리스트를 만들고 필요한 원소만 사용할 수 있다
*** 코틀린 타입 시스템 연구
**** 널이 될 수 있는 타입
물음표를 추가해 널이 될 수 없는 타입과 널을 결합한다

규칙
- 널이 될 수 없는 타입의 변수에 널을 대입할 수 없다
- 널이 될 수 있는 타입의 식에 대해 ~null~ 검사를 먼저 하지 않고는 메서드를 호출할 수 없다

***** 앨비스(Elvis) 연산자
- 물음표 뒤에 콜론이 따라오는 모양
- 왼쪽 객체가 널인 경우 오른쪽 값을 반환한다

#+begin_src kotlin
  matbeAString?.length ?: 0
#+end_src
