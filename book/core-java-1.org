#+title: Core Java 1

* core java
** About This eBook
** Preface
*** To the Reader
I assume that you don't like books filled with toy examples
My goal(writer) is to enable you to fully understand the Java language and library

This first volume concentrates **on the fundamental concepts** of the Java language
The second volume, *Core Java, Volume 2: Advanced Features*, goes further into the most import libraries

*** A Tour of This Book
*** Conventions
*** Sample Code
** Acknowledgments
** An Introduction to Java 1
*** Java as a Programming Platform
Java is a whole *platform*, with a huge library, containing lots of reusable code, and an execution environment that provides services such as security, portability across operating systems, and automatic garbage collection
*** The Java "White Paper" Buzzwords
**** simple
The syntax for Java is, indeed, a cleaned-up version of C++ syntax
**** object-oriented
**** distributed
**** robust
**** secure
**** architecture-neutral
**** portable
**** interpreted
**** high-performance
**** multithreaded
**** dynamic
*** Java Applets and the Internet
*** A Short History of Java
*** Common Misconceptions about Java
** The Java Programming Environment 15
how to install JDK
how to compile
how to run Java programs
*** Installing the Java Development Kit
**** Downloading the JDK
depending on the provider, the Java Development Kit may have a brand name, such as Temurin(Eclipse Foundation)

| Name                     | Acronym | Explanation                                                                                                                |
|--------------------------+---------+----------------------------------------------------------------------------------------------------------------------------|
| Java Development Kit     | JDK     | The software for programmers who want to write Java Programs                                                               |
| Java Runtime Environment | JRE     | Only supported unitl Java 8                                                                                                |
| Standard Edition         | SE      |                                                                                                                            |
| Micro Edition            | ME      |                                                                                                                            |
| OpenJDK                  | -       | A free and open source implementation of Java SE                                                                           |
| Hotspot                  | -       | The "just in time" compiler by Oracle                                                                                      |
| OpenJ9                   | -       | jit by IBM                                                                                                                 |
| GraalVM                  | -       | "ahead of time" compiler                                                                                                   |
| Long Term Support        | LTS     | A release that is supported for multiple years                                                                             |
| Eclipse                  | -       | A foundation that distributes open-source software                                                                         |
| Termurin                 | -       | The brand name for the OpenJDK version that the Eclipse foundation distributes                                             |
| Adoptium                 | -       | The project within the Eclipse Foundation that provides an OpenJDK version and infrastructure support for its distribution |
**** Setting Up the JDK

*** Using the Command-Line Tools
The compiler requires a *file name*(~Welcome.java~). When you run the program, you specify a *class name*(~Welcome~) without a ~.java~ or ~.class~ extension
*** Using an Integrated Development Environment
*** JShell
** Fundamental Programming Structures in Java 31
*** A Simple Java Program
Java *is case sensitive*
if you made any mistakes in capitalization, the program will not run

The keyword ~public~ is called an *access modifier*
these modifiers control the level of access other parts of a program have to this code

everything in a Java program lives inside a class

you need to make the file name for the source code the same as the name of the *public class*, with the extension ~.java~ appended
**** name of the class
class names are nouns that start with an uppercase letter
Names must begin with a letter, and after that, they can have any combination of letters and digits
The length is essentially unlimited
You cannot use a Java reserved word(such as ~public~ or ~class~)
**** main method
According to the Java language Specification, the ~main~ method must be declared ~public~`
The Java Language Specification is the official document that describes the java language

~main~ method does not return an "exit code" to the os
If the ~main~ method exits normally, the java program has the exit code ~0~ indicating successful completion
To terminate the program with a different exit code, call ~System.exit(code)~.

*** Comments
- ~//~
- ~/*~, ~*/~
- ~/**~, ~*/~
  - this comment is used to generate documentation automatically
*** Data Types
Java is a *strongly typed language*
This means that every variable must have a declared type

There are eight *primitive types* in Java.
- Four of them are integer types
- Two are floating-point number types
- one is the character type used for UTF-16 code units in the Unicode encoding scheme
- one is for truth values

**** Integer Types
The integers types are for numbers without fractional parts
Negative values are allowed
Java does not have any ~unsigned~ versions of the ~int~, ~long~, ~short~, or ~byte~ types

| Type  | Storage Requirements | Range(Inclusive)                |
|-------+----------------------+---------------------------------|
| byte  | 1 byte               | -128 to 127                     |
| short | 2 bytes              | -32,768 to 32,767               |
| int   | 4 bytes              | -2,147,483,648 to 2,147,483,647 |
| long  | 8 bytes              | -                               |

The ~byte~ and ~short~ types are mainly intended for specialized applications, such as low-level file handling or for large arrays *when storage space is at a premium*

Under Java, the ranges of the integer types do not depend on the machine on which you will be running the Java code

Long integer numbers have a suffix ~L~ or ~l~
- e.g. ~4000000000L~
Hexadecimal numbers have a prefix ~0x~ or ~0X~
- e.g. ~0xCAFE~
Octal numbers have a prefix ~0~
- e.g. ~010~
numbers in binary with a prefix ~0b~, ~0B~
- e.g. ~0b1001~
You can add underscores to the number literals
- The Java compiler simply removes them
- e.g. ~1_000_000~

If you work with integer values that can never be negative and you really need an additional bit, you can, with some care, interpret signed integer values are unsigned
- Due to the nature of binary arithmetic, addition, subtraction, and multiplication will work provided they don't overlflow
- call ~Byte.toUnsignedInt(b)~ to get an ~int~ value between 0 and 255, then process the integer value and cast back to ~byte~

The ~Integer~ and ~Long~ classes have methods for unsigned division and remainder

**** Floating-Point Types
The limited precision of ~float~ (6-7 significant digits) is simply not sufficient for many situations
Use ~float~ values only when you work with a library that requires them, or when you need to store a very large number of them

Java 20 adds a couple of methods(~Float.floatToFloat16~ and ~Float.float16toFloat~) for storing "half-precision" 16-bit floating-point numbers in ~short~ values. These are used for *implementating neural networks*

Numbers of type ~float~ have a suffix ~F~, ~f~
Floating-point numbers without an ~F~ suffix are always considered to be of type ~double~

An ~E~ or ~e~ denotes a decimal exponent
- e.g. ~1.729E3~

You can specify floating-point literals in hexadecimal

All floating-point computations follow the IEEE-754 specification

There are three special floating-point values to denote *overflows and erros*
The constants ~Double.POSITIVE_INFINITY~, ~Double.NEGETIVE_INFINITY~, and ~Double.NaN~ represent these special values, but *they are rarely used in practive*
- Positive infinity
  - e.g. the result of dividing a positive floating-point number by 0 is positive infinity
- Negative infinity
- NaN(not a number)
  - e.g. Dividing 0.0 by 0 or the square root of a negative number yields NaN

Floating-point numbers are *not* suitable *for financial calculations* in which roundoff erros cannot be tolerated
- Such roundoff errors are caused by the fact that floating-point numbers are represented in the binary system
  - There is no precise binary representation of the fraction 1/10, just as there is no accurate representation of the fraction 1/3 in the decimal system
- if you need precise numerical computations without roundoff errors, use the ~BigDecimal~ class
**** The ~char~ Type
some Unicode characters can be decribed with *one* ~char~ value, and other Unicode characters require *two* ~char~ value

Literal values of type ~char~ are enclosed in single quotes
Values of type ~char~ can be expressed as hexadecimal values that run from `\u0000` to `\uFFFF`
The ~\u~ escape sequence(but none of the other escape sequences) can even be used *outside* quoted character constants and strings
Unicode escape sequences are processed before the code is parsed

You can have any number of ~u~ in a Unicode escape sequence

Escape Sequences for Special Characters
| Escape Sequence | Name                                                     |
|-----------------+----------------------------------------------------------|
| \b              | Backspace                                                |
| \t              | Tab                                                      |
| \n              | Line feed                                                |
| \r              | Carriage return                                          |
| \f              | Form feed                                                |
| \"              | Double quote                                             |
| \'              | Single quote                                             |
| \\              | Backslash                                                |
| \s              | Space. Used in text blocks to retain trailing whitespace |
| \newline        | In text blocks only: Join this line with the next        |
**** Unicode and the ~char~ Type
There were many different character encoding standards: ASCII, ISO 8859-1 ...
This caused two problems
- A particular code value corresponds to different letters in the different encoding schemes
- The encodings for languages with large character sets have variable length
~Unicode~ was designed to solve both problems: a fixed 2-byte code
~Java~ was designed from the ground up *to use 16-bit Unicode characters*
Now, the 16-bit ~char~ type is *insufficient* to decribe all Unicode characters

A *code point* is an integer value associated with a character in an encoding scheme
In the Unicode standard, code points are written in hexadecimal and prefixed with U+, such U+0041
A Unicode has code points that are grouped into 17 *code planes*, each holding 65536 characters

How a Unicode code point(that is, an integer ranging from 0 to hexadecimal 10FFF) is represented in bits depends on the *character encoding*
Java strings use the UTF-16 encoding
It encodes all Unicode code points in a variable-length code of 16-bit units, called *code units*
The characters in the basic multilingual plane are encoded as a single code unit.
All other characters are encoded as consecutive pairs of code units
Each of the code units in such an encoding pair falls into a range of 2048 unused values of the basic multilingual plane, called the *surrogates area*(`\uD800` to `\uDBFF` for the first code unit, `\uDC00` to `\uDFFF` for the second code unit)
you can immediately tell whether a code unit encodes a single character or it is the first or second part of supplementary character

Nowadays, Unicode has become so complex
with languages whose characters are made from smaller building blocks, with emojis that can have modifiers for gender and skine tone
**** The ~boolean~ Type
The ~boolean~ type has two values, ~false~ and ~true~

You cannot convert between integers and ~boolean~ values

*** Variables and Constants
Variable are used to store values
Constants are variables whose values don't change

**** Declaring Variables
In Java, every variable has a *type*

The semicolon is necessary because a declaration is a complete Java statement, which must end in a semicolon

The identifier for a variable name(as well as for other names) is made up of letters, digits, currency symbols, and "punctuation connectors"
The first character cannot be a digit

Even though ~$~ is a valid character in an identifier, you should not use it in your own code. It is intended for names that are generated by the Java compiler and other tools

You can declare multiple variables on a single line
If you declare each variable separately, your programs are easier to read
**** Initializing Variables
In Java, it is considered good style to declare variables as closely as possible to the point where they are first used
**** Constants
In Java, you use the keyword ~final~ to denote a constant

The keyword ~final~ indicates that you can assign to the variable once, and then its value is *set once and for all*
It is customary to name constants in all uppercase

class constants
**** Enumerated Types
Sometimes, a variable should only hold a restricted set of values
An enumerated type has a finite number of named values
A variable of type enum can hold only one of the values listed in the type declaration, or the special value ~null~ that indicates that the variable is not set to any value at all
*** Operators
**** Arithmetic Operators
~/~
integer divison If both operands are integers, and floating-point divison
Integer division by 0 raises an exception
whereas floating-point division by 0 yields an infinite or NaN result

When one of the operands of ~%~ is negative, so is the result
*** Strings
*** Input and Output
*** Control Flow
*** Big Numbers
*** Arrays
** Objects and Classes 127
*** Introduction to Object-Oriented Programming
*** Using Predefined Classes
*** Defining Your Own Classes
*** Static Fields and Methods
*** Method Parameters
*** Object Construction
*** Records
*** Packages
*** JAR Files
*** Documentation Comments
*** Class Design Hints
** Inheritance 217
*** Classes, Superclasses, and Subclasses
*** Object: The Cosmic Superclass
*** Generic Array Lists
*** Object Wrappers and Autoboxing
*** Methods with a Variable Number of Arguments
*** Abstract Classes
*** Enumeration Classes
*** Sealed Classes
*** Pattern Matching
*** Reflection
*** Desing Hints for Inheritance
** Interfaces, Lambda Expressions, and Inner Classes 327
*** Interfaces
*** Lambda Expressions
*** Inner Classes
*** Service Loaders
*** Proxies
** Exceptions, Assertions, and Logging 403
*** Dealing with Errors
*** Catching Exceptions
*** Tips for Using Exceptions
*** Using Assertions
*** Logging
*** Debugging Tips
** Generic Programming 459
*** Why Generic Programming
*** Defining a Simple Generic Class
*** Generic Methods
*** Bounds for Type Variables
*** Generic Code and the Virtual Machine
*** Inheritance Rules for Generic Types
*** Wildcard Types
*** Restrictions and Limitations
*** Reflection and Generics
** Collections 511
*** The Java Collections Framework
*** Interfaces in the Collections Framework
*** Concrete Collections
*** Maps
*** Copies and Views
*** Algorithms
*** Legacy Collections
** Concurrency 599
*** Running Threads
*** Thread States
*** Thread Properties
*** Coordinating Tasks
*** Synchronization
*** Thread-Safe Collections
*** Asynchronous Computations
*** Processes
** Annotations 711
*** Using Annotations
*** Defining Annotations
*** Annotations in the JAVA API
*** Processing Annotations at Runtime
*** Source-Level Annotation Processing
*** Bytecode Engineering
** The Java Platform Module System 747
*** The Module Concept
*** Naming Modules
*** The Modular "Hello, World!" Program
*** Requiring Modules
*** Exporting Packages
*** Modular JARs
*** Modules and Reflective Access
*** Automatic Modules
*** The Unnamed Module
*** Command-Line Flags for Migration
*** Transitive and Static Requirements
*** Qualified Exporting and Opening
*** Service Loading
*** Tools for Working with Modules
