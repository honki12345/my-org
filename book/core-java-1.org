#+title: Core Java 1

* core java
** About This eBook
** Preface
*** To the Reader
I assume that you don't like books filled with toy examples
My goal(writer) is to enable you to fully understand the Java language and library

This first volume concentrates **on the fundamental concepts** of the Java language
The second volume, *Core Java, Volume 2: Advanced Features*, goes further into the most import libraries

*** A Tour of This Book
*** Conventions
*** Sample Code
** Acknowledgments
** An Introduction to Java
*** Java as a Programming Platform
Java is a whole *platform*, with a huge library, containing lots of reusable code, and an execution environment that provides services such as security, portability across operating systems, and automatic garbage collection
*** The Java "White Paper" Buzzwords
**** simple
The syntax for Java is, indeed, a cleaned-up version of C++ syntax
**** object-oriented
**** distributed
**** robust
**** secure
**** architecture-neutral
**** portable
**** interpreted
**** high-performance
**** multithreaded
**** dynamic
*** Java Applets and the Internet
*** A Short History of Java
*** Common Misconceptions about Java
** The Java Programming Environment
how to install JDK
how to compile
how to run Java programs
*** Installing the Java Development Kit
**** Downloading the JDK
depending on the provider, the Java Development Kit may have a brand name, such as Temurin(Eclipse Foundation)

| Name                     | Acronym | Explanation                                                                                                                |
|--------------------------+---------+----------------------------------------------------------------------------------------------------------------------------|
| Java Development Kit     | JDK     | The software for programmers who want to write Java Programs                                                               |
| Java Runtime Environment | JRE     | Only supported unitl Java 8                                                                                                |
| Standard Edition         | SE      |                                                                                                                            |
| Micro Edition            | ME      |                                                                                                                            |
| OpenJDK                  | -       | A free and open source implementation of Java SE                                                                           |
| Hotspot                  | -       | The "just in time" compiler by Oracle                                                                                      |
| OpenJ9                   | -       | jit by IBM                                                                                                                 |
| GraalVM                  | -       | "ahead of time" compiler                                                                                                   |
| Long Term Support        | LTS     | A release that is supported for multiple years                                                                             |
| Eclipse                  | -       | A foundation that distributes open-source software                                                                         |
| Termurin                 | -       | The brand name for the OpenJDK version that the Eclipse foundation distributes                                             |
| Adoptium                 | -       | The project within the Eclipse Foundation that provides an OpenJDK version and infrastructure support for its distribution |
**** Setting Up the JDK

*** Using the Command-Line Tools
The compiler requires a *file name*(~Welcome.java~). When you run the program, you specify a *class name*(~Welcome~) without a ~.java~ or ~.class~ extension
*** Using an Integrated Development Environment
*** JShell
** Fundamental Programming Structures in Java
*** A Simple Java Program
Java *is case sensitive*
if you made any mistakes in capitalization, the program will not run

The keyword ~public~ is called an *access modifier*
these modifiers control the level of access other parts of a program have to this code

everything in a Java program lives inside a class

you need to make the file name for the source code the same as the name of the *public class*, with the extension ~.java~ appended
**** name of the class
class names are nouns that start with an uppercase letter
Names must begin with a letter, and after that, they can have any combination of letters and digits
The length is essentially unlimited
You cannot use a Java reserved word(such as ~public~ or ~class~)
**** main method
According to the Java language Specification, the ~main~ method must be declared ~public~`
The Java Language Specification is the official document that describes the java language

~main~ method does not return an "exit code" to the os
If the ~main~ method exits normally, the java program has the exit code ~0~ indicating successful completion
To terminate the program with a different exit code, call ~System.exit(code)~.

*** Comments
- ~//~
- ~/*~, ~*/~
- ~/**~, ~*/~
  - this comment is used to generate documentation automatically
*** Data Types
Java is a *strongly typed language*
This means that every variable must have a declared type

There are eight *primitive types* in Java.
- Four of them are integer types
- Two are floating-point number types
- one is the character type used for UTF-16 code units in the Unicode encoding scheme
- one is for truth values

**** Integer Types
The integers types are for numbers without fractional parts
Negative values are allowed
Java does not have any ~unsigned~ versions of the ~int~, ~long~, ~short~, or ~byte~ types

| Type  | Storage Requirements | Range(Inclusive)                |
|-------+----------------------+---------------------------------|
| byte  | 1 byte               | -128 to 127                     |
| short | 2 bytes              | -32,768 to 32,767               |
| int   | 4 bytes              | -2,147,483,648 to 2,147,483,647 |
| long  | 8 bytes              | -                               |

The ~byte~ and ~short~ types are mainly intended for specialized applications, such as low-level file handling or for large arrays *when storage space is at a premium*

Under Java, the ranges of the integer types do not depend on the machine on which you will be running the Java code

Long integer numbers have a suffix ~L~ or ~l~
- e.g. ~4000000000L~
Hexadecimal numbers have a prefix ~0x~ or ~0X~
- e.g. ~0xCAFE~
Octal numbers have a prefix ~0~
- e.g. ~010~
numbers in binary with a prefix ~0b~, ~0B~
- e.g. ~0b1001~
You can add underscores to the number literals
- The Java compiler simply removes them
- e.g. ~1_000_000~

If you work with integer values that can never be negative and you really need an additional bit, you can, with some care, interpret signed integer values are unsigned
- Due to the nature of binary arithmetic, addition, subtraction, and multiplication will work provided they don't overlflow
- call ~Byte.toUnsignedInt(b)~ to get an ~int~ value between 0 and 255, then process the integer value and cast back to ~byte~

The ~Integer~ and ~Long~ classes have methods for unsigned division and remainder

**** Floating-Point Types
The limited precision of ~float~ (6-7 significant digits) is simply not sufficient for many situations
Use ~float~ values only when you work with a library that requires them, or when you need to store a very large number of them

Java 20 adds a couple of methods(~Float.floatToFloat16~ and ~Float.float16toFloat~) for storing "half-precision" 16-bit floating-point numbers in ~short~ values. These are used for *implementating neural networks*

Numbers of type ~float~ have a suffix ~F~, ~f~
Floating-point numbers without an ~F~ suffix are always considered to be of type ~double~

An ~E~ or ~e~ denotes a decimal exponent
- e.g. ~1.729E3~

You can specify floating-point literals in hexadecimal

All floating-point computations follow the IEEE-754 specification

There are three special floating-point values to denote *overflows and erros*
The constants ~Double.POSITIVE_INFINITY~, ~Double.NEGETIVE_INFINITY~, and ~Double.NaN~ represent these special values, but *they are rarely used in practive*
- Positive infinity
  - e.g. the result of dividing a positive floating-point number by 0 is positive infinity
- Negative infinity
- NaN(not a number)
  - e.g. Dividing 0.0 by 0 or the square root of a negative number yields NaN

Floating-point numbers are *not* suitable *for financial calculations* in which roundoff erros cannot be tolerated
- Such roundoff errors are caused by the fact that floating-point numbers are represented in the binary system
  - There is no precise binary representation of the fraction 1/10, just as there is no accurate representation of the fraction 1/3 in the decimal system
- if you need precise numerical computations without roundoff errors, use the ~BigDecimal~ class
**** The ~char~ Type
some Unicode characters can be decribed with *one* ~char~ value, and other Unicode characters require *two* ~char~ value

Literal values of type ~char~ are enclosed in single quotes
Values of type ~char~ can be expressed as hexadecimal values that run from `\u0000` to `\uFFFF`
*** Variables and Constants
*** Operators
*** Strings
*** Input and Output
*** Control Flow
*** Big Numbers
*** Arrays
** Objects and Classes
*** Introduction to Object-Oriented Programming
*** Using Predefined Classes
*** Defining Your Own Classes
*** Static Fields and Methods
*** Method Parameters
*** Object Construction
*** Records
*** Packages
*** JAR Files
*** Documentation Comments
*** Class Design Hints
** Inheritance
*** Classes, Superclasses, and Subclasses
*** Object: The Cosmic Superclass
*** Generic Array Lists
*** Object Wrappers and Autoboxing
*** Methods with a Variable Number of Arguments
*** Abstract Classes
*** Enumeration Classes
*** Sealed Classes
*** Pattern Matching
*** Reflection
*** Desing Hints for Inheritance
** Interfaces, Lambda Expressions, and Inner Classes
*** Interfaces
*** Lambda Expressions
*** Inner Classes
*** Service Loaders
*** Proxies
** Exceptions, Assertions, and Logging
*** Dealing with Errors
*** Catching Exceptions
*** Tips for Using Exceptions
*** Using Assertions
*** Logging
*** Debugging Tips
** Generic Programming
*** Why Generic Programming
*** Defining a Simple Generic Class
*** Generic Methods
*** Bounds for Type Variables
*** Generic Code and the Virtual Machine
*** Inheritance Rules for Generic Types
*** Wildcard Types
*** Restrictions and Limitations
*** Reflection and Generics
** Collections
*** The Java Collections Framework
*** Interfaces in the Collections Framework
*** Concrete Collections
*** Maps
*** Copies and Views
*** Algorithms
*** Legacy Collections
** Concurrency
*** Running Threads
*** Thread States
*** Thread Properties
*** Coordinating Tasks
*** Synchronization
*** Thread-Safe Collections
*** Asynchronous Computations
*** Processes
** Annotations
*** Using Annotations
*** Defining Annotations
*** Annotations in the JAVA API
*** Processing Annotations at Runtime
*** Source-Level Annotation Processing
*** Bytecode Engineering
** The Java Platform Module System
*** The Module Concept
*** Naming Modules
*** The Modular "Hello, World!" Program
*** Requiring Modules
*** Exporting Packages
*** Modular JARs
*** Modules and Reflective Access
*** Automatic Modules
*** The Unnamed Module
*** Command-Line Flags for Migration
*** Transitive and Static Requirements
*** Qualified Exporting and Opening
*** Service Loading
*** Tools for Working with Modules
