#+title: Core Java 1

* core java
** About This eBook
** Preface
*** To the Reader
I assume that you don't like books filled with toy examples
My goal(writer) is to enable you to fully understand the Java language and library

This first volume concentrates **on the fundamental concepts** of the Java language
The second volume, *Core Java, Volume 2: Advanced Features*, goes further into the most import libraries

*** A Tour of This Book
*** Conventions
*** Sample Code
** Acknowledgments
** An Introduction to Java 1
*** Java as a Programming Platform
Java is a whole *platform*, with a huge library, containing lots of reusable code, and an execution environment that provides services such as security, portability across operating systems, and automatic garbage collection
*** The Java "White Paper" Buzzwords
**** simple
The syntax for Java is, indeed, a cleaned-up version of C++ syntax
**** object-oriented
**** distributed
**** robust
**** secure
**** architecture-neutral
**** portable
**** interpreted
**** high-performance
**** multithreaded
**** dynamic
*** Java Applets and the Internet
*** A Short History of Java
*** Common Misconceptions about Java
** The Java Programming Environment 15
how to install JDK
how to compile
how to run Java programs
*** Installing the Java Development Kit
**** Downloading the JDK
depending on the provider, the Java Development Kit may have a brand name, such as Temurin(Eclipse Foundation)

| Name                     | Acronym | Explanation                                                                                                                |
|--------------------------+---------+----------------------------------------------------------------------------------------------------------------------------|
| Java Development Kit     | JDK     | The software for programmers who want to write Java Programs                                                               |
| Java Runtime Environment | JRE     | Only supported unitl Java 8                                                                                                |
| Standard Edition         | SE      |                                                                                                                            |
| Micro Edition            | ME      |                                                                                                                            |
| OpenJDK                  | -       | A free and open source implementation of Java SE                                                                           |
| Hotspot                  | -       | The "just in time" compiler by Oracle                                                                                      |
| OpenJ9                   | -       | jit by IBM                                                                                                                 |
| GraalVM                  | -       | "ahead of time" compiler                                                                                                   |
| Long Term Support        | LTS     | A release that is supported for multiple years                                                                             |
| Eclipse                  | -       | A foundation that distributes open-source software                                                                         |
| Termurin                 | -       | The brand name for the OpenJDK version that the Eclipse foundation distributes                                             |
| Adoptium                 | -       | The project within the Eclipse Foundation that provides an OpenJDK version and infrastructure support for its distribution |
**** Setting Up the JDK

*** Using the Command-Line Tools
The compiler requires a *file name*(~Welcome.java~). When you run the program, you specify a *class name*(~Welcome~) without a ~.java~ or ~.class~ extension
*** Using an Integrated Development Environment
*** JShell
** Fundamental Programming Structures in Java 31
*** A Simple Java Program
Java *is case sensitive*
if you made any mistakes in capitalization, the program will not run

The keyword ~public~ is called an *access modifier*
these modifiers control the level of access other parts of a program have to this code

everything in a Java program lives inside a class

you need to make the file name for the source code the same as the name of the *public class*, with the extension ~.java~ appended
**** name of the class
class names are nouns that start with an uppercase letter
Names must begin with a letter, and after that, they can have any combination of letters and digits
The length is essentially unlimited
You cannot use a Java reserved word(such as ~public~ or ~class~)
**** main method
According to the Java language Specification, the ~main~ method must be declared ~public~`
The Java Language Specification is the official document that describes the java language

~main~ method does not return an "exit code" to the os
If the ~main~ method exits normally, the java program has the exit code ~0~ indicating successful completion
To terminate the program with a different exit code, call ~System.exit(code)~.

*** Comments
- ~//~
- ~/*~, ~*/~
- ~/**~, ~*/~
  - this comment is used to generate documentation automatically
*** Data Types
Java is a *strongly typed language*
This means that every variable must have a declared type

There are eight *primitive types* in Java.
- Four of them are integer types
- Two are floating-point number types
- one is the character type used for UTF-16 code units in the Unicode encoding scheme
- one is for truth values

**** Integer Types
The integers types are for numbers without fractional parts
Negative values are allowed
Java does not have any ~unsigned~ versions of the ~int~, ~long~, ~short~, or ~byte~ types

| Type  | Storage Requirements | Range(Inclusive)                |
|-------+----------------------+---------------------------------|
| byte  | 1 byte               | -128 to 127                     |
| short | 2 bytes              | -32,768 to 32,767               |
| int   | 4 bytes              | -2,147,483,648 to 2,147,483,647 |
| long  | 8 bytes              | -                               |

The ~byte~ and ~short~ types are mainly intended for specialized applications, such as low-level file handling or for large arrays *when storage space is at a premium*

Under Java, the ranges of the integer types do not depend on the machine on which you will be running the Java code

Long integer numbers have a suffix ~L~ or ~l~
- e.g. ~4000000000L~
Hexadecimal numbers have a prefix ~0x~ or ~0X~
- e.g. ~0xCAFE~
Octal numbers have a prefix ~0~
- e.g. ~010~
numbers in binary with a prefix ~0b~, ~0B~
- e.g. ~0b1001~
You can add underscores to the number literals
- The Java compiler simply removes them
- e.g. ~1_000_000~

If you work with integer values that can never be negative and you really need an additional bit, you can, with some care, interpret signed integer values are unsigned
- Due to the nature of binary arithmetic, addition, subtraction, and multiplication will work provided they don't overlflow
- call ~Byte.toUnsignedInt(b)~ to get an ~int~ value between 0 and 255, then process the integer value and cast back to ~byte~

The ~Integer~ and ~Long~ classes have methods for unsigned division and remainder

**** Floating-Point Types
The limited precision of ~float~ (6-7 significant digits) is simply not sufficient for many situations
Use ~float~ values only when you work with a library that requires them, or when you need to store a very large number of them

Java 20 adds a couple of methods(~Float.floatToFloat16~ and ~Float.float16toFloat~) for storing "half-precision" 16-bit floating-point numbers in ~short~ values. These are used for *implementating neural networks*

Numbers of type ~float~ have a suffix ~F~, ~f~
Floating-point numbers without an ~F~ suffix are always considered to be of type ~double~

An ~E~ or ~e~ denotes a decimal exponent
- e.g. ~1.729E3~

You can specify floating-point literals in hexadecimal

All floating-point computations follow the IEEE-754 specification

There are three special floating-point values to denote *overflows and erros*
The constants ~Double.POSITIVE_INFINITY~, ~Double.NEGETIVE_INFINITY~, and ~Double.NaN~ represent these special values, but *they are rarely used in practive*
- Positive infinity
  - e.g. the result of dividing a positive floating-point number by 0 is positive infinity
- Negative infinity
- NaN(not a number)
  - e.g. Dividing 0.0 by 0 or the square root of a negative number yields NaN

Floating-point numbers are *not* suitable *for financial calculations* in which roundoff erros cannot be tolerated
- Such roundoff errors are caused by the fact that floating-point numbers are represented in the binary system
  - There is no precise binary representation of the fraction 1/10, just as there is no accurate representation of the fraction 1/3 in the decimal system
- if you need precise numerical computations without roundoff errors, use the ~BigDecimal~ class
**** The ~char~ Type
some Unicode characters can be decribed with *one* ~char~ value, and other Unicode characters require *two* ~char~ value

Literal values of type ~char~ are enclosed in single quotes
Values of type ~char~ can be expressed as hexadecimal values that run from `\u0000` to `\uFFFF`
The ~\u~ escape sequence(but none of the other escape sequences) can even be used *outside* quoted character constants and strings
Unicode escape sequences are processed before the code is parsed

You can have any number of ~u~ in a Unicode escape sequence

Escape Sequences for Special Characters
| Escape Sequence | Name                                                     |
|-----------------+----------------------------------------------------------|
| \b              | Backspace                                                |
| \t              | Tab                                                      |
| \n              | Line feed                                                |
| \r              | Carriage return                                          |
| \f              | Form feed                                                |
| \"              | Double quote                                             |
| \'              | Single quote                                             |
| \\              | Backslash                                                |
| \s              | Space. Used in text blocks to retain trailing whitespace |
| \newline        | In text blocks only: Join this line with the next        |
**** Unicode and the ~char~ Type
There were many different character encoding standards: ASCII, ISO 8859-1 ...
This caused two problems
- A particular code value corresponds to different letters in the different encoding schemes
- The encodings for languages with large character sets have variable length
~Unicode~ was designed to solve both problems: a fixed 2-byte code
~Java~ was designed from the ground up *to use 16-bit Unicode characters*
Now, the 16-bit ~char~ type is *insufficient* to decribe all Unicode characters

A *code point* is an integer value associated with a character in an encoding scheme
In the Unicode standard, code points are written in hexadecimal and prefixed with U+, such U+0041
A Unicode has code points that are grouped into 17 *code planes*, each holding 65536 characters

How a Unicode code point(that is, an integer ranging from 0 to hexadecimal 10FFF) is represented in bits depends on the *character encoding*
Java strings use the UTF-16 encoding
It encodes all Unicode code points in a variable-length code of 16-bit units, called *code units*
The characters in the basic multilingual plane are encoded as a single code unit.
All other characters are encoded as consecutive pairs of code units
Each of the code units in such an encoding pair falls into a range of 2048 unused values of the basic multilingual plane, called the *surrogates area*(`\uD800` to `\uDBFF` for the first code unit, `\uDC00` to `\uDFFF` for the second code unit)
you can immediately tell whether a code unit encodes a single character or it is the first or second part of supplementary character

Nowadays, Unicode has become so complex
with languages whose characters are made from smaller building blocks, with emojis that can have modifiers for gender and skine tone
**** The ~boolean~ Type
The ~boolean~ type has two values, ~false~ and ~true~

You cannot convert between integers and ~boolean~ values

*** Variables and Constants
Variable are used to store values
Constants are variables whose values don't change

**** Declaring Variables
In Java, every variable has a *type*

The semicolon is necessary because a declaration is a complete Java statement, which must end in a semicolon

The identifier for a variable name(as well as for other names) is made up of letters, digits, currency symbols, and "punctuation connectors"
The first character cannot be a digit

Even though ~$~ is a valid character in an identifier, you should not use it in your own code. It is intended for names that are generated by the Java compiler and other tools

You can declare multiple variables on a single line
If you declare each variable separately, your programs are easier to read
**** Initializing Variables
In Java, it is considered good style to declare variables as closely as possible to the point where they are first used
**** Constants
In Java, you use the keyword ~final~ to denote a constant

The keyword ~final~ indicates that you can assign to the variable once, and then its value is *set once and for all*
It is customary to name constants in all uppercase

class constants
**** Enumerated Types
Sometimes, a variable should only hold a restricted set of values
An enumerated type has a finite number of named values
A variable of type enum can hold only one of the values listed in the type declaration, or the special value ~null~ that indicates that the variable is not set to any value at all
*** Operators
**** Arithmetic Operators
~/~
integer divison If both operands are integers, and floating-point divison
Integer division by 0 raises an exception
whereas floating-point division by 0 yields an infinite or NaN result

When one of the operands of ~%~ is negative, so is the result
**** Mathematical Functions and Constants
The ~Math~ class contains an assortment of mathematical functions

The methods in the ~Math~ class use the routines in the computer's floating-point unit for fastest performance
If completely predictable results are more important than performance, use the ~StrictMath~ class instead

The ~Math~ class provides several methods to make integer arithmetic safer (not over,underflow)
**** Conversions between Numeric Types
conversions *without* information loss
- byte -> short
- short -> int
- char -> int
- int -> double
- int -> long
- float -> double

conversions *may* lose precision
- int -> float
- long -> float
- long -> double

conversion in a binary operator
- if either of the operands is ~double~, the other one will be converted to a ~double~
- if either of the operands is ~float~, the other one will be converted to a ~float~
- if either of the operands is ~long~, the other one will be converted to a ~long~
- if either of the operands is ~int~, the other one will be converted to a ~int~
**** Casts
Conversions in which loss of information is possible are done by means of *casts*

~long~ can only be assigned to an ~int~ with an explicit cast because there is the possibility of information loss

You cannot cast between ~boolean~ values and any numeric type
**** Assignment
If a compound assignment operator yields a value whose type is different from that of the left-hand side,
then it is *coerced* to fit with no warning

In Java, an assignment is an *expression*
Many programmers find such nested assignments confusing and prefer to write them more clearly
**** Increment and Decrement Operators
The prefix form does the addition first; the postfix form evaluates to the old value of the variable
Many programmers find this behavior confusing.
In Java, using ~++~ inside expression is uncommon
**** Relational and ~boolean~ Operators
**** The Conditional Operator
~?:~ operator that selects a value, depending on a Boolean expression
**** Switch Expressions
If you need to choose among more than two values, then you can use a ~switch~ expression, which was introduced in Java 14
The expression following the ~switch~ keyword is called the *selector expression* and its value is the *selector*
A ~case~ label must be a compile-time constant whose type matches the selector type
You can provide multiple labels for each ~case~, separated by commas

When you use the ~switch~ expression with enumerated constants, you need not supply the name of the enumeration in each label
- it is deduced from the ~switch~ value

It was legal to omit the ~default~ since there was a case for each possible value

When the selector is an ~enum~, and you don't have cases for all constants, you need a ~default~
A ~switch~ expression with an integer or ~String~ selector must always have a ~default~
If the selector is ~null~, a ~NullPointerException~ is thrown.
- If you want to avoid this possibility, add a ~case null~
**** Bitwise Operators
For any of the integer types, you have operators that can work directly with the bits that make up the integers
This means that you can use masking technique to get at individual bits in a number

The bitwise operators
~&~ ("and") ~|~("or") ~^~("xor") ~~~("not"
~>>~ ~<<~ operators which shift a bit pattern right of left
- These operators are convenient when you need *to build up bit patterns* to do bit masking
~>>>~ operator fills the top bits with zero, unlike ~>>~ which extends the sign bit into the top bits

When applied to ~boolean~ values, the ~&~, ~|~ operators yield a ~boolean~ value

The right-hand operand of the shift operators is reduced modulo32
(unless the left-hand operand is a ~long~, in which case the right-hand operand is reduced modulo 64)
- e.g. the value of ~1 << 35~ is the same as ~1 << 3~

The ~Integer~ class has a number of static methods for bit-level operations
**** Parentheses and Operator Hierarchy
If no parentheses are used, operations are performed in the hierarchical order indicated
Operators on the same level are processed from left to right, except for those that are right-associative

Java does not have a comma operator unlike C or C++

*** Strings
Conceptually, Java strings
**** Concatenation
Java allows you to use ~+~ to join(concatenate) two strings

When you concatenate a string with a value that is not a string, the latter is converted to a string

If you need to put multiple strings together, separated by a delimiter, use the static ~join~ method

The ~repeat~ method produces a string that repeats a given string a number of times

**** Spitting Strings
The ~split~ method splits a string into parts along a given boundary
It yields an array
The argument of the ~split~ method is a *regular expression*

| Pattern     | Description                                |
|-------------+--------------------------------------------|
| "\\s+"      | Whitespace                                 |
| "\\s*,\\s*" | Comma with optional whitespace             |
| "\\."       | Period                                     |
| \\PL+       | Any non-letters                            |
| "\\R"       | Line breaks                                |
| "\\b"       | Word boundaries                            |
| "\\b{g}"    | Grapheme cluster boundaries (since Java 9) |
Splitting along *grapheme cluster* boundaries breaks a string into what humans perceive as the constituent characters
**** Indexes and Substrings
Java strings are sequences of ~char~ values
The ~char~ data type is used for representing Unicode code points in the UTF-16 encoding

The ~length~ method yields the number of ~char~ values required for a given string

The call ~s.charAt(n)~ returns the ~char~ value at position ~n~, where ~n~ is between ~0~ and ~s.length() - 1~
These calls are not very useful

You sometimes need to know where a substring is located in a string
Use the ~indexOf~ method

Do not hard-code the length of a string
Always use the ~length~ method instead

You can extract a substring from a larger string with the ~substring~ method of the ~String~ class
#+begin_src java
String greeting = "Hello, World!";
int n = greeting.indexOf(",");
String s = greeting.substring(0, n);
#+end_src
The second argument of ~substring~ is the first position that you *do not* want to copy

**** Strings Are Immutable
The ~String~ class gives no methods that led you *change* a character in an existing string

Immutable strings have one great advantage: The compiler can arrange that strings are *shared*

The designers of Java decided that the efficiency of sharing outweighs the inefficiency of string creation
**** Testing Strings for Equality
To test whether two strings are equal, use the ~equals~ method

To test whether two strings are idential except for the upper/lowercase letter distinction, use the ~equalsIgnoreCase~ method

Do *not* use the ~==~ operator to test whether two strings are equal
It only determines whether or not the strings are stored in the same location
**** Empty and Null Strings
A ~String~ variable can also hold a special value, called ~null~, that indicates that no object is currently associated with the variable

To test whether a string is ~null~, use
#+begin_src java
if (str == null)
#+end_src
**** The ~String~ API
~java.lang.String~ 1.0
- ~char charAt(int index)~
  returns the code unit at the specified location. You probably don't want to call this method unless you are interested in low-level code units
- ~int length()~
  returns the number of code units of the string
- ~boolean equals(Object other)~
  returns ~true~ if the string equals ~other~
- ~boolean equalsIgnoreCase(String other)~
  return ~true~ if the string equals ~other~, except for upper/lowercase distinction
- ~int compareTo(String other)~
  returns a negative value if the string comes before ~other~ in dictionary order, positive value if the string comes after ~other~ in dictionary order, or ~0~ if the string are equal
- ~boolean isEmpty()~ 6
  ~boolean isBlank()~ 11
  return ~true~ if the string is empty or consists of whitespace
- ~boolean startsWith(String prfix)~
  ~boolean endsWith(String suffix)~
  return ~true~ if the string starts with ~prefix~ or ends with ~suffix~
- ~int indexOf(String str)~
  ~int indexOf(String str, int fromIndex)~
  ~int indexOf(String str, int fromIndex, int toIndex)~ 21
  return the start of the first substring equal to the string ~str~, starting at index ~0~ or at ~fromIndex~, and ending at the end of the string or at ~toIndex~. Return ~-1~ if ~str~ does not occur in this string or the specified substring
- ~int lastIndexOf(String str)~
  ~int lastIndexOf(String str, int fromIndex)~
  returns a new string that is obtained by replacing all substrings matching ~oldString~ in the string with the string ~newString~. You can supply ~String~ or ~StringBuilder~ arguments for the ~CharSequence~ parameters
- ~String substring(int beginIndex)~
  ~String substring(int beginIndex, int endIndex)~
  return a new string consisting of all code units from ~beginIndex~ until the end of the string or until ~endIndex~ - 1
- ~String toLowerCase()~
  ~String toUpperCase()~
  return a new string containing all characters in the original string, with uppercase characters converted to lowercase, or lowercase characters converted to uppercase
- ~String strip()~ 11
  ~String stripLeading()~ 11
  ~String stripTrailing()~ 11
  return a new string by eliminating leading and trailing, or just leading or trailing whitespace in the original string. Use these methods instead of the archaic ~trim~ method that eliminates characters <= U+0020
- ~String join(CharSequence delimiter, CharSequence... elements)~ 8
  returns a new string joining all elements with the given delimiter
- ~String repeat(int count)~ 11
  returns a string that repeats this string ~count~ times
- ~String[] split(String regex)~ 1.4
  finds all matches of the regular expression and split the string by removing them. Returns an array with the fragments, but not a trailing empty string
**** Building Strings
Every time you concatenate strings, a new ~String~ object is constructed.
This is time consuming and wastes memory.
Using the ~StringBuilder~ class avoids this problem

The ~String~ class doesn't have a method to reverse the Unicode characters of a string, but ~StringBuilder~ does.
To reverse a string, use this code snippet
#+begin_src java
String reversed = new StringBuilder(original).reverse().toString();
#+end_src
Reversing works correctly for characters that are encoded with two char values, but it does not take grapheme clusters into account.

The legacy ~StringBuffer~ class is less efficient
But it allows multiple threads to add or remove characters
If all string editing happens in a single thread(which is usually the case), you should use ~StringBuilder~
***** The ~StringBuilder~ API
~java.lang.StringBuilder~ 5.0
- ~StringBuilder()~
  ~StringBuilder(CharSequence seq)~
  constructs an empty string builder, or one with the given initial content
- ~int length()~
  returns the number of code units of the builder or buffer
- ~StringBuilder append(String str)~
  appends a string and returns the string builder
- ~StringBuilder appendCodePoint(int cp)~
  appends a code point, converting it into one or two code units, and returns ~this~
- ~StringBuilder insert(int offset, String str)~
  inserts a string at position ~offset~ and returns the string builder
- ~StringBuilder delete(int startIndex, int endIndex)~
  deletes code units with offsets ~startIndex~ to ~endIndex~ - 1 and returns the string builder
- ~StringBuilder repeat(CharSequence cs, int count)~ 21
  Appends ~count~ copies of ~cs~ and returns the string builder
- ~StringBuilder reverse()~
  Reverse the code points in this string builder and returns the builder
- ~String toString()~
  returns a string with the same data as the builder or buffer contents
**** Text Blocks
The text block feature, added in Java 15, makes it easy to provide string literals that span multiple lines
*** Input and Output
**** Reading Input
The ~Scanner~ class is not suitable for reading a password from a console since the input is plainly visible to anyone
Use ~readPassword~ method of the ~Console~ class to read a password while hiding the user input

For security reasons, the password is returned in an array of characters rather than a string
After you are done processing the password, you should immediately overwrite the array elements with a filler value

***** Scanner
~java.util.Scanner~ 5.0
- ~Scanner(InputStream in)~
  constructs a ~Scanner~ object from the given input stream
- ~String nextLine()~
  reads the next line of input
- ~String next()~
  reads the next word of input(delimited by whitespace)
- ~int nextInt()~
  ~double nextDouble()~
  read and convert the next character sequence that represents an integer or floating-point number
- ~boolean hasNext()~
  tests whether there is another word in the input
- ~boolean hasNextInt()~
  ~boolean hasNextDouble()~
  test whether the next character sequence represents an integer or floating-point number
~java.lang.System~ 1.0
- ~static Console console()~
~java.io.Console~ 6
- ~char[] readPassword(String prompt, Object... args)~
  ~String readLine(String prompt, Object... args)~
**** Formatting Output
Each of the *format specifiers* that start with a ~%~ character is replaced with the corresponding argument
The *conversion character* that ends a format specifier indicates the type of the value to be formatted

Table 3.6: Conversions for ~printf~

You can use the ~s~ conversion to format arbitrary objects
If an arbitrary object implements the ~Formattable~ interface, the object's ~formatTo~ method is invoked

You can specify *flags* that control the appearance of the formatted output
You can use multiple flags

Table 3.7: Flags for ~printf~

Figure 3.6: Format specifier syntax
[[../image/specifier_syntax.jpg]]

Formatting is *locale-specific*
If you produce a file that is later consumed by a computer program, you may need to choose a fixed locale for the output
**** File Input and Output
To read from a file, construct a ~Scanner~ object like this
If the file name contains backslashes, remember to escape each of them with an additional backslash

File store bytes, not Unicode characters
As of Java 18, UTF-8, this is the default encoding for all operations that read and write text
In older versions, the "default charset" of the computer running the Java program was used

To write to a file, construct a ~PrintWriter~ object
Prior to Java 18, you had to set the character encoding explicity to UTF-8

When you specify a relative file name, the file is located relative to the directory in which the jvm was started
If you run into grief with locating files, consider using absolute path names
***** ~Scanner~, ~PrintWriter~, ~Path~ API
~java.util.Scanner~ 5.0
- ~Scanner(Path p)~ 7
  ~Scanner(Path p, Charset charset)~ 10
  constructs a ~Scanner~ that reads data from the given path, using the default or given character encoding
- ~Scanner(String data)~
  constructs a ~Scanner~ that reads data from the given string

~java.io.PrintWriter~ 1.1
- ~PrintWriter(String fileName)~
  ~PrintWriter(String fileName, Charset charset)~ 10
  constructs a ~PrintWriter~ that writes data to the file with the given file name, using the default or given character encoding

~java.nio.file.Path~ 7
- ~static Path of(String pathname)~ 11
  constructs a ~Path~ from the given path name
*** Control Flow
Java supports both conditional statements and loops to determine control flow
**** Block Scope
A block,(sometimes called a *compound statement*) consists of a number of Java statements, surrounded by a pair of braces
Blocks define the scope of your variables
A Block can be *nested* inside another block
**** Conditional Statements
**** Loops
If you want to make sure a block is executed at least once, you need to move the test to the bottom, using the ~do/while~ loop
**** Determinate Loops
The *for* loop is a general construct to support iteration controlled by a *counter* or similar variable that is *updated after every iteration*

The first slot usually holds the counter initialization
The second slot gives the condition that will be tested *before* each new pass through the loop
The third slot specifies how to update the counter

When you declare a variable in the first slot of the *for* statement, the scope of that variable extends until the end of the body of the ~for~ loop
If you wish to use the final value of a loop counter *outside the for loop*, be sure to declare it outside the loop header.

The first slot of a for loop can declare multiple variables, provided they are of the same type. And the third slot can contain multiple comma-separated expressions:
#+begin_src java
for (int i = 1, j = 10; i <= 10; i++, j--) { ... }
#+end_src
**** Multiple Selections with ~switch~
Unlike a ~switch~ expression, a ~switch~ statement has no value. Each case carries out an action

In the fallthrough, each case ends with a *colon*
In the no-fallthrough, each case ends with *arrows*
You can't mix colons and arrows in a single *switch* statement

[*switch* expression]
Each branch must yield a value
- ~->~ value
- ~yield~ value (like break)
It is legal *to throw an exception* in a branch of *a switch expression*
The point of a *switch* expression is to produce a value(or to fail with an exception). You are not allowed to "jump out"
- You cannot use `return`, `break`, `continue` *statement* in a *switch expression*

Which one should you choose?
- Avoid the fallthrough forms
  - It is very *uncommon* to need fallthrough
- Prefer *switch* expressions over statements

***** Exprssion; No Fallthrough
#+begin_src java
int numLetters = switch (seasonName)
    {
        case "Spring" ->
                {
                    ...
                    yield 6;
                }
        case "Summer", "Winter" -> 6;
        default -> -1;
    }
#+end_src
***** Expression; Fallthrough
#+begin_src java
int numLetters = switch (seasonName)
    {
        case "Spring":
                ...
        case "Summer", "Winter":
                yield 6;
        default:
                yield -1;
    }
#+end_src
***** Statement; No Fallthrough
#+begin_src java
switch (seasonName)
    {
        case "Spring" ->
            {
                ...;
                numLetters = 6;
            }
        case "Summer", "Winter" -> numLetters = 6;
        default -> numLetters = -1;
    }
#+end_src
***** Statement; Fallthrough
#+begin_src java
switch (seasonName)
    {
        case "Spring":
            ...;
        case "Summer", "Winter":
            numLetters = 6;
            break;
        default:
            numLetters = -1;
    }
#+end_src
**** Statements That Break Control Flow
Although the designers of *Java kept goto as a reserved word*, they decided not to include it in the language.


***** *unlabeled break* statement
The *break* statement can also be used to break out of a loop.
***** *labeled break* statement
The labeled break statement lets you break out of multiple nested loops.

If there is a bad input, the labeled break moves *past the end of the labeled block*.
As with any use of the break statement, you then need to *test whether the loop exited normally or as a result of a break.*

You can apply a label to *any statement* like ~if~ statement, a block statement...

Note that you can only jump *out of* a block, never *into* a block
***** continue statement
The *continue* statement transfers control to the header of the innermost enclosing loop
If the ~continue~ statement is used in a ~for~ loop, it jumps to the "update" part of the ~for~ loop

There is also a labeled form of the *continue* statement that jumps to the *header* of the loop with the matching label
*** Big Numbers
If the precision of the basic integer and floating-point type is not sufficient, you can turn to the classes in the ~java.math~ package: ~BigInteger~ and ~BigDecimal~
- The BigInteger class implements arbitrary-precision integer arithmetic
- BigDecimal does the same for floating-point numbers.

Use the static ~valueOf~ method to turn an ordinary number into a big number
For longer numbers, use a constructor with a *string* argument

With the ~BigDecimal~ class, you should always use the constructor with a *string* argument
- There is a constructor ~BigDecimal(double)~ that is inherently prone to roundoff
  e.g. ~new BigDecimal(0.1)~

In Java 19, the BigInteger class provides a parallelMultiply method that yields the same result as multiply but can potentially compute the result faster by using multiple processor cores

~java.math.BigInteger~ 1.1
- ~BigInteger add(BigInteger other)~
  ~BigInteger subtract(BigInteger other)~
  ~BigInteger multiply(BigInteger other)~
  ~BigInteger divide(BigInteger other)~
  ~BigInteger mod(BigInteger other)~
  ~BigInteger pow(BigInteger other)~
  return the sum, difference, product, quotient, remainder, and power of this big integer and ~other~
- ~BigInteger sqrt()~ 9
- ~int compareTo(BigInteger other)~
- ~static BigInteger valueOf(long x)~
  returns a big integer whose value equals ~x~

~java.math.BigDecimal~ 1.1
- ~BigDecimal(String digits)~
- ~BigDecimal add(BigDecimal other)~
  ~BigDecimal subtract(BigDecimal other)~
  ~BigDecimal multiply(BigDecimal other)~
  ~BigDecimal divide(BigDecimal other)~ 5.0
  ~BigDecimal divide(BigDecimal other, RoundingMode mode)~ 5.0
  return the sum, difference, product, or quotient of this big decimal and ~other~.
  The first ~divide~ method throws an exception if the quotient does not have a finite decimal expansion
  To obtain a rounded result, use the second method
- ~int compareTo(BigInteger other)~
*** Arrays
Arrays hold sequences of values of the same type.
**** Declaring Arrays
#+begin_src java
int[] a;        // this statement only declares the variable *a*.
int[] a = new int[100]; // Use the *new* operator to create the array
#+end_src

The array length need not be a constant

Once you create an array, you cannot change its length

***** create and supply initial values
Java has a shortcut for *creating* an array object and supplying *initial values*:
- you do not use ~new~ with this syntax
- you don't specify the length
- A comma after the last value is allowed
#+begin_src java
int[] smallPrimes = { 2, 3, 5, 7, 11, 13 };
#+end_src
***** arrays of length 0
It is legal to have arrays of length 0
- Such an array can be useful if you write a method that computes an array result and the result happens to be empty
#+begin_src java
new type[0];
new type[0] {};
#+end_src
***** anonymous array
Declare an *anonymous array*
#+begin_src java
new int[] { 17, 19, 23, 29, 31, 37 }
#+end_src
**** Accessing Array Elements
When you create an array of *numbers*, all elements are initialized with *zero*
Arrays of *boolean* are initialized with *false*
Arrays of *objects* are initialized with the special value *null*, which indicates that they do not (yet) hold any objects.
**** print all values of array
There is an even easier way to print all values of an array, using the toString method of the Arrays class.
**** The "for each" loop
Java has a powerful looping construct that allows you to loop through each element in an array (or any other collection of elements)

The collection expression must be an
- array
- an object of a class that implements the Iterable interface,
**** Array Copying
If you actually want to copy all values of one array into a new array, use the *copyOf* method in the *Arrays* class
**** Command-Line Arguments
Unlike in C++, *the name of the program is not stored* in the array of command-line arguments.
**** Array Sorting
**** Arrays API
~java.util.Arrays~ 1.2
- ~static String toString(T[] a)~ 5.0
  returns a string with the elements of a, *enclosed in brackets* and *delimited by commas*. In this and the following methods, the component type T of the array can be ~int~, ~long~, ~short~, ~char~, ~byte~, ~boolean~, ~float~, or ~double~.
- ~static T[] copyOf(T[] a, int end)~ 6
  ~static T[] copyOfRange(T[] a, int start, int end)~ 6
  return an array of the same type as a, of length either ~end~ or ~end – start~, filled with the values of ~a~. If end is larger than a.length, the result is padded with ~0~ or ~false~ values.
- ~static void sort(T[] a)~
- ~static void fill(T[] a, T v)~
- ~static boolean equals(T[] a, T[] b)~
  returns ~true~ if the arrays have the same length and if the elements at corresponding indexes match
**** Multidimensional Arrays
**** Ragged Arrays
** Objects and Classes 127
*** Introduction to Object-Oriented Programming
An object-oriented program is made of objects.
Each object has a specific functionality, exposed to its users, and a hidden implementation

[[../image/ProceduralvsOO.jpg]]
**** structured programming vs object-oriented programming
***** structured programming
Traditional structured programming consists of designing a set of procedures(or *algorithms) to solve a problem
Once the procedures are determined, the traditional ~next step~ was to find appropriate ways *to store the data*

First, they dicided on the procedures for manipulating the data;
then, they decided what structure to impose on the data to make the manipulations easier
***** object-oriented programming
OOP reverses the order:
puts the data first, then looks at the algorithms to operate on the data
**** Classes
A *class* specifies how objects are made

instance fields
- The bits of data in an object

methods
- the procedures that operate on the data are called

object
- A specific object that is an instance of a class will have specific values of its instance fields

state
- The set of those values(its instance fields)
- Whenever you invoke a mehtod on an object, its state may change

inheritance
- When you extend an existing class, the new class has all the properties and methods of the class that you extend. You then supply new methods and instance fields that apply to your new class only

***** Encapsulation(information hiding)
- Formally, encapsulation is simply combining data and behavior in one package and hiding the implementation details from the users of the object
- The key to making encapsulation work is to have methods *never* directly access instance fields in a *class other than their own*.
  - Programs should interact with object data *only* through the object's methods
- Encapsulation is the way to give an object its "black box" behavior, which is the key to reuse and reliability
  - This means a class may totally change how it stores its data, but as long as it continues *to use the same methods* to manipulate the data, no other object will know or care.
- If an object's state changed *without* a method call on that object, someone broke encapsulation.
**** Objects
You should be able to identify three key characteristics of objects
- The object's *behavior* - what can you do with this object, or what methods can you apply to it
- The object's *state* - how does the object react when you invoke those methods?
- The object's *identity* - how is the object distinguished from others that may have the same behavior and state?
**** Identifying Classes
In a traditional procedural program, you start the process at the *top*, with the *main function*.

When designing an object-oriented system, there is no “top,” and newcomers to OOP often wonder where to begin.
The answer is:
- Identify your classes
- then add methods to each class.
**** Relationships between Classes
The most common relationships between classes are
***** Dependance ("uses-a")
- A class depends on another class if its methods use or manipulate objects of that class
- Try to minimize the number of classes that depend on each other
  - The point is, if a class ~A~ is unaware of the existence of a class ~B~, it is also unconcerned about any changes to ~B~
    (And this means that changes to ~B~ do not introduce bugs into ~A~)
  - In software engineering terminology, you want to minimize the *coupling* between classes
***** Aggregation ("has-a")
- Containment means that objects of class ~A~ contain objects of class ~B~
- Some methodologists view the concept of aggregation with disdain and prefer to use a more general “association” relationship.
***** Inheritance ("is-a")
***** UML(Unified Modeling Language)
Many programmers use the UML (Unified Modeling Language) notation to draw class diagrams that describe the *relationships between classes*.

You draw *classes as rectangles*, and *relationships as arrows* with various adornments

*** Using Predefined Classes
**** Objects and Object Variables
To work with objects, you first construct them and specify their initial state
Then you apply methods to the objects

It is important to realize that an object variable doesn’t actually contain an object.
It only *refers* to an object
***** built-in type vs class
With classes, the design task is *offloaded* to a library designer.
If the class is not perfect, other programmers can easily write their own classes to enhance or replace the system classes. 
***** constructor
In Java, you use *constructors* to construct new instances
A constructor is a special method whose purpose is to *construct* and *initialize* objects

Constructors always have the same name as the class name
**** The *LocalDate* class of the Java Library
An instance of the ~Date~ class has a state—namely, a *particular* point in time.
The time in ~Date~ is represented by the number of milliseconds(positive or negative) from a fixed point, the so-called *epoch*, which is 00:00:00 UTC, January 1,1970

the *Date* class is not very useful for manipulating the kind of calendar information that humans use for dates,

The library designers decided to separate the concerns of *keeping time* and *attaching names* to points in time.
- the ~Data~ class, which represents a point in time
- the ~LocalDate~ class, which express days in the familiar calendar notation
- Nowadays there is a much more robust set of classes for manipulating various aspects of date and time

***** UTC
UTC is the Coordinated Universal Time, the scientific time standard which is, for practical purpose, the same as the more familiar GMT, or Greenwich Mean Time
**** Mutator and Accessor Methods
*Accessor methods* that only access objects without modifying them
**** LocalDate API
~java.time.LocalDate~ 8
- ~static LocalDate now()~
  constructs an object that represents the current date
- ~static LocalDate of(int year, int month, int day)~
  constructs an object that represents the given date
- ~int getYear()~
  ~int getMonthValue()~
  ~int getDayOfMonth()~
  get the year, month, and day of this date
- ~DayOfWeek getDayOfWeek()~
  gets the weekday of this date as an instance of the ~DayOfWeek~ class.
  Call *getValue* on the DayOfWeek instance to get a weekday between ~1~ (Monday) and ~7~ (Sunday).
- ~LocalDate plusDays(int n)~
  ~LocalDate minusDays(int n)~

*** Defining Your Own Classes
**** An ~Employee~ Class
**** Use of Multiple Source Files
Many programmers prefer to put each class into its own source file.

**** Dissecting the ~Employee~ Class
when the Java compiler sees the Employee class being used inside EmployeeTest.java,
- it will look for a file named Employee.class.
  - If it does not find that file, it automatically searches for Employee.java and compiles it.
- Moreover, if the *timestamp of the version of Employee.java* that it finds is newer than that of the existing Employee.class file, the Java compiler will automatically recompile the file.
***** The ~private~ keyword
The private keyword makes sure that the only methods that *can access* these instance fields are *the methods of* the Employee class *itself*.
No outside method can read or write to these fields.
***** The ~public~ keyword
 The keyword public means that *any* method in *any* class can call the method
**** First Steps with Constructors
This constructor runs when you construct objects - giving the instance fields the *initial state* you want them to have
**** Declaring Local Variables with ~var~
~var~ keyword provides their type can be *inferred* from the *inital value*
**** Working with ~null~ References
An object variable holds
- a reference to an object, or
- the special value ~null~ to indicate the absence of an object

If you apply a method to a ~null~ value, a ~NullPointerException~ occurs

When you define a class, it is a good idea to be clear about which fields can be ~null~

Two solutions for handling ~null~
- The "permissive" approache is to turn a ~null~ argument into an appropriate *non-null* value
  - The ~Objects~ class has a convenience method: ~Objects.requireNonNullElse()~
- The "tough love" approach is to *reject* a ~null~ argument
  - The ~Objects~ class has a convenience method: ~Objects.requireNonNull()~
**** Implicit and Explicit Parameters
implicit argument
- The object of type that appears *before* the method name
- Every method has an *implicit parameter* whose name is the keyword ~this~, which is initialized with the implicit argument

explicit argument
- The arguments inside the parentheses after the method name
- (Some people call the implicit argument the *target* of *receiver* of the method call)
**** Benefits of Encapsulation
field accessors
- The methods return the values of instance fields

get and set the value
- A private instance field
- A public field accessor method
- A public field mutator method.

Be careful not to write accessor methods that *return* references to *mutable objects*.

Figure 4.5: Returning a reference to a mutable instance field
- *cloning* the mutable object before returning it.
- use immutable objects when possible
[[../image/mutableobject.jpg]]
**** Class-Based Access Privileges
A method can access the private data of *all objects of its class*

#+begin_src java
class Employee
{
   . . .
   public boolean equals(Employee other)
   {
      return name.equals(other.name);
   }
}
#+end_src
**** Private Methods
private methods are useful in certain circumstances
- You may wish to break up the code for a computation into separate *helper methods*.
  Typically, these helper methods should not be part of the public interface

The point is that as long as the method is private, the designers of the class can be assured that it is *never used* elsewhere, so they can simply *drop* it.

If a method is public, you *cannot* simply drop it because other code might rely on it.
**** Final Instance Fields
Such a field *must be initialized* when the object is constructed.
Afterwards, the field may not be modified again.

The final modifier is particularly useful for fields whose type is *primitive* or an *immutable class*.
- A class is immutable if *none of its methods* ever mutate its objects. For example, the String class is immutable.

For *mutable* classes, the final modifier can be *confusing*.
#+begin_src java
private final StringBuilder evaluations;
evaluations = new StringBuilder();

public void giveGoldStar()
{
   evaluations.append(LocalDate.now() + ": Gold star!\n");
}
#+end_src

A final field can be *null*:
*** Static Fields and Methods
**** Static Fields
A *field* as static, then the field is *not* present in the objects of the class.
You can think of static fields as belonging to the *class*, not to the individual objects.
Even if there are *no Employee objects*, the static field nextId is present.
It belongs to the *class*, not to any individual object.

There is only a single copy of each static field.

In some object-oriented programming languages, static fields are called *class fields*
**** Static Constants
Static variables are quite rare. However, static *constants* are more common.
**** Static Methods
Static methods are methods that do *not* operate on objects

You can think of static methods as methods that don’t have a *this* parameter.

A static method of class *cannot* access the instance field

I recommend that you use class names, not objects, to invoke static methods.

Use static methods in two situations:
- When a method *doesn’t* need to access the *object state* because all needed parameters are supplied as explicit parameters (e.g: Math.pow)
- When a method *only* needs to access static fields of the class
**** Factory Methods
Here is another common use for static methods
- use static factory methods that *construct* objects.

constructor vs factory methods
- When you use a constructor, You can’t give names to constructors.
- When you use a constructor, you can’t vary the type of the constructed object
- You may want to share instances
**** The ~main~ Method
**** Objects API
~java.util.Objects~ 7
- ~static <T> void requireNonNull(T obj)~
  ~static <T> void requireNonNull(T obj, String message)~
  ~static <T> void requireNonNull(T obj, Supplier<String> messageSupplier)~ 8
  If ~obj~ is ~null~, these methods throw a ~NullPointerException~ with no message or given message
- ~static <T> T requireNonNullElse(T obj, T defaultObj)~ 9
  ~static <T> T requireNonNullElseGet(T obj, Supplier<T> defaultSupplier)~ 9
  return ~obj~ if it is not null, or the ~default object~ if obj is null.

*** Method Parameters
This demonstrates that the Java programming language does *not* use call by reference for objects.
Instead, *object references are passed by value*

A summary of what you *can and cannot* do with method parameters in Java:
- A method cannot modify a parameter of a *primitive* type
- A method can change the *state* of an object parameter.
- A method cannot make an object parameter refer to a new object.

How parameters can be passed to method?

call by value
- The method gets just the value that the caller provides
call by reference
- The method gets the *location* of the variable that the caller provides
- A method can *modify* the value stored in a variable passed by reference

*** Object Construction
**** Explicit Field Initialization
#+begin_src java
class Employee
{
   private String name = "";
   . . .
}
#+end_src
This assignment is carried out before the constructor executes.
This syntax is particularly useful if all constructors of a class need to set a particular instance field to the *same value*

The initialization value doesn’t have to be a constant value.
**** Calling Another Constructor
If the first statement of a constructor has the form ~this(. . .)~, then the constructor calls another constructor of the same class.
**** Initialization Blocks
Class declarations can contain arbitrary blocks of code.
These blocks are executed whenever an object of that class is constructed

#+begin_src java
class Employee
{
   private static int nextId;

   private int id;
   private String name;
   private double salary;

   // object initialization block
   {
      id = nextId;
      nextId++;
   }

   public Employee(String n, double s)
   {
      name = n;
      salary = s;
   }

   public Employee()
   {
      name = "";
      salary = 0;
   }
   . . .
}
#+end_src
The initialization block runs first, and *then* the body of the constructor is executed.

This mechanism is *never* necessary and is not common.
It is usually more straightforward to place the initialization code *inside a constructor*.

***** Circular definitions
To avoid circular definitions, you should always place initialization blocks after the field definitions.
***** when a constructor is called
- All instance fields are initialized to their default values (0, false, or null).
- All field initializers and initialization blocks are executed, in the order in which they occur in the class declaration.
- The body of the constructor is executed.
***** static field
If the static fields of your class require *complex* initialization code, use a static *initialization block*.

*Like instance fields*, static fields are 0, false, or null unless you explicitly set them to another value.

All static field initializers and static initialization blocks are executed *in the order* in which they occur in the class declaration.
**** Random API
~java.util.random.RandomGenerator~ 17
- ~int nextInt(int n)~
  returns a random integer between 0 and ~n~ - 1
- ~static RandomGenerator of(String name)~
  yields a random generator for the given algorithm name.
- ~static RandomGenerator getDefault()~
  yields a strong random generator with 64 or more state bits.
~java.util.Random~ 1.0
- ~static from(RandomGenerator generator)~ 19
  returns a Random instance whose methods delegate to the given RandomGenerator.
**** Object Destruction and the ~finalize~ Method
Do *not* use the finalize method for cleanup
*** Records
**** The Record Concept
A record is a special form of a class whose state is *immutable* and *readable by the public*

The class(Record) has a constructor and accessor methods ([[*Mutator and Accessor Methods]]) and ~toString~, ~equals~ and ~hashCode~
can
- You can add your *own* methods to a record
- A record, like any class, can have *static fields and methods*
cannot
- You cannot add *instance fields* to a record
- If you intend record instances to be immutable, don't use *mutable types* for fields.

***** declaration
To declare a record, provide the name and the instance variables that hold the object state.

#+begin_src java
record Point(double x, double y) { }
#+end_src

In the Java language specification, the instance *fields* of a record are called *its components*.
***** Class vs Record
Use a *record* instead of a class for immutable data that is completely represented by a set of variables.
Use a *class* if the data is mutable, or if the representation may evolve over time.
**** Constructors: Canonical, Compact, and Custom
canonical constructor
- The automatically defined constructor that sets all instance fields

compact form
- To validate or normalize the parameters for the canonical constructor
- The body of the compact form is the “prelude” to the canonical constructor. It merely modifies *the parameter variables* from and to *before they are assigned* to the instance field

  #+begin_src java
record Range(int from, int to)
{
   public Range // Compact form, validating parameters
   {
      if (from > to) throw new IllegalArgumentException();
   }
}
  #+end_src

You can define additional *custom constructors*
The first statement of such a constructor must call another constructor, so that ultimately *the canonical constructor is invoked*

If the canonical constructor needs to do additional work, you can provide your own implementation.
But this is very *uncommon*
*** Packages
Java allows you to *group classes in a collection* called a package
**** Package Names
The main reason for using packages is to guarantee *the uniqueness of class names*

In fact, to absolutely guarantee a unique package name, use an *Internet domain name* (which is known to be unique) written in reverse.
You then use subpackages for different projects.

there is absolutely no relationship between nested packages
- Each is its own *independent* collection of classes.
  e.g. ~java.util~ and ~java.util.jar~ have nothing to do with each other.
**** Class Importation
A class can use
all classes *from its own package*
and *all **public** classes from other packages.*

The point of the import statement is to give you *a shorthand to refer* to the classes in the package
You can import a specific class or the whole package.
- e.g. *
- you can only use the * notation to import a *single package*.

Locating classes in packages is an activity of the *compiler*.
The bytecodes in class files always use full package names to refer to other classes.
***** name conflict
The only time that you need to pay attention to packages is when you have a *name conflict*.

You can solve this problem by adding a specific import statement:
**** Static Imports
A form of the ~import~ statement permits the importing of static methods and fields, not just classes.
**** Addition of a Class into a Package
To place classes inside a package, *put the name of the package at the top of your source file*, before the code that defines the classes in the package

If you don’t put a package statement in the source file, then the classes in that source file belong to the *unnamed package*.
The unnamed package has no package name

Place source files into a subdirectory that matches the full package name
- The *compiler places the class files* into the same directory structure.
- The *virtual machine* won’t find the classes if the packages don't match the directories.

In this situation, you still must compile and run classes from the *base* directory
**** Pacakge Access
~public~
- can be used by any class
~private~
- can be used only by the class that defines them
~default~
- can be used by all methods in the same *pacakge*
- e.g. the unamed package

You should use *modules* to encapsulate packages
**** The Class Path
The class path is the collection of all locations that can contain class files.
**** Setting the Class Path
It is best to specify the class path with the option -classpath
(or -cp or the more modern variant, --class-path)
- The entire command must be typed onto a single line. It is a good idea to place such a long command line into a shell script or a batch file.

The class path lists all directories and archive files that are *starting points* for locating classes.
*** JAR Files
When you package your application,
you want to give your users *a single file, not a directory structure* filled with class files. Java Archive (JAR) files were designed for this purpose

A JAR file can contain both class files and other file types such as image and sound files. Moreover, JAR files are compressed, using the familiar ZIP compression format.
**** The Manifest
Each JAR file contains a *manifest* file that describes special features of the archive.

The manifest file is called ~MANIFEST.MF~ and is located in a special *META-INF subdirectory* of the JAR file
**** Executable JAR Files
You can use the e option of the jar command to specify the *entry* point of your program
— the *class* that you would normally specify when invoking the java program launcher:
~jar cvfe MyProgram.jar com.mycompany.mypkg.MainAppClass files to add~
- Alternatively, you can specify the main class of your program in the manifest, including a statement of the form
  ~Main-Class: com.mycompany.mypkg.MainAppClass~

The public API of all classes should be the *same* for both releases.
- The sole purpose of multi-release JARs is to enable a particular version of your program or library to work with multiple JDK releases
**** Multi-Release JAR Files
*** Documentation Comments
Javadoc that generates HTML documentation from your source files.

If you add comments that start with the special delimiter ~/**~ to your source code, you too can easily produce professional-looking documentation
**** Comment Insertion
The javadoc utility extracts information for the following items
- Modules
- Packages
- Public classes and interfaces
- Public and protected fields
- Public and protected constructors and methods

The *first sentence* of the *free-form* text should be a *summary statement*.
- The javadoc utility automatically generates summary pages that extract these sentences.
***** tag
Each /** . . . */ documentation comment contains *free-form text* followed by tags.
- A tag starts with an @, such as @since or @param.
**** Class Comments
The class comment must be placed *after* any ~import~ statements, directly before the ~class~ definition.
**** Method Comments
Each method comment must immediately precede the method that it describes.

In addition to the general-purpose tags, you can use the following tags:
**** Field Comments
You only need to document public fields—generally that means static constants.
**** Package Comments
To generate package comments, you need to add a *separate file* in each package directory
- Supply a Java file named ~package-info.java~
- Supply an HTML file named ~package.html~
**** HTML Markup
To type monospaced code, use {@code . . . } instead of <code>. . .</code>
**** Links
You can use hyperlinks to other relevant parts of the javadoc documentation, or to external documents,
- with the ~@see~ and ~@link~ tags.
**** General Comments
- ~@since text~
- ~@author name~
- ~@version text~
**** Code Snippets
**** Comment Extraction
*** Class Design Hints
1. *Always keep data private.*
2. *Always initialize data.*
3. *Don’t use too many basic types in a class.*
4. *Not all fields need individual field accessors and mutators.*
5. *Break up classes that have too many responsibilities.*
6. *Make the names of your classes and methods reflect their responsibilities.*
7. *Prefer immutable classes.*
** Inheritance 217
*** Classes, Superclasses, and Subclasses
*** Object: The Cosmic Superclass
*** Generic Array Lists
*** Object Wrappers and Autoboxing
*** Methods with a Variable Number of Arguments
*** Abstract Classes
*** Enumeration Classes
*** Sealed Classes
*** Pattern Matching
*** Reflection
*** Desing Hints for Inheritance
** Interfaces, Lambda Expressions, and Inner Classes 327
*** Interfaces
*** Lambda Expressions
*** Inner Classes
*** Service Loaders
*** Proxies
** Exceptions, Assertions, and Logging 403
*** Dealing with Errors
*** Catching Exceptions
*** Tips for Using Exceptions
*** Using Assertions
*** Logging
*** Debugging Tips
** Generic Programming 459
*** Why Generic Programming
*** Defining a Simple Generic Class
*** Generic Methods
*** Bounds for Type Variables
*** Generic Code and the Virtual Machine
*** Inheritance Rules for Generic Types
*** Wildcard Types
*** Restrictions and Limitations
*** Reflection and Generics
** Collections 511
*** The Java Collections Framework
*** Interfaces in the Collections Framework
*** Concrete Collections
*** Maps
*** Copies and Views
*** Algorithms
*** Legacy Collections
** Concurrency 599
*** Running Threads
*** Thread States
*** Thread Properties
*** Coordinating Tasks
*** Synchronization
*** Thread-Safe Collections
*** Asynchronous Computations
*** Processes
** Annotations 711
*** Using Annotations
*** Defining Annotations
*** Annotations in the JAVA API
*** Processing Annotations at Runtime
*** Source-Level Annotation Processing
*** Bytecode Engineering
** The Java Platform Module System 747
*** The Module Concept
*** Naming Modules
*** The Modular "Hello, World!" Program
*** Requiring Modules
*** Exporting Packages
*** Modular JARs
*** Modules and Reflective Access
*** Automatic Modules
*** The Unnamed Module
*** Command-Line Flags for Migration
*** Transitive and Static Requirements
*** Qualified Exporting and Opening
*** Service Loading
*** Tools for Working with Modules
