#+title: Core Java 1

* core java
** About This eBook
** Preface
*** To the Reader
I assume that you don't like books filled with toy examples
My goal(writer) is to enable you to fully understand the Java language and library

This first volume concentrates **on the fundamental concepts** of the Java language
The second volume, *Core Java, Volume 2: Advanced Features*, goes further into the most import libraries

*** A Tour of This Book
*** Conventions
*** Sample Code
** Acknowledgments
** An Introduction to Java 1
*** Java as a Programming Platform
Java is a whole *platform*, with a huge library, containing lots of reusable code, and an execution environment that provides services such as security, portability across operating systems, and automatic garbage collection
*** The Java "White Paper" Buzzwords
**** simple
The syntax for Java is, indeed, a cleaned-up version of C++ syntax
**** object-oriented
**** distributed
**** robust
**** secure
**** architecture-neutral
**** portable
**** interpreted
**** high-performance
**** multithreaded
**** dynamic
*** Java Applets and the Internet
*** A Short History of Java
*** Common Misconceptions about Java
** The Java Programming Environment 15
how to install JDK
how to compile
how to run Java programs
*** Installing the Java Development Kit
**** Downloading the JDK
depending on the provider, the Java Development Kit may have a brand name, such as Temurin(Eclipse Foundation)

| Name                     | Acronym | Explanation                                                                                                                |
|--------------------------+---------+----------------------------------------------------------------------------------------------------------------------------|
| Java Development Kit     | JDK     | The software for programmers who want to write Java Programs                                                               |
| Java Runtime Environment | JRE     | Only supported unitl Java 8                                                                                                |
| Standard Edition         | SE      |                                                                                                                            |
| Micro Edition            | ME      |                                                                                                                            |
| OpenJDK                  | -       | A free and open source implementation of Java SE                                                                           |
| Hotspot                  | -       | The "just in time" compiler by Oracle                                                                                      |
| OpenJ9                   | -       | jit by IBM                                                                                                                 |
| GraalVM                  | -       | "ahead of time" compiler                                                                                                   |
| Long Term Support        | LTS     | A release that is supported for multiple years                                                                             |
| Eclipse                  | -       | A foundation that distributes open-source software                                                                         |
| Termurin                 | -       | The brand name for the OpenJDK version that the Eclipse foundation distributes                                             |
| Adoptium                 | -       | The project within the Eclipse Foundation that provides an OpenJDK version and infrastructure support for its distribution |
**** Setting Up the JDK

*** Using the Command-Line Tools
The compiler requires a *file name*(~Welcome.java~). When you run the program, you specify a *class name*(~Welcome~) without a ~.java~ or ~.class~ extension
*** Using an Integrated Development Environment
*** JShell
** Fundamental Programming Structures in Java 31
*** A Simple Java Program
Java *is case sensitive*
if you made any mistakes in capitalization, the program will not run

The keyword ~public~ is called an *access modifier*
these modifiers control the level of access other parts of a program have to this code

everything in a Java program lives inside a class

you need to make the file name for the source code the same as the name of the *public class*, with the extension ~.java~ appended
**** name of the class
class names are nouns that start with an uppercase letter
Names must begin with a letter, and after that, they can have any combination of letters and digits
The length is essentially unlimited
You cannot use a Java reserved word(such as ~public~ or ~class~)
**** main method
According to the Java language Specification, the ~main~ method must be declared ~public~`
The Java Language Specification is the official document that describes the java language

~main~ method does not return an "exit code" to the os
If the ~main~ method exits normally, the java program has the exit code ~0~ indicating successful completion
To terminate the program with a different exit code, call ~System.exit(code)~.

*** Comments
- ~//~
- ~/*~, ~*/~
- ~/**~, ~*/~
  - this comment is used to generate documentation automatically
*** Data Types
Java is a *strongly typed language*
This means that every variable must have a declared type

There are eight *primitive types* in Java.
- Four of them are integer types
- Two are floating-point number types
- one is the character type used for UTF-16 code units in the Unicode encoding scheme
- one is for truth values

**** Integer Types
The integers types are for numbers without fractional parts
Negative values are allowed
Java does not have any ~unsigned~ versions of the ~int~, ~long~, ~short~, or ~byte~ types

| Type  | Storage Requirements | Range(Inclusive)                |
|-------+----------------------+---------------------------------|
| byte  | 1 byte               | -128 to 127                     |
| short | 2 bytes              | -32,768 to 32,767               |
| int   | 4 bytes              | -2,147,483,648 to 2,147,483,647 |
| long  | 8 bytes              | -                               |

The ~byte~ and ~short~ types are mainly intended for specialized applications, such as low-level file handling or for large arrays *when storage space is at a premium*

Under Java, the ranges of the integer types do not depend on the machine on which you will be running the Java code

Long integer numbers have a suffix ~L~ or ~l~
- e.g. ~4000000000L~
Hexadecimal numbers have a prefix ~0x~ or ~0X~
- e.g. ~0xCAFE~
Octal numbers have a prefix ~0~
- e.g. ~010~
numbers in binary with a prefix ~0b~, ~0B~
- e.g. ~0b1001~
You can add underscores to the number literals
- The Java compiler simply removes them
- e.g. ~1_000_000~

If you work with integer values that can never be negative and you really need an additional bit, you can, with some care, interpret signed integer values are unsigned
- Due to the nature of binary arithmetic, addition, subtraction, and multiplication will work provided they don't overlflow
- call ~Byte.toUnsignedInt(b)~ to get an ~int~ value between 0 and 255, then process the integer value and cast back to ~byte~

The ~Integer~ and ~Long~ classes have methods for unsigned division and remainder

**** Floating-Point Types
The limited precision of ~float~ (6-7 significant digits) is simply not sufficient for many situations
Use ~float~ values only when you work with a library that requires them, or when you need to store a very large number of them

Java 20 adds a couple of methods(~Float.floatToFloat16~ and ~Float.float16toFloat~) for storing "half-precision" 16-bit floating-point numbers in ~short~ values. These are used for *implementating neural networks*

Numbers of type ~float~ have a suffix ~F~, ~f~
Floating-point numbers without an ~F~ suffix are always considered to be of type ~double~

An ~E~ or ~e~ denotes a decimal exponent
- e.g. ~1.729E3~

You can specify floating-point literals in hexadecimal

All floating-point computations follow the IEEE-754 specification

There are three special floating-point values to denote *overflows and erros*
The constants ~Double.POSITIVE_INFINITY~, ~Double.NEGETIVE_INFINITY~, and ~Double.NaN~ represent these special values, but *they are rarely used in practive*
- Positive infinity
  - e.g. the result of dividing a positive floating-point number by 0 is positive infinity
- Negative infinity
- NaN(not a number)
  - e.g. Dividing 0.0 by 0 or the square root of a negative number yields NaN

Floating-point numbers are *not* suitable *for financial calculations* in which roundoff erros cannot be tolerated
- Such roundoff errors are caused by the fact that floating-point numbers are represented in the binary system
  - There is no precise binary representation of the fraction 1/10, just as there is no accurate representation of the fraction 1/3 in the decimal system
- if you need precise numerical computations without roundoff errors, use the ~BigDecimal~ class
**** The ~char~ Type
some Unicode characters can be decribed with *one* ~char~ value, and other Unicode characters require *two* ~char~ value

Literal values of type ~char~ are enclosed in single quotes
Values of type ~char~ can be expressed as hexadecimal values that run from `\u0000` to `\uFFFF`
The ~\u~ escape sequence(but none of the other escape sequences) can even be used *outside* quoted character constants and strings
Unicode escape sequences are processed before the code is parsed

You can have any number of ~u~ in a Unicode escape sequence

Escape Sequences for Special Characters
| Escape Sequence | Name                                                     |
|-----------------+----------------------------------------------------------|
| \b              | Backspace                                                |
| \t              | Tab                                                      |
| \n              | Line feed                                                |
| \r              | Carriage return                                          |
| \f              | Form feed                                                |
| \"              | Double quote                                             |
| \'              | Single quote                                             |
| \\              | Backslash                                                |
| \s              | Space. Used in text blocks to retain trailing whitespace |
| \newline        | In text blocks only: Join this line with the next        |
**** Unicode and the ~char~ Type
There were many different character encoding standards: ASCII, ISO 8859-1 ...
This caused two problems
- A particular code value corresponds to different letters in the different encoding schemes
- The encodings for languages with large character sets have variable length
~Unicode~ was designed to solve both problems: a fixed 2-byte code
~Java~ was designed from the ground up *to use 16-bit Unicode characters*
Now, the 16-bit ~char~ type is *insufficient* to decribe all Unicode characters

A *code point* is an integer value associated with a character in an encoding scheme
In the Unicode standard, code points are written in hexadecimal and prefixed with U+, such U+0041
A Unicode has code points that are grouped into 17 *code planes*, each holding 65536 characters

How a Unicode code point(that is, an integer ranging from 0 to hexadecimal 10FFF) is represented in bits depends on the *character encoding*
Java strings use the UTF-16 encoding
It encodes all Unicode code points in a variable-length code of 16-bit units, called *code units*
The characters in the basic multilingual plane are encoded as a single code unit.
All other characters are encoded as consecutive pairs of code units
Each of the code units in such an encoding pair falls into a range of 2048 unused values of the basic multilingual plane, called the *surrogates area*(`\uD800` to `\uDBFF` for the first code unit, `\uDC00` to `\uDFFF` for the second code unit)
you can immediately tell whether a code unit encodes a single character or it is the first or second part of supplementary character

Nowadays, Unicode has become so complex
with languages whose characters are made from smaller building blocks, with emojis that can have modifiers for gender and skine tone
**** The ~boolean~ Type
The ~boolean~ type has two values, ~false~ and ~true~

You cannot convert between integers and ~boolean~ values

*** Variables and Constants
Variable are used to store values
Constants are variables whose values don't change

**** Declaring Variables
In Java, every variable has a *type*

The semicolon is necessary because a declaration is a complete Java statement, which must end in a semicolon

The identifier for a variable name(as well as for other names) is made up of letters, digits, currency symbols, and "punctuation connectors"
The first character cannot be a digit

Even though ~$~ is a valid character in an identifier, you should not use it in your own code. It is intended for names that are generated by the Java compiler and other tools

You can declare multiple variables on a single line
If you declare each variable separately, your programs are easier to read
**** Initializing Variables
In Java, it is considered good style to declare variables as closely as possible to the point where they are first used
**** Constants
In Java, you use the keyword ~final~ to denote a constant

The keyword ~final~ indicates that you can assign to the variable once, and then its value is *set once and for all*
It is customary to name constants in all uppercase

class constants
**** Enumerated Types
Sometimes, a variable should only hold a restricted set of values
An enumerated type has a finite number of named values
A variable of type enum can hold only one of the values listed in the type declaration, or the special value ~null~ that indicates that the variable is not set to any value at all
*** Operators
**** Arithmetic Operators
~/~
integer divison If both operands are integers, and floating-point divison
Integer division by 0 raises an exception
whereas floating-point division by 0 yields an infinite or NaN result

When one of the operands of ~%~ is negative, so is the result
**** Mathematical Functions and Constants
The ~Math~ class contains an assortment of mathematical functions

The methods in the ~Math~ class use the routines in the computer's floating-point unit for fastest performance
If completely predictable results are more important than performance, use the ~StrictMath~ class instead

The ~Math~ class provides several methods to make integer arithmetic safer (not over,underflow)
**** Conversions between Numeric Types
conversions *without* information loss
- byte -> short
- short -> int
- char -> int
- int -> double
- int -> long
- float -> double

conversions *may* lose precision
- int -> float
- long -> float
- long -> double

conversion in a binary operator
- if either of the operands is ~double~, the other one will be converted to a ~double~
- if either of the operands is ~float~, the other one will be converted to a ~float~
- if either of the operands is ~long~, the other one will be converted to a ~long~
- if either of the operands is ~int~, the other one will be converted to a ~int~
**** Casts
Conversions in which loss of information is possible are done by means of *casts*

~long~ can only be assigned to an ~int~ with an explicit cast because there is the possibility of information loss

You cannot cast between ~boolean~ values and any numeric type
**** Assignment
If a compound assignment operator yields a value whose type is different from that of the left-hand side,
then it is *coerced* to fit with no warning

In Java, an assignment is an *expression*
Many programmers find such nested assignments confusing and prefer to write them more clearly
**** Increment and Decrement Operators
The prefix form does the addition first; the postfix form evaluates to the old value of the variable
Many programmers find this behavior confusing.
In Java, using ~++~ inside expression is uncommon
**** Relational and ~boolean~ Operators
**** The Conditional Operator
~?:~ operator that selects a value, depending on a Boolean expression
**** Switch Expressions
If you need to choose among more than two values, then you can use a ~switch~ expression, which was introduced in Java 14
The expression following the ~switch~ keyword is called the *selector expression* and its value is the *selector*
A ~case~ label must be a compile-time constant whose type matches the selector type
You can provide multiple labels for each ~case~, separated by commas

When you use the ~switch~ expression with enumerated constants, you need not supply the name of the enumeration in each label
- it is deduced from the ~switch~ value

It was legal to omit the ~default~ since there was a case for each possible value

When the selector is an ~enum~, and you don't have cases for all constants, you need a ~default~
A ~switch~ expression with an integer or ~String~ selector must always have a ~default~
If the selector is ~null~, a ~NullPointerException~ is thrown.
- If you want to avoid this possibility, add a ~case null~
**** Bitwise Operators
For any of the integer types, you have operators that can work directly with the bits that make up the integers
This means that you can use masking technique to get at individual bits in a number

The bitwise operators
~&~ ("and") ~|~("or") ~^~("xor") ~~~("not"
~>>~ ~<<~ operators which shift a bit pattern right of left
- These operators are convenient when you need *to build up bit patterns* to do bit masking
~>>>~ operator fills the top bits with zero, unlike ~>>~ which extends the sign bit into the top bits

When applied to ~boolean~ values, the ~&~, ~|~ operators yield a ~boolean~ value

The right-hand operand of the shift operators is reduced modulo32
(unless the left-hand operand is a ~long~, in which case the right-hand operand is reduced modulo 64)
- e.g. the value of ~1 << 35~ is the same as ~1 << 3~

The ~Integer~ class has a number of static methods for bit-level operations
**** Parentheses and Operator Hierarchy
If no parentheses are used, operations are performed in the hierarchical order indicated
Operators on the same level are processed from left to right, except for those that are right-associative

Java does not have a comma operator unlike C or C++

*** Strings
Conceptually, Java strings
**** Concatenation
Java allows you to use ~+~ to join(concatenate) two strings

When you concatenate a string with a value that is not a string, the latter is converted to a string

If you need to put multiple strings together, separated by a delimiter, use the static ~join~ method

The ~repeat~ method produces a string that repeats a given string a number of times

**** Spitting Strings
The ~split~ method splits a string into parts along a given boundary
It yields an array
The argument of the ~split~ method is a *regular expression*

| Pattern     | Description                                |
|-------------+--------------------------------------------|
| "\\s+"      | Whitespace                                 |
| "\\s*,\\s*" | Comma with optional whitespace             |
| "\\."       | Period                                     |
| \\PL+       | Any non-letters                            |
| "\\R"       | Line breaks                                |
| "\\b"       | Word boundaries                            |
| "\\b{g}"    | Grapheme cluster boundaries (since Java 9) |
Splitting along *grapheme cluster* boundaries breaks a string into what humans perceive as the constituent characters
**** Indexes and Substrings
Java strings are sequences of ~char~ values
The ~char~ data type is used for representing Unicode code points in the UTF-16 encoding

The ~length~ method yields the number of ~char~ values required for a given string

The call ~s.charAt(n)~ returns the ~char~ value at position ~n~, where ~n~ is between ~0~ and ~s.length() - 1~
These calls are not very useful

You sometimes need to know where a substring is located in a string
Use the ~indexOf~ method

Do not hard-code the length of a string
Always use the ~length~ method instead

You can extract a substring from a larger string with the ~substring~ method of the ~String~ class
#+begin_src java
String greeting = "Hello, World!";
int n = greeting.indexOf(",");
String s = greeting.substring(0, n);
#+end_src
The second argument of ~substring~ is the first position that you *do not* want to copy

**** Strings Are Immutable
The ~String~ class gives no methods that led you *change* a character in an existing string

Immutable strings have one great advantage: The compiler can arrange that strings are *shared*

The designers of Java decided that the efficiency of sharing outweighs the inefficiency of string creation
**** Testing Strings for Equality
To test whether two strings are equal, use the ~equals~ method

To test whether two strings are idential except for the upper/lowercase letter distinction, use the ~equalsIgnoreCase~ method

Do *not* use the ~==~ operator to test whether two strings are equal
It only determines whether or not the strings are stored in the same location
**** Empty and Null Strings
A ~String~ variable can also hold a special value, called ~null~, that indicates that no object is currently associated with the variable

To test whether a string is ~null~, use
#+begin_src java
if (str == null)
#+end_src
**** The ~String~ API
~java.lang.String~ 1.0
- ~char charAt(int index)~
  returns the code unit at the specified location. You probably don't want to call this method unless you are interested in low-level code units
- ~int length()~
  returns the number of code units of the string
- ~boolean equals(Object other)~
  returns ~true~ if the string equals ~other~
- ~boolean equalsIgnoreCase(String other)~
  return ~true~ if the string equals ~other~, except for upper/lowercase distinction
- ~int compareTo(String other)~
  returns a negative value if the string comes before ~other~ in dictionary order, positive value if the string comes after ~other~ in dictionary order, or ~0~ if the string are equal
- ~boolean isEmpty()~ 6
  ~boolean isBlank()~ 11
  return ~true~ if the string is empty or consists of whitespace
- ~boolean startsWith(String prfix)~
  ~boolean endsWith(String suffix)~
  return ~true~ if the string starts with ~prefix~ or ends with ~suffix~
- ~int indexOf(String str)~
  ~int indexOf(String str, int fromIndex)~
  ~int indexOf(String str, int fromIndex, int toIndex)~ 21
  return the start of the first substring equal to the string ~str~, starting at index ~0~ or at ~fromIndex~, and ending at the end of the string or at ~toIndex~. Return ~-1~ if ~str~ does not occur in this string or the specified substring
- ~int lastIndexOf(String str)~
  ~int lastIndexOf(String str, int fromIndex)~
  returns a new string that is obtained by replacing all substrings matching ~oldString~ in the string with the string ~newString~. You can supply ~String~ or ~StringBuilder~ arguments for the ~CharSequence~ parameters
- ~String substring(int beginIndex)~
  ~String substring(int beginIndex, int endIndex)~
  return a new string consisting of all code units from ~beginIndex~ until the end of the string or until ~endIndex~ - 1
- ~String toLowerCase()~
  ~String toUpperCase()~
  return a new string containing all characters in the original string, with uppercase characters converted to lowercase, or lowercase characters converted to uppercase
- ~String strip()~ 11
  ~String stripLeading()~ 11
  ~String stripTrailing()~ 11
  return a new string by eliminating leading and trailing, or just leading or trailing whitespace in the original string. Use these methods instead of the archaic ~trim~ method that eliminates characters <= U+0020
- ~String join(CharSequence delimiter, CharSequence... elements)~ 8
  returns a new string joining all elements with the given delimiter
- ~String repeat(int count)~ 11
  returns a string that repeats this string ~count~ times
- ~String[] split(String regex)~ 1.4
  finds all matches of the regular expression and split the string by removing them. Returns an array with the fragments, but not a trailing empty string
**** Building Strings
Every time you concatenate strings, a new ~String~ object is constructed.
This is time consuming and wastes memory.
Using the ~StringBuilder~ class avoids this problem

The ~String~ class doesn't have a method to reverse the Unicode characters of a string, but ~StringBuilder~ does.
To reverse a string, use this code snippet
#+begin_src java
String reversed = new StringBuilder(original).reverse().toString();
#+end_src
Reversing works correctly for characters that are encoded with two char values, but it does not take grapheme clusters into account.

The legacy ~StringBuffer~ class is less efficient
But it allows multiple threads to add or remove characters
If all string editing happens in a single thread(which is usually the case), you should use ~StringBuilder~
***** The ~StringBuilder~ API
~java.lang.StringBuilder~ 5.0
- ~StringBuilder()~
  ~StringBuilder(CharSequence seq)~
  constructs an empty string builder, or one with the given initial content
- ~int length()~
  returns the number of code units of the builder or buffer
- ~StringBuilder append(String str)~
  appends a string and returns the string builder
- ~StringBuilder appendCodePoint(int cp)~
  appends a code point, converting it into one or two code units, and returns ~this~
- ~StringBuilder insert(int offset, String str)~
  inserts a string at position ~offset~ and returns the string builder
- ~StringBuilder delete(int startIndex, int endIndex)~
  deletes code units with offsets ~startIndex~ to ~endIndex~ - 1 and returns the string builder
- ~StringBuilder repeat(CharSequence cs, int count)~ 21
  Appends ~count~ copies of ~cs~ and returns the string builder
- ~StringBuilder reverse()~
  Reverse the code points in this string builder and returns the builder
- ~String toString()~
  returns a string with the same data as the builder or buffer contents
**** Text Blocks
The text block feature, added in Java 15, makes it easy to provide string literals that span multiple lines
*** Input and Output
**** Reading Input
The ~Scanner~ class is not suitable for reading a password from a console since the input is plainly visible to anyone
Use ~readPassword~ method of the ~Console~ class to read a password while hiding the user input

For security reasons, the password is returned in an array of characters rather than a string
After you are done processing the password, you should immediately overwrite the array elements with a filler value

***** Scanner
~java.util.Scanner~ 5.0
- ~Scanner(InputStream in)~
  constructs a ~Scanner~ object from the given input stream
- ~String nextLine()~
  reads the next line of input
- ~String next()~
  reads the next word of input(delimited by whitespace)
- ~int nextInt()~
  ~double nextDouble()~
  read and convert the next character sequence that represents an integer or floating-point number
- ~boolean hasNext()~
  tests whether there is another word in the input
- ~boolean hasNextInt()~
  ~boolean hasNextDouble()~
  test whether the next character sequence represents an integer or floating-point number
~java.lang.System~ 1.0
- ~static Console console()~
~java.io.Console~ 6
- ~char[] readPassword(String prompt, Object... args)~
  ~String readLine(String prompt, Object... args)~
**** Formatting Output
Each of the *format specifiers* that start with a ~%~ character is replaced with the corresponding argument
The *conversion character* that ends a format specifier indicates the type of the value to be formatted

Table 3.6: Conversions for ~printf~

You can use the ~s~ conversion to format arbitrary objects
If an arbitrary object implements the ~Formattable~ interface, the object's ~formatTo~ method is invoked

You can specify *flags* that control the appearance of the formatted output
You can use multiple flags

Table 3.7: Flags for ~printf~

Figure 3.6: Format specifier syntax
[[../image/specifier_syntax.jpg]]

Formatting is *locale-specific*
If you produce a file that is later consumed by a computer program, you may need to choose a fixed locale for the output
**** File Input and Output
To read from a file, construct a ~Scanner~ object like this
If the file name contains backslashes, remember to escape each of them with an additional backslash

File store bytes, not Unicode characters
As of Java 18, UTF-8, this is the default encoding for all operations that read and write text
In older versions, the "default charset" of the computer running the Java program was used

To write to a file, construct a ~PrintWriter~ object
Prior to Java 18, you had to set the character encoding explicity to UTF-8

When you specify a relative file name, the file is located relative to the directory in which the jvm was started
If you run into grief with locating files, consider using absolute path names
***** ~Scanner~, ~PrintWriter~, ~Path~ API
~java.util.Scanner~ 5.0
- ~Scanner(Path p)~ 7
  ~Scanner(Path p, Charset charset)~ 10
  constructs a ~Scanner~ that reads data from the given path, using the default or given character encoding
- ~Scanner(String data)~
  constructs a ~Scanner~ that reads data from the given string

~java.io.PrintWriter~ 1.1
- ~PrintWriter(String fileName)~
  ~PrintWriter(String fileName, Charset charset)~ 10
  constructs a ~PrintWriter~ that writes data to the file with the given file name, using the default or given character encoding

~java.nio.file.Path~ 7
- ~static Path of(String pathname)~ 11
  constructs a ~Path~ from the given path name
*** Control Flow
Java supports both conditional statements and loops to determine control flow
**** Block Scope
A block,(sometimes called a *compound statement*) consists of a number of Java statements, surrounded by a pair of braces
Blocks define the scope of your variables
A Block can be *nested* inside another block
**** Conditional Statements
**** Loops
If you want to make sure a block is executed at least once, you need to move the test to the bottom, using the ~do/while~ loop
**** Determinate Loops
The *for* loop is a general construct to support iteration controlled by a *counter* or similar variable that is *updated after every iteration*

The first slot usually holds the counter initialization
The second slot gives the condition that will be tested *before* each new pass through the loop
The third slot specifies how to update the counter

When you declare a variable in the first slot of the *for* statement, the scope of that variable extends until the end of the body of the ~for~ loop
If you wish to use the final value of a loop counter *outside the for loop*, be sure to declare it outside the loop header.

The first slot of a for loop can declare multiple variables, provided they are of the same type. And the third slot can contain multiple comma-separated expressions:
#+begin_src java
for (int i = 1, j = 10; i <= 10; i++, j--) { ... }
#+end_src
**** Multiple Selections with ~switch~
Unlike a ~switch~ expression, a ~switch~ statement has no value. Each case carries out an action

In the fallthrough, each case ends with a *colon*
In the no-fallthrough, each case ends with *arrows*
You can't mix colons and arrows in a single *switch* statement

[*switch* expression]
Each branch must yield a value
- ~->~ value
- ~yield~ value (like break)
It is legal *to throw an exception* in a branch of *a switch expression*
The point of a *switch* expression is to produce a value(or to fail with an exception). You are not allowed to "jump out"
- You cannot use `return`, `break`, `continue` *statement* in a *switch expression*

Which one should you choose?
- Avoid the fallthrough forms
  - It is very *uncommon* to need fallthrough
- Prefer *switch* expressions over statements

***** Exprssion; No Fallthrough
#+begin_src java
int numLetters = switch (seasonName)
    {
        case "Spring" ->
                {
                    ...
                    yield 6;
                }
        case "Summer", "Winter" -> 6;
        default -> -1;
    }
#+end_src
***** Expression; Fallthrough
#+begin_src java
int numLetters = switch (seasonName)
    {
        case "Spring":
                ...
        case "Summer", "Winter":
                yield 6;
        default:
                yield -1;
    }
#+end_src
***** Statement; No Fallthrough
#+begin_src java
switch (seasonName)
    {
        case "Spring" ->
            {
                ...;
                numLetters = 6;
            }
        case "Summer", "Winter" -> numLetters = 6;
        default -> numLetters = -1;
    }
#+end_src
***** Statement; Fallthrough
#+begin_src java
switch (seasonName)
    {
        case "Spring":
            ...;
        case "Summer", "Winter":
            numLetters = 6;
            break;
        default:
            numLetters = -1;
    }
#+end_src
**** Statements That Break Control Flow
Although the designers of *Java kept goto as a reserved word*, they decided not to include it in the language.


***** *unlabeled break* statement
The *break* statement can also be used to break out of a loop.
***** *labeled break* statement
The labeled break statement lets you break out of multiple nested loops.

If there is a bad input, the labeled break moves *past the end of the labeled block*.
As with any use of the break statement, you then need to *test whether the loop exited normally or as a result of a break.*

You can apply a label to *any statement* like ~if~ statement, a block statement...

Note that you can only jump *out of* a block, never *into* a block
***** continue statement
The *continue* statement transfers control to the header of the innermost enclosing loop
If the ~continue~ statement is used in a ~for~ loop, it jumps to the "update" part of the ~for~ loop

There is also a labeled form of the *continue* statement that jumps to the *header* of the loop with the matching label
*** Big Numbers
If the precision of the basic integer and floating-point type is not sufficient, you can turn to the classes in the ~java.math~ package: ~BigInteger~ and ~BigDecimal~
- The BigInteger class implements arbitrary-precision integer arithmetic
- BigDecimal does the same for floating-point numbers.

Use the static ~valueOf~ method to turn an ordinary number into a big number
For longer numbers, use a constructor with a *string* argument

With the ~BigDecimal~ class, you should always use the constructor with a *string* argument
- There is a constructor ~BigDecimal(double)~ that is inherently prone to roundoff
  e.g. ~new BigDecimal(0.1)~

In Java 19, the BigInteger class provides a parallelMultiply method that yields the same result as multiply but can potentially compute the result faster by using multiple processor cores

~java.math.BigInteger~ 1.1
- ~BigInteger add(BigInteger other)~
  ~BigInteger subtract(BigInteger other)~
  ~BigInteger multiply(BigInteger other)~
  ~BigInteger divide(BigInteger other)~
  ~BigInteger mod(BigInteger other)~
  ~BigInteger pow(BigInteger other)~
  return the sum, difference, product, quotient, remainder, and power of this big integer and ~other~
- ~BigInteger sqrt()~ 9
- ~int compareTo(BigInteger other)~
- ~static BigInteger valueOf(long x)~
  returns a big integer whose value equals ~x~

~java.math.BigDecimal~ 1.1
- ~BigDecimal(String digits)~
- ~BigDecimal add(BigDecimal other)~
  ~BigDecimal subtract(BigDecimal other)~
  ~BigDecimal multiply(BigDecimal other)~
  ~BigDecimal divide(BigDecimal other)~ 5.0
  ~BigDecimal divide(BigDecimal other, RoundingMode mode)~ 5.0
  return the sum, difference, product, or quotient of this big decimal and ~other~.
  The first ~divide~ method throws an exception if the quotient does not have a finite decimal expansion
  To obtain a rounded result, use the second method
- ~int compareTo(BigInteger other)~
*** Arrays
Arrays hold sequences of values of the same type.
**** Declaring Arrays
#+begin_src java
int[] a;        // this statement only declares the variable *a*.
int[] a = new int[100]; // Use the *new* operator to create the array
#+end_src

The array length need not be a constant

Once you create an array, you cannot change its length

***** create and supply initial values
Java has a shortcut for *creating* an array object and supplying *initial values*:
- you do not use ~new~ with this syntax
- you don't specify the length
- A comma after the last value is allowed
#+begin_src java
int[] smallPrimes = { 2, 3, 5, 7, 11, 13 };
#+end_src
***** arrays of length 0
It is legal to have arrays of length 0
- Such an array can be useful if you write a method that computes an array result and the result happens to be empty
#+begin_src java
new type[0];
new type[0] {};
#+end_src
***** anonymous array
Declare an *anonymous array*
#+begin_src java
new int[] { 17, 19, 23, 29, 31, 37 }
#+end_src
**** Accessing Array Elements
When you create an array of *numbers*, all elements are initialized with *zero*
Arrays of *boolean* are initialized with *false*
Arrays of *objects* are initialized with the special value *null*, which indicates that they do not (yet) hold any objects.
**** print all values of array
There is an even easier way to print all values of an array, using the toString method of the Arrays class.
**** The "for each" loop
Java has a powerful looping construct that allows you to loop through each element in an array (or any other collection of elements)

The collection expression must be an
- array
- an object of a class that implements the Iterable interface,

** Objects and Classes 127
*** Introduction to Object-Oriented Programming
*** Using Predefined Classes
*** Defining Your Own Classes
*** Static Fields and Methods
*** Method Parameters
*** Object Construction
*** Records
*** Packages
*** JAR Files
*** Documentation Comments
*** Class Design Hints
** Inheritance 217
*** Classes, Superclasses, and Subclasses
*** Object: The Cosmic Superclass
*** Generic Array Lists
*** Object Wrappers and Autoboxing
*** Methods with a Variable Number of Arguments
*** Abstract Classes
*** Enumeration Classes
*** Sealed Classes
*** Pattern Matching
*** Reflection
*** Desing Hints for Inheritance
** Interfaces, Lambda Expressions, and Inner Classes 327
*** Interfaces
*** Lambda Expressions
*** Inner Classes
*** Service Loaders
*** Proxies
** Exceptions, Assertions, and Logging 403
*** Dealing with Errors
*** Catching Exceptions
*** Tips for Using Exceptions
*** Using Assertions
*** Logging
*** Debugging Tips
** Generic Programming 459
*** Why Generic Programming
*** Defining a Simple Generic Class
*** Generic Methods
*** Bounds for Type Variables
*** Generic Code and the Virtual Machine
*** Inheritance Rules for Generic Types
*** Wildcard Types
*** Restrictions and Limitations
*** Reflection and Generics
** Collections 511
*** The Java Collections Framework
*** Interfaces in the Collections Framework
*** Concrete Collections
*** Maps
*** Copies and Views
*** Algorithms
*** Legacy Collections
** Concurrency 599
*** Running Threads
*** Thread States
*** Thread Properties
*** Coordinating Tasks
*** Synchronization
*** Thread-Safe Collections
*** Asynchronous Computations
*** Processes
** Annotations 711
*** Using Annotations
*** Defining Annotations
*** Annotations in the JAVA API
*** Processing Annotations at Runtime
*** Source-Level Annotation Processing
*** Bytecode Engineering
** The Java Platform Module System 747
*** The Module Concept
*** Naming Modules
*** The Modular "Hello, World!" Program
*** Requiring Modules
*** Exporting Packages
*** Modular JARs
*** Modules and Reflective Access
*** Automatic Modules
*** The Unnamed Module
*** Command-Line Flags for Migration
*** Transitive and Static Requirements
*** Qualified Exporting and Opening
*** Service Loading
*** Tools for Working with Modules
