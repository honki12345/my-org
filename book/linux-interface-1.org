* 기초 리눅스 API
** 1장 역사와 표준
*** 유닉스와 C의 간략한 역사
*** 리눅스의 간략한 역사
**** GNU 프로젝트
**** 리눅스 커널
*** 표준화
**** C 프로그래밍 언어
**** 최초의 POSIX 표준
**** X/Open Company와 오픈그룹
**** SUSv3와 POSIX.1-2001
**** SUSv4와 POSIX.1-2008
**** 유닉스 표준 연대표
**** 구현표준
**** 리눅스, 표준, 리눅스 스탠더드 베이스
*** 정리
** 2장 기본개념
*** 핵심 운영체제: 커널
*** 셸
*** 사용자와 그룹
*** 단일 디렉토리 계층구조, 디렉토리, 링크, 파일
*** 파일 I/O 모델
*** 프로그램
*** 프로세스
[ 프로그램이 실행될 때 ]
커널이 프로그램 코드를 가상 메모리에 올리고,
프로그램 변수 공간을 할당하고,
프로세스에 대한 여러 정보(프로세스 ID, 종료 상태, 사용자 ID, 그룹 ID 등)을 기록하기 위한 커널 내 데이터 구조를 준비한다

[ 프로세스 메모리 배치 ]
프로세스는 논리적으로 다음과 같은 세그먼트로 나뉜다
- 텍스트: 프로그램 명령
- 데이터: 프로그램이 사용하는 정적 변수
- 힙: 프로그램이 실행 중에 추가로 메모리를 할당할 수 있는 영역
- 스택: 함수가 호출되고 리턴됨에 따라 자라고 줄어드는 메모리 영역으로, 지역변수와 함수호출 연결정보가 저장된다
*** 메모리 매핑
*** 정적 라이브러리와 공유 라이브러리
*** 프로세스 간 통신과 동기화
*** 시그널
*** 스레드
*** 프로세스 그룹과 셸 작업 제어
*** 세션, 제어 터미널, 제어 프로세스
*** 가상 터미널
*** 날짜와 시간
*** 클라이언트/서버 아키텍처
*** 실시간
*** /proc 파일 시스템
*** 정리
** 3장 시스템 프로그래밍 개념
*** 시스템 호출
*** 라이브러리 함수
*** 표준 C 라이브러리: GNU C 라이브러리(glib)
*** 시스템 호출과 라이브러리 함수의 에러 처리                   :minishell:
시스템 호출이 실패하면 전역 정수 변수 'errno'를 특정 에러를 나타내는 양수로 설정한다.
헤더 파일 '<errno.h>을 사용하면 'errno' 선언 뿐만 아니라 다양한 에러 상수도 포함된다.
각 메뉴얼 'ERROS' 세션에는 각 시스템 호출이 리턴할 수 있는 'errno' 값의 목록이 나와 있다.

에러를 확인할 때는 언제나 함수의 리턴 값이 에러를 나타내는지를 확인하고, 그 경우에만 'errno'을 통해 에러의 원인을 찾아야 한다.
또는 호출 전에 'errno'을 0으로 설정하고, 호출 후에 다시 확인한다
**** perror()
#+begin_src C
  #include <stdio.h>

  void perror(const char *msg);
#+end_src

The 'perror()' function produces a message on standard error describing the last error encountered during a call to system or library function.
First (if 's' is not NULL and *s is not a null byte ('\0')),
the argument string 's' is printed, followed by a colon and a blank.
Then an error message corresponding to the current value of 'errno' and a new-line.
**** strerror()
#+begin_src C
  #include <string.h>

  char *strerror(int errnum);
#+end_src
'strerror()' 함수는 인자 'errnum'으로 주어진 에러 번호에 해당하는 에러 문자열을 리턴한다.
'strerror()'가 리턴한 문자열은 정적으로 할당되어 있을 수 있으므로, 이후의'strerror()'에 의해 다른 값으로 바뀔 수 있다.
'errnum'이 알 수 없는 에러 번호를 담고 있으면, 'strerror()'는 'Unknown error nnn'이라는 형태의 문자열을 리턴한다.
어떤 구현에서는 이런 경우 'strerror()'가 NULL을 리턴하기도 한다
*** 이 책의 예제 프로그램
**** 명령행 옵션과 인자
**** 공통 함수와 헤더 파일
*** 이식성 이슈
**** 기능 테스트 매크로
**** 시스템 데이터형
**** 기타 이식성 이슈
*** 정리
** 4장 파일 I/O: 범용 I/O 모델
*** 개요
I/O를 수행하는 모든 시스템 호출은 파일 디스크립터라는 음이 아닌 정수를 통해 열려 있는 파일을 참조한다.
파일 디스크립터는 파이프, FIFO, 소켓, 터미널, 디바이스, 일반 파일 등 종류에 상관없이 모든 열려 있는 파일을 참조할 때 쓴다
셸은 보통 세가지 파일 디스크립터가 언제나 열려 있는 채로 동작한다 (대화형 셸에서 이 세가지 파일 디스크립터는 셸이 동작중인 터미널을 가리킨다)
프로그램은 셸의 디스크립터의 복사본을 물려 받는다
명령행에서 I/O을 재지정하면 셸은 프로그램을 시작하기 전에 파일 디스크립터가 적절히 수정되도록 보장한다.

**** 파일 I/O을 수행하는 네가지 핵심 시스템 호출
***** `fd = open(pathname, flags, mode)`
`pathname`이 가리키는 파일을 열고, 열린 파일을 이후의 호출에서 참조할 때 쓸 파일 디스크립터를 리턴한다.
해당 파일이 존재하면 `flags`의 값에 따라 `open()`이 만들 수도 있다.
`flags`는 또한 파일을 읽기, 쓰기, 둘 다를 위해 열지를 지정한다.
`mode`는 파일을 만들 경우 파일에 부여할 권한을 지정한다.
`open()`는 파일을 만들지 않을 경우, 이 인자는 무시되므로 생략할 수 있다.
***** `numread = read(fd, buffer, count)`
`fd`가 가리키는 파일에서 최대 `count` 바이트를 읽어 `buffer`에 저장한다.
`read()`는 실제로 읽은 바이트 수를 리턴한다.
더 이상 읽을 수 없으면 (즉, 파일의 끝을 만나면) `read()`는 0을 리턴한다.
***** `numwritten = write(fd, buffer, count)`
`buffer`에서 최대 `count` 바이트를 `fd`가 열려 있는 파일에 쓴다.
`write()`는 실제로 쓴 바이트 수를 리턴하므로, `count`보다 작은 수를 리턴할 수 있다
***** `status = close(fd)`
모든 I/O를 마친 뒤에 파일 디스크립터 `fd`와 관련 커널 자원을 해제하기 위해 호출한다
*** I/O의 범용성
네가지 시스템 호출(`open(), read(), write(), close()`)이 터미널 같은 디바이스를 포함해 모든 종류의 파일에 대한 I/O를 수행한다.
따라서 이 시스템 호출만으로 프로그램을 작성하면, 어떤 종류의 파일에 대해서도 동작할 것이다.
이러한 I/O의 범용성은 각 파일 시스템과 드라이버가 같은 종류의 I/O 시스템 호출을 구현함으로써 가능해졌다.
파일 시스템이나 디바이스 특유의 기능을 써야할 때는 다목적 시스템 호출인 `ioctl()`를 사용할 수 있다.
*** 파일 열기: open()                                           :minishell:
#+begin_src C
  #include <sys/stat.h>
  #include <fcntl.h>

  // flags는 파일 접근모드, mode는 파일 권한(새로운 파일 만들 때)
  int open(const char *pathname, int flags, ... /* mode_t mode */);
#+end_src
 `open()` 시스템 호출은 기존 파일을 열거나 새로운 파일을 만들고 연다.
`pathname`이 가리키는 파일을 연다. `pathname`이 심볼릭 링크면 역참조한다.
성공하면 `open()`은 파일 디스크립터를 리턴하며, 이후의 시스템 호출에서는 이 파일 디스크립터를 통해 해당 파일을 참조할 수 있다.
에러가 발생하면 `open()`은 -1을 리턴하고 그에 맞춰 `errno`가 설정된다.
 `flags` 인자는 *파일 접근모드*를 지정하는 비스마스크다.
 `open()`으로 새로운 파일을 만들 때는 `mode` 비트 마스크 인자로 *파일 권한*을 설정한다.
`open()` 호출에 `O_CREAT`를 지정하지 않으면 `mode`는 생략해도 된다.
새로 만들어진 파일에 실제로 설정되는 권한은 mode 인자뿐만 아니라 프로세스의 'unmask'와 (선태적으로 존재하는) 부모 디렉토리의 기본 접근 제어 목록에 따라서도 달라진다
**** open()의 flags 인자
**** open()의 에러
**** creat() 시스템 호출
*** 파일 읽기: read()
*** 파일에 쓰기: write()                                        :minishell:
#+begin_src C
  #include <unistd.h>

  ssize_t write(int fd, void *buffer, size_t count);
#+end_src
write() 시스템 호출은 열려있는 파일에 데이터를 쓴다.
**** write의 인자와 리턴값
'buffer'는 쓸 데이터의 주소이고, 'count'는 'buffer'에서 읽어와 쓸 바이트 수이고, 'fd'는 데이터를 쓸 파일을 가리키는 파일 디스크립터이다.
성공하면 write()는 실제로 쓴 바이트 수를 리턴하는데 이는 'count'보다 작을 수 있다.
디스크 파일의 경우, 이는 디스크가 가득 찼거나, 파일 크기에 대한 프로세스 자원 한도에 다다랐을 경우 등에 발생할 수 있다.
*** 파일 닫기: close()                                          :minishell:
#+begin_src C
  #include <unistd.h>

  int close(int fd);
#+end_src
close() 시스템 호출은 열려 있는 파일 디스크립터를 닫고, 프로세스가 차후에 재사용할 수 있게 해제한다.
프로세스가 종료되면, 열려있던 모든 파일 디스크립터가 자동으로 닫힌다.

close() 호출은 다음과 같이 에러 확인 코드로 에워싸야한다.
#+begin_src C
  if (close(fd) == -1)
    errExit("close");
#+end_src
이는 열리지 않은 파일 디스크립터를 닫으려고 하거나, 같은 파일 디스크립터를 두 번 닫으려고 하는 등의 에러와,
특정 파일 시스템이 파일 닫기 동작 중 발견한 에러 상황을 잡아낼 수 있다
*** 파일 오프셋 변경: lseek()
*** 범용 I/O 모델 외의 오퍼레이션: ioctl()                      :minishell:
범용 I/O 모델에서 벗어나는 파일과 디바이스 오퍼레이션을 위한 범용 메커니즘이다.
#+begin_src C
  #include <sys/ioctl.h>

  // 성공할 경우 리턴값은 request에 따라 다르다. 에러가 발생하면 -1을 리턴한다
  int ioctl(int fd, int request, ... /*argp */);
#+end_src
'fd'인자는 'request'로 지정된 제어 오퍼레이션을 수행할 디바이스나 파일을 가리키는 파일 디스크립터다.'
디바이스별 헤더 파일에 request 인자로 넘길 수 있는 상수가 정의되어 있다.
ioctl()은 'request' 인자 값을 보고 'argp' 값의 데이터형을 알 수 있다. 보통 'argp'는 정수나 구조체를 가리키는 포인터이고, 경우에 따라 쓰이지 않기도 한다.
**** i-노드 플래그
커널에 의한 파일 처리의 다양한 측면을 제어한다

몇몇 리눅스 파일 시스템은 파일과 디렉토리에 설정되는 여러 가지 i-노드 플래그를 허용한다.
이런 특성은 표준이 아닌 리눅스 확장이다.

셸에서 i-노드 플래그는 'chattr'와 'lsattr' 명령을 사용해 설정하고 확인할 수 있다
프로그램 내에서 i-노드 플래그는 추출될 수 있고, ioctl() 시스템 호출을 사용해 수정할 수 있다
i-노드 플래그는 일반 파일과 디렉토리 모두에 설정될 수 있다.

*** 정리
** 5장 파일 I/O: 더 자세히
*** 원자성과 경쟁 상태
*** 파일 제어 오퍼레이션: fcntl()
*** 파일 상태 플래그 열기
*** 파일 디스크립터와 열려 있는 파일의 관계
*** 파일 디스크립터 복사하기                                    :minishell:
셸이 특정 파일을 단순히 두 번 여는것만으로는 충분하지 않다.
이유는 두 파일 디스크립터가 파일 오프셋 포인터를 공유하지 않고, 따라서 서로 상대방의 출력을 덮어쓸 것이기 때문이다.

**** dup()
#+begin_src C
  #include <unistd.h>

  // 성공하면 (새로운) 파일디스크립터를 리턴하고, 에러가 발생하면 -1을 리턴한다
  int dup(int oldfd);
#+end_src
dup() 호출은 인자로 열린 파일 디스크립터 'oldfd'를 받고, 동일한 열린 파일 디스크립터를 가라키는 새 디스크립터를 리턴한다.
새 디스크립터는 사용하지 않은 가장 작은 파일디스크립터임이 보장된다
**** dup2()
항상 원하는 파일 디스크립터를 얻으려면, dup2()을 사용할 수 있다
#+begin_src C
  #include <unistd.h>

  // 성공하면 (새로운) 파일 디스크립터를 리턴하고, 에러가 발생하면 -1을 리턴한다
  int dup2(int oldfd, int newfd);
#+end_src
dup2() 시스템호출은 'newfd'로 주어진 디스크립터 번호를 사용해서 'oldfd'로 주어진 파일디스크립터의 복제를 만든다
'newfd'에서 명시된 파일 디스크립터가 이미 열려 있으면, dup2()는 먼저 그 파일을 닫는다.
(이렇게 닫힐 때 일어나는 모든 에러는 조용히 무시된다. 좀 더 안전한 프로그래밍 습관은 'newfd'가 열려 있으면 dup2()를 호출하기 전에 명시적으로 'newfd'를 close() 하는 것이다)

'oldfd'가 유효한 파일 디스크립터가 아니라면, dup2()는 EBADF 에러를 내며 실패하고, 'newfd'는 닫히지 않는다.
'oldfd'가 유효한 파일 디스크립터이고 'oldfd'와 'newfd'의 값이 같으면 dup2()는 아무 일도 하지 않는다
('newfd'는 닫히지 않고, dup2()는 함수 결과로 'newfd'를 리턴한다)
*** 지정된 오프셋에서의 파일 I/O: pread()와 pwrite()
*** 스캐터-개더 I/O: readv()와 writev()
*** 파일 잘라내기: truncate()와 ftruncate()
*** 비블로킹 I/O
*** 큰 파일에 대한 I/O
*** '/dev/fd' 디렉토리
*** 임시파일 만들기
*** 정리
** 6장 프로세스
*** 프로세스와 프로그램
[ 프로세스 ]
실행 중인 프로그램

[ 프로그램 ]
실행 시에 프로세스를 어떻게 만들지에 대한 광범위한 정보를 담고 있는 파일
- 바이너리 포맷 식별자: 각 프로그램 파일에는 실행 파일의 포맷에 대한 정보가 포함되어 있다
  커널은 이를 이용해서 파일의 나머지 정보를 해석한다
- 기계어 명령
- 프로그램 진입점 주소
- 데이터: 변수의 초기값과 사용할 문자상수(문자열)
- 심볼 테이블과 재배치 테이블: 프로그램 내 함수와 변수의 위치와 이름을 나타낸다
  이 테이블은 디버그와 실행 시 심볼 찾기(동적 링크) 등 다양한 목적으로 쓰인다
- 공유 라이브러리와 동적 링크 정보
- 기타정보
*** 프로세스 ID와 부모 프로세스 ID
*** 프로세스의 메모리 레이아웃
각 프로세스에 할당된 메모리는 세그먼트라고 부르는 여러 영역으로 나뉜다
- 텍스트 세그먼트
- 초기화된 데이터 세그먼트
- 초기화되지 않은 데이터 세그먼트
- 스택
- 힙
*** 가상 메모리 관리
[ 프로그램의 두 가지 지역성 ]
- 공간적 지역성: 프로그램이 최근에 접근한 메모리 주소 **근처에** 접근하는 경향
- 시간적 지역성: 프로그램이 최근에 접근한 메모리 주소에 가까운 미래에 **다시** 접근하는 경향
참조의 지역성으로 인해 프로그램의 주소 공간 중 일부만을 RAM에 올려놓고도 프로그램을 실행할 수 있다

[ 가상 메모리 방식 ]
- 페이지: 각 프로그램이 사용하는 메모리를 작은 고정 크기 단위로 나눈 것
- 페이지 프레임: RAM을 일련의 같은 크기로 나눈 것
- 스왑영역: 컴퓨터의 RAM을 보충하기 위해 따로 잡아둔 디스크 공간

참조의 지역성으로 인해 어느 한순간에는 프로그램의 일부 페이지만 물리적 메모리 페이지프레임에 존재해도 된다
이 페이지들이 상주집합(resident set)을 이룬다
프로그램의 사용되지 않는 페이지의 복사본은 스왑영역에 보관되고, 필요할 때만 물리적 메모리에 로드된다

- 페이지 폴트: 프로세스가 현재 물리적 메모리에 존재하지 않는 페이지를 참조할 때 발생한다.
  커널은 그 시점에서 해당 페이지를 디스크에서 메모리로 로드하는 동안 프로세스의 실행을 중지한다
- 가상주소공간(virtual address space): 프로세스가 사용할 수 있는 모든 가상 메모리 페이지의 집합
  각 프로세스에 할당되는 논리적인 메모리 공간
- 페이지 테이블: 페이지 테이블의 각 엔트리는 가상 페이지가 RAM의 어디에 있는지(페이지 프레임)을 나타낸다
*** 스택과 스택 프레임
*** 명령행 인자(argc, argv)
*** 환경 변수 목록                                              :minishell:
프로세스마다 환경변수목록이라는 문자열 배열이 있다.
이 문자열은 각각 '이름=값' 형태를 띠고 있다.
따라서 환경변수목록은 임의의 정보를 담고 있는 이름-값 쌍의 집합이다.
이 이름=값 목록에서 '이름'들을 환경변수(environment variable)라고 한다

새로운 프로세스가 만들어지면 부모의 환경 변수를 물려 받는다.
자식 프로세스는 생성될 당시에 부모 프로세스 환경 변수의 복사본을 받기 때문에, 이 정보전달은 일방향이고 한 번만 이뤄진다

환경변수는 셸에서 자주 쓰인다. 자신의 환경 변수에 값을 설정함으로써, 셸은 사용자 명령을 수행하기 위해 만드는 프로세스에 이 값을 전달할 수 있다.
예를 들어, 환경변수 'SHELL'은 셸 프로그램 자신의 경로명으로 설정된다. 많은 프로그램이 셸을 실행할 때 이 변수를 참조한다

대부분의 셸에서 'export' 명령을 통해 환경 변수에 값을 추가할 수 있다
#+begin_src bash
  SHELL=/bin/bash # 셸 변수를 만든다
  export SHELL # 변수를 셸 프로세스의 환경변수목록에 넣는다
#+end_src
모든 프로세스의 환경변수목록은 리눅스에 고유한 '/proc/PID/environ' 파일을 통해 확인할 수 있는데, 각각은은 '이름=값'의 쌍으로 되어있고 널 바이트로 끝난다
**** 프로그램에서 환경 변수에 접근하기
C프로그램에서 환경변수목록은 전역변수 ~char **environ~을 통해 접근할 수 있다
(C 런타임 시작 코드에서 이 변수를 정의하고 환경 변수 목록을 가리키도록 설정한다)
환경변수목록에 접근하는 다른 방법은 main() 함수의 세번째 인자를 선언하는 것이다
(이 기능은 유닉스 시스템 사이에 널리 구현되어 있지만, 스코프로 제한뿐만 아니라 SUSv3에 정의되어 있지 않으므로 사용하지 않는 편이 좋다)

getenv() 함수는 프로세스 환경 변수를 하나씩 읽을 수 있다
#+begin_src C
  #include <stdlib.h>

  // (값) 문자열을 가리키는 포인터를 리턴하거나, 해당 변수가 없으면 NULL을 리턴한다
  char *getenv(const char *name);
#+end_src
***** getenv() 이식성 문제
SUSv3는 getenv()가 리턴한 문자열을 응용 프로그램이 수정해서는 안된다고 규정하고 있다.
이는 이 문자열이 실은 환경 변수의 일부이기 때문이다.
환경 변수의 값을 바꿔야한다면 setenv()나 putenv() 함수를 쓸 수 있다

SUSv3에 따르면 getenv()가 정적으로 할당된 버퍼(이후의 getenv(), setenv(), putenv(), unsetenv() 호출로 인해 값이 바뀔 수 있는)를 이용해서 값을 구현해도 된다
getenv()의 glibc 구현은 이런식으로 정적버퍼를 쓰지 않지만, getenv()가 리턴한 문장려을 보존해야하는 이식성 있는 프로그램은 그 뒤에 이 함수들을 호출하기 전에 해당 문자열을 다른 곳에 복사해둬야 한다
*** 비지역 goto 수행: setjmp()와 longjmp()
*** 정리
** 7장 메모리 할당
*** 힙에 메모리 할당하기
**** 프로그램 브레이크 조정하기: brk()와 sbrk()
**** 힙에 메모리 할당하기: malloc()와 free()                   :minishell:
***** malloc()
#+begin_src C
  #include <stdlib.h>

  // 성공하면 할당된 메모리를 가리키는 포인터를 리턴하고, 에러가 발생하면 NULL을 리턴한다
  void *malloc(size_t size);
#+end_src
malloc() 함수는 힙에서 'size' 바이트를 할당하고 새로 할당된 메모리 블록의 시작을 가리키는 포인터를 리턴한다.
할당된 블록은 초기화되어 있지 않다
malloc()은 ~void *~을 리턴하기 때문에 어떤 형의 C 포인터에도 대입할 수 있다.
malloc()이 리턴하는 메모리 블록은 어떤 형의 C 데이터 구조도 효율적으로 접근할 수 있도록 언제나 적절한 경계에 정렬되어 있다.
이는 대부분의 아키텍처에서 8바이트나 16바이트 경계에 맞춰 할당됨을 뜻한다
SUSv3에는 malloc(0)이 NULL 또는 free()로 해제할 수 있는(그리고 해제해야 하는) 소량의 메모리를 가리키는 포인터를 리턴할 수 있다고 정의되어 있다.
리눅스에서 malloc(0)은 언제나 후자의 동작을 취한다
 (프로그램 브레이크의 상한에 도달했든지 하여) 메모리를 할당하지 못하면, malloc()은 NULL을 리턴하고 errno를 설정해 에러를 알린다.
메모리 할당 실패 가능성은 낮지만, 모든 malloc()과 관련 함수 호출은 이런 에러 리턴을 확인해야 한다.
***** free()
#+begin_src C
  #include <stdlib.h>

  void free(void *ptr);
#+end_src
free() 함수는 ptr이 가리키는 메모리 블록을 해제한다.
ptr은 이전에 malloc()이나 나중에 설명할 기타 힙 메모리 할당 함수가 리턴한 주소여야 한다.
free() 의 인자가 NULL 포인터면, 해당 호출은 아무 일도 하지 않는다
(즉, free() 에 NULL 포인터를 넘겨도 에러가 아니다)
free() 호출 이후에 ptr을 사용하면 예를 들어 ptr를 한 번 더 free() 에 넘기면 예측할 수 없는 에러를 야기할 수 있다
**** malloc()과 free()의 구현
**** 힙에 메모리를 할당하는 그 밖의 방법
*** 스택에 메모리 할당하기: alloca()
*** 정리
** 8장 사용자와 그룹
사용자마다 (고유한 로그인 이름)과 (숫자로 이뤄진 사용자 ID(UID))가 있다.
사용자는 하나 이상의 그룹에 속할 수 있다.
각 그룹에는 (고유한 이름)과 (그룹 ID(GID))가 있다.

사용자 ID와 그룹 ID의 목적
여러 가지 시스템 자원의 소유권을 결정하고 해당 자원에 접근하는 프로세스의 권한을 제어하는데 있다.
*** 패스워드 파일: ~/etc/passwd~
~/etc/passwd~는 시스템 패스워드 파일이다.
이 파일에는 사용자 계정별로 한 줄씩 기록되어 읽다
각 줄은 콜론(:)으로 구분된 7개의 필드로 이뤄져 있다

필드
- 로그인 이름
- 암호화된 패스워드
- 사용자 ID(UID)
- 그룹 ID(GID)
- 주석
- 홈디렉토리
- 로그인 셸
*** 섀도 패스워드 파일: ~/etc/shadow/~
보안을 위해 민감하지 않은 모든 사용자 정보는 공개적으로 읽을 수 있는 패스워드 파일에 두고, 암호화된 패스워드는 특권 프로그램만 읽을 수 있는 섀도 패스워드 파일에 둔다 

섀도 패스워드 파일에는 패스워드 파일의 해당 레코드와 짝을 맞추기 위한 (로그인 이름), (암호화된 패스워드), 그 외에 여러 가지 보안 관련 필드가 존재한다
*** 그룹 파일: ~/etc/group~
사용자가 속하는 그룹은 사용자의 패스워드 엔트리의 그룹 ID와 그룹별로 사용자가 나열되어 있는 그룹 파일의 조합으로 정의된다
이렇게 이상하게 정보가 두 파일로 나뉜데는 역사적인 이유가 있다.

그룹 파일에는 그룹별로 한 줄씩 기록되어 있고, 줄마다 다음과 같이 콜론으로 나뉜 4개의 필드도 있다.
필드
- 그룹 이름
- 암호화된 패스워드
- 그룹 ID
- 사용자 목록

**** 그룹의 역사적인 변천
초기 유닉스 구현에서는 사용자가 하나의 그룹에만 속할 수 있었다
사용자가 로그인 시 처음 속하는 그룹은 패스워드 파일의 그룹 필드에 의해 결정됐고 나중에 ~newgrp(1)~ 명령으로 바꿀 수 있었음

4.2BSD는 사용자가 동시에 여러 그룹에 속할 수 있다는 개념을 내놓았고, 이는 나중에 POSIX.1-1990에서 표준화됐다.
이는 그룹 파일에 각 사용자가 어느 그룹에 속하는지를 나열하는 방식이다
*** 사용자와 그룹 정보 읽기
패스워드, 섀도 패스워드, 그룹 파일에서 각 레코드를 읽어오는 라이브러리 함수와, 이 파일에서 모든 레코드를 스캔하는 라이브러리 함수에 대해 알아보자
*** 패스워드 암호화와 사용자 인증
*** 정리
** 9장 프로세스 자격증명
[프로세스 자격증명(process credential)]
프로세스마다 연관된 숫자 사용자 ID(UID)와 그룹 ID(GID)
- 실제 사용자 ID와 그룹 ID
- 유효 사용자 ID와 그룹 ID
- 저장된 set-user-ID와 저장된 set-group-ID
- 파일 시스템 사용자 ID와 그룹 ID
- 추가 그룹 ID
*** 실제 사용자 ID와 실제 그룹 ID
실제 사용자 ID와 실제 그룹 ID는 프로세스의 **소유자**인 사용자와 그룹을 나타낸다

로그인 과정의 일부로 로그인 셸은 ~/etc/passwd~ 파일에 있는 사용자의 패스워드 레코드 중 3번째와 4번째 필드에서 실제 사용자 ID와 그룹 ID를 얻는다
새로운 프로세스가 만들어지면 새로운 프로세스는 부모로부터 이 ID를 물려받는다
*** 유효 사용자 ID와 유효 그룹 ID
유효 사용자 ID와 유효 그룹 ID는 프로세스가 여러 동작을 수행할 때 프로세스에게 주어진 권한을 결정한다
유효 사용자 ID는 커널이 프로세스가 다른 프로세스에게 시그널을 보낼 수 있는지를 결정할 때도 사용된다

[특권 프로세스]
유효 사용자 ID가 0인 프로세스는 슈퍼유저의 모든 특권을 갖는다
특정 시스템 호출은 특권 프로세스만이 실행할 수 있다

보통 유효 사용자 ID와 유효 그룹 ID는 실제 사용자 ID와 실제 그룹 ID와 같지만, 달라지는 두 가지 경우가 있다
하나는 시스템호출
또다른 하나는 set-user-ID와 set-group-ID 프로그램을 실행해서이다
*** set-user-ID와 set-group-ID 프로그램
set-user-ID 프로그램을 이용하면 프로세스의 유효 사용자 ID를 실행 파일의 (소유자의) 사용자 ID와 동일한 값으로 설정한다
set-group-ID 프로그램은 유효 그룹 ID에 대해 비슷한 일을 수행한다
set-user-ID 프로그램이 실행되면('exec()'를 통해 프로세스의 메모리에 로드되면) 커널은 프로세스의 유효 사용자 ID를 실행 파일의 사용자 ID로 설정한다

[권한 비트]
실행파일(모든파일)에는 set-user-ID와 set-group-ID 비트가 있다
이 권한 비트는 'chmod' 명령으로 설정된다.
비특권 사용자는 자신이 소유한 파일에 대해서만 이 비트를 설정할 수 있다.
set-user-ID나 set-group-ID 권한 비트가 설정되어 있는 프로그램의 권한 목록을 보면, 실행권한을 나타내는 'x'가 's'로 대치되어 있다

*** 저장된 set-user-ID와 저장된 set-group-ID
set-user-ID 프로그램은 다양한 시스템 호출을 통해 유효 사용자 ID를 실제 사용자 ID 또는 저장된 set-user-ID로 설정할 수 있다
set-group-ID 프로그램의 유효 그룹 ID를 바꿀 수 있는 유사한 시스템 호출도 존재한다
이런식으로 프로그램은 실행 파일의 사용자(그룹) ID가 갖고 있는 특권을 임시로 포기했다가 다시 회복할 수 있다
*** 파일 시스템 사용자 ID와 파일 시스템 그룹 ID
리눅스의 경우
(파일 열기, 파일 소유권 변경, 파일 권한 수정 등) 파일시스템 오퍼레이션을 수정할 때 (추가 그룹 ID와 함께) 권한을 결정하는 것은 유효 사용자/그룹 ID 보다는 파일 시스템 사용자/그룹 ID다

일반적으로 파일 시스템 사용자/그룹 ID는 해당 유효 ID와 같다
시스템 호출이나 set-user-ID/set-group-ID 프로그램 실행에 의해 유효 사용자/그룹 ID가 바뀔 때마다, 해당 파일 시스템 사용자/그룹 ID도 같은 값으로 바뀐다
리눅스 고유의 시스템 호출인 ~setfsuid()~와 ~setfgid()~ 를 통해 명시적으로 파일 시스템 ID를 유효 ID와 다르게 만들었을 경우 뿐이다

[리눅스는 왜 파일 시스템 ID를 제공할까?]
*** 추가 그룹 ID
*** 프로세스 자격증명 읽고 수정하기
모든 프로세스의 자격증명은, 리눅스 공유의 ~/proc/PID/status~ 파일의 Uid, Gid, Groups 줄에서도 찾을 수 있다
Uid/Gid 줄에는 ID가 실제, 유효, 저장된, 파일시스템 ID 순으로 나열되어 있다
**** 실제, 유효, 저장된 ID 읽고 바꾸기
**** 파일 시스템 ID 읽고 바꾸기
**** 추가 그룹 ID 읽고 바꾸기
**** 프로세스 자격증명 바꾸는 호출에 대한 요약
**** 예제: 프로세스 자격증명 출력하기
*** 정리
** 10장 시간
** 11장 시스템 한도와 옵션
** 12장 시스템과 프로세스 정보
** 13장 파일 I/O 버퍼링
** 14장 파일 시스템
** 15장 파일 속성
*** 파일 정보 추출: stat()                                      :minishell:
stat(), lstat(), fstat() 시스템 호출은 파일에 관한 정보를 추출하며, 대부분의 정보는 파일 i-노드에서 얻는다
#+begin_src C
  #include <sys/stat.h>

  // 성공하면 0을 리턴하고 에러가 발생하면 -1을 리턴한다
  int stat(const char *pathname, struct stat *statbuf);
  int lstat(const char *pathname, struct stat *statbuf);
  int fstat(int fd, struct stat *statbuf);
#+end_src
**** 세가지 시스템호출(stat(), lstat(), fstat())의 차이점
파일이 명시된 방법만 다르다

- stat(): 명명된 파일에 관한 정보를 리턴한다
- lstat(): stat()와 유사하지만 명명된 파일이 심볼릭 링크인 경우, 링크가 가리키는 정보 대신에 링크 자체에 대한 정보가 리턴된다
- fstat(): 열린 파일 디스크립터에 의해 참조된 파일에 관한 정보를 리턴한다

stat()와 lstat() 시스템 호출은 파일 자체에 권한을 요구하지 않는다.
하지만 실행(검색)권한은 'pathname'에 명시된 모든 부모 디렉터리에서 요구된다.
반면 fstat()은 유효한 파일 디스크립터를 제공한다면 항상 성공적으로 리턴한다
**** stat 구조체
#+begin_src C
  struct stat {
    dev_t st_dev; /* 파일이 위치한 디바이스 ID */
    ino_t st_ino; /* 파일의 i-노드 수 */
    mode_t st_mode; /* 파일 형식과 권한 */
    nlink_t st_nlink; /* 파일의 (하드) 링크 수 */
    uid_t st_uid; /* 파일 소유자의 사용자 ID */
    gid_t st_gid; /* 파일 소유자의 그룹 ID */
    dev_t st_rdev; /* 디바이스 특정 파일의 ID */
    off_t st_size; /* 파일의 전체 크기(바이트) */
    blksize_t st_blksize; /* I/O의 최적 블록 크기(바이트) */
    blkcnt_t st_blocks; /* 할당된 블록의 수 (512B) */
    time_t st_atime; /* 마지막 파일 접근 시간 */
    time_t st_mtime; /* 마지막 파일 수정 시간 */
    time_t st_ctime; /* 마지막 상태 변경시간 */
#+end_src
*** 파일 타이스탬프
**** utime()과 utimes()을 이용한 파일 타임스탬프 변경
**** ultimensat()과 futimens()를 이용한 파일 타임스탬프 변경
*** 파일 소유권
**** 새로운 파일의 소유권
**** 파일 소유권 변경: chown(), fchown(), lchown()
*** 파일 권한
**** 일반 파일에 대한 권한
'stat' 구조체의 'st_mode' 필드의 마지막 12비트는 파일의 권한을 정의한다
이 비트의 처음 세 비트는 'set-user-ID', 'set-group-ID', 스티키 비트로 알려진 특별한 비트다
남은 9 비트는 파일에 접근하는 여러 범주의 사용자에게 허용되는 권한을 정의하는 마스크를 형성한다

파일 권한은 마스크는 세 가지로 구본된다
- 소유자(사용자): 파일이 소유자에게 허용된 권한
- 그룹: 파일 그룹 멤버인 사용자에게 허용된 권한
- 기타: 그 외의 모든 사용자에게 허용된 권한
각 사용저 범주에는 다음의 권한이 나누어진다
- 읽기: 파일의 내용을 읽는 권한
- 쓰기: 파일의 내용을 변경하는 권한
- 실행: 파일을 실행하는 권한(즉 프로그램 또는 스크립트)
  스크립트 파일을 실행하기 위해서는 읽기와 실행 권한이 요구된다

특정 권한 비트가 설정되어 있는지 확인하기 위해 ~<sys/stat.h>~ 헤더 파일은 'stat' 구조체의 'st_mode'로 AND(&) 될 수 있는 상수를 정의한다
(이런 상수는 open() 시스템 호출 정의가 포함된 ~<fcntl.h>~을 포함함으로써 정의된다)
**** 디렉토리에 대한 권한
디렉토리에 대한 권한은 다르게 해석된다

- 읽기: 디렉토리의 내용(파일이름의 목록)을 나열할 수 있다
- 쓰기: 디렉토리에서 파일을 생성하고 제거할 수 있다. 파일을 삭제하기 위해서 파일 자체에 어떤 권한을 가질 필요는 없다
- 실행: 디렉토리 내의 파일에 접근할 수 있다. 디렉토리에서 실행 권한은 검색권한이라고도 한다

디렉토리에서 읽기 권한은 단지 디렉토리 내의 파일이름 목록을 볼 수 있게 해줄 뿐이다.
디렉토리의 내용이나 파일의 i-노드 정보에 접근하려면 디렉토리에서 실행 권한이 필요하다
**** 권한 검사 알고리즘
시스템 호출에 주어진 경로명에 디렉토리 접두어가 있다면, 파일 자체에 요구되는 권한을 검사하는 것 외에도 커널은 이 접두어의 디렉토리 각각의 실행권한도 검사한다
권한 검사는 프로세스의 유효 사용자 ID와 유효 그룹 ID, 추가 그룹 ID를 사용해 수행된다
**** 파일 접근권 검사 access()                                 :minishell:
#+begin_src C
  #include <unistd.h>

  int access(const char *pathname, int mode);
  // 모든 권한이 허용된 경우 0을 리턴하고 그렇지 않은 경우 -1을 리턴한다
#+end_src
유효 사용자 ID, 유효 그룹 ID, 추가 그룹 ID는 파일에 접근할 때 프로세스가 지니고 있는 권한을 결정하는데 사용된다
'access()' 시스템 호출은 프로세스의 **실제 사용자 ID** 와 **실제 그룹 ID**, **추가 그룹 ID**에 기반해서 'pathname'에 명시된 파일의 접근성을 검사한다 
'pathname'이 심볼릭 링크인 경우 'access()'는 그 링크를 역참조한다
'mode'인자는 상수를 1개 혹은 그 이상을 OR 연산한 비트마스크다
'mode'에 명시된 모든 권한이 'pathname'에 허용되면 'access()'는 0을 리턴하고
하나의 권한이라도 허용되지 않는 경우 ( 또는 에러가 발생한 경우 ) 'access()'는 -1을 리턴한다
***** mode 상수값
| 상수 | 설명                 |
|------+----------------------|
| F_OK | 파일이 존재하는가?     |
| R_OK | 파일을 읽을 수 있는가? |
| W_OK | 파일에 쓸 수 있는가?   |
| X_OK | 파일을 실행할 수 있는가?|
**** set-user-ID, set-group-ID, 스티키 비트
**** 프로세스 파일 모드 생성 마스크: umask()
**** 파일 권한 변경: chmod()와 fchmod()
*** i-노드 플래그(ext2 확장 파일 속성)
*** 정리
** 16장 확장속성
** 17장 ACL
** 18장 디렉토리와 링크
각 프로세스에는 디렉토리와 관련된 두가지 속성이 있다
- 절대 경로명이 해석되는 시발점을 결정하는 루트 디렉토리
- 상대 경로명이 해석되는 시발점을 결정하는 현재 작업 디렉토리
*** 디렉토리와 (하드) 링크
*** 심볼릭(소프트) 링크
*** (하드) 링크 생성과 제거: link()와 unlink()                  :minishell:
**** link()
#+begin_src C
  #include <unistd.h>

  // 성공하면 0을 리턴하고 에러가 발생하면 -1을 리턴한다
  int link(const char *oldpath, const char *newpath);
#+end_src
'oldpath'에 기존 파일의 경로명이 주어지면, 'link()' 시스템 호출은 'newpath'에 명시된 경로명을 이용해 새로운 링크를 생성한다
'newpath'가 이미 존재하는 경우, 덮어쓰지 않고 대신에 에러(EEXIST)가 발생한다

리눅스에서 'link()' 시스템 호출은 심볼릭 링크를 역참조하지 않는다
'oldpath'가 심볼릭 링크라면, 'newpath'는 동일한 심볼릭 링크 파일에 새로운 하드 링크로 생성된다
**** unlink()
#+begin_src C
  #include <unistd.h>

  // 성공하면 0을 리턴하고, 에러가 발생하면 -1을 리턴한다
  int unlink(const char *pathname);
#+end_src
'unlink()' 시스템 호출은 링크를 제거하고(파일이름을 지우고), 파일의 마지막 링크인 경우 파일 자체도 제거한다
'pathname'에 명시된 링크가 존재하지 않으면, 'unlink()'는 'ENOENT' 에러로 실패한다
디렉토리를 제거하기 위해 'unlink()'를 사용할 수는 없고, 이런 동작은 'rmdir()'이나 'remove()'가 요구된다
'unlink()' 시스템 후출은 심볼릭 링크를 역참조하지 않는다
***** 모든 파일 디스크립터가 닫힌 경우에만 열린 파일 제거
파일의 마지막 링크가 제거되고, 어떤 프로세스가 파일을 참조하는 열린 파일을 갖고 있는 경우, 모든 디스크립터가 닫히기 전까지 파일은 실질적으로 제거되지 않는다
*** 파일이름 변경: rename()
*** 심볼릭 링크 관련 작업: symlink()와 readlink()
*** 디렉토리 생성과 제거: mkdir()와 rmdir()
*** 파일이나 디렉토리 제거: remove()
*** 디렉토리 읽기: opendir()와 readdir()                        :minishell:
디렉토리를 열고, 포함되어 있는 파일들을 하나씩 추출하는데 사용될 수 있다
**** opendir()
#+begin_src C
  #include <dirent.h>

  // 디렉토리 스트림 핸들을 리턴한다. 에러가 발생하면 NULL을 리턴한다
  DIR *opendir(const char *dirpath);
#+end_src
'opendir()' 함수는 디렉토리를 열고, 이후 호출에서 디렉토리를 참조할 때 사용할 수 있는 핸들을 리턴한다

'opendir()' 함수는 'dirpath'로 지정된 디렉토리를 열고, 'DIR'형 구조체를 가리키는 포인터를 리턴한다
이 구조체는 소위 디렉토리 스트림이며, 이는 호출자가 이후에 설명하는 다른 함수에 전달하는 핸들에 해당한다
'opendir()'이 리턴되면 디렉토리 스트림은 디렉토리 목록의 첫번째 엔트리에 위치한다
**** readdir()
#+begin_src C
  #include <dirent.h>

  // 다음 디렉토리 엔트리를 가리키는 정적으로 할당된 구조체의 포인터를 리턴한다
  // 디렉토리의 끝이거나 에러가 발생하면 NULL을 리턴한다
  struct dirent *readdir(DIR *dirp);
#+end_src

'readdir()'의 각 호출은 'dirp'가 가리키는 디렉토리 스트림에서 다음 디렉토리 엔트리를 읽고 엔트리에 대해 다음의 정보를 담고 있는 정적으로 할당된 'dirent' 형의 구조체를 가리키는 포인터를 리턴한다

#+begin_src C
  struct dirent {
    ino_t d_ino; /* 파일 i-노드 번호 */
    char d_name[]; /* 파일의 널로 끝나는 이름 */
#+end_src
이 구조체는 'readdir()'를 호출할 때마다 덮어써진다

'd_name'에 의해 참조되는 파일의 자세한 정보는 'opendir()'에 명시된 'dirpath' 인자에 (슬래시와) 'd_name' 필드를 통해 리턴된 값을 붙여 만든 경로명에 대해 'lstat'를 호출함으로써 얻을 수 있다

디렉토리의 끝이나 에러 발생시에 'readdir()'은 NULL을 리턴하며, 'errno'에 에러를 나타내는 값을 설정한다.
#+begin_src C
  errno = 0;
  direntp = readdir(dirp);
  if (direntp == NULL) {
    if (errno != 0) {
      /* 핸들 에러 */
    } else {
      /* 디렉토리의 끝에 도달 */
    }
  }
#+end_src
**** closedir()
#+begin_src C
  #include <dirent.h>

  // 성공하면 0을 리턴하고 에러가 발생하면 -을 리턴한다
  int closedir(DIR *dirp);
#+end_src
'closedir()' 함수는 'dirp'로 참조되는 열린 디렉토리 스트림을 닫고, 스트림에 의해 사용된 자원을 해제한다
*** 파일트리검색: nftw()
*** 프로세스의 현재 작업 디렉토리                               :minishell:
프로세스의 현재 작업 디렉토리는
프로세스에 의해 참조되는 상대적인 경로명을 결정하는 시작지점을 정의한다

새로운 프로세스는 부모로부터 현재 작업 디렉토리를 상속받는다
**** 현재 작업 디렉토리 추출
***** getcwd()
#+begin_src C
  #include <unistd.h>

  // 성공하면 cwdbuf를 리턴하고, 에러가 발생하면 NULL을 리턴한다
  char *getcwd(char *cwdbuf, size_t size);
#+end_src
'getcwd()' 함수는 현재 작업 디렉토리의 절대 경로명을 가지고 널로 끝나는 문자열을
'cwdbuf'가 가리키는 할당된 버퍼에 넣는다

호출자는 적어도 'size' 바이트 길이의 'cwdbuf'를 할당해야 한다
(일반적으로 PATH_MAX 상수를 사용해 cwdbuf의 크기를 정한다)
리눅스 /x86-32에서 'getcwd()'는 최대 4096(PATH_MAX)바이트를 리턴한다.
현재 작업 디렉토리의 절대 경로명의 길이가 이런 한도를 초과하면 'getcwd()'를 안정적으로 사용할 수 없다

성공 시에 'getcwd()'는 결과로 'cwdbuf'의 포인터를 리턴한다.
현재 경로 디렉토리의 경로명이 'size'바이트를 넘으면 'getcwd()'는 'errno'를 'ERANGE'로 설정하고 NULL을 리턴한다

'cwdbuf' 인자가 NULL이고 size가 0이면
'getcwd()'의 glibc 래퍼 함수는 요구된 만큼의 버퍼를 할당하고, 해당 함수의 결과로 그 버퍼의 포인터를 리턴한다.
메모리 누수를 피하기 위해 호출자는 이후에 'free()'를 이용해 이 버퍼를 해제해야 한다
이런 기능에 대한 의존성은 이식성 있는 응용 프로그램에서는 피해야 한다
***** chdir()
#+begin_src C
  #include <unistd.h>

  // 성공하면 0을 리턴하고, 에러가 발생하면 -1을 리턴한다
  int chdir(const char *pathname);
#+end_src
'chdir()' 시스템 호출은 프로세스의 현재 작업 디렉토리를 pathname에 명시된 절대 혹은 상대 경로명으로 변경한다
(심볼릭 링크인 경우 역참조된다)
*** 디렉토리 파일 식별자 관련 작업 운용
*** 프로세스의 루트 디렉토리 변경: chroot()
*** 경로명 결정: realpath()
*** 경로명 문자열 파싱: dirname()과 basename()
*** 정리
** 19장 파일 이벤트 감시
** 20장 시그널: 기본개념
*** 개념과 개요
*** 시그널 형식과 기본 동작
*** 시그널 속성 변경: signal()                                  :minishell:
*** 시그널 핸들러 소개
*** 시그널 전송: kill()                                         :minishell:
*** 프로세스 존재 여부 검사
*** 시그널을 보내는 그 밖의 방법: raise()와 killpg()
*** 시그널 설명 출력
*** 시그널 집합                                                 :minishell:
*** 시그널 마스크(시그널 전달 블록)
*** 보류 중인 시그널
*** 시그널은 큐에 들어가지 않는다
*** 시그널 속성 변경: sigaction()                               :minishell:
*** 시그널 대기: pause()
*** 정리
** 21장 시그널: 시그널 핸들러
** 22장 시그널: 고급 기능
** 23장 타이머와 수면
** 24장 프로세스 생성
*** fork(), exit(), wait(), execve() 소개
**** fork()
fork() 시스템 호출을 통해 부모 프로세스는 새로운 자식 프로세스를 생성할 수 있다
새로운 자식프로세스를 부모 프로세스와 (거의) 동일하게 복제해서 이뤄진다
자식 프로세스는 부모의 스택, 데이터, 힙, 텍스트, 세그먼트의 복제본을 갖게된다
**** exit(status)
프로세스를 종료시켜, 현재 프로세스가 사용한 모든 자원(메모리, 열린 파일 디스크립터 등)을 커널이 다른 프로세스에 재할당 할 수 있게 해준다

status 인자는 정수값으로 프로세스의 종료 상태를 나타낸다.
부모는 wait() 시스템 호출을 통해 이 값을 얻을 수 있다
**** wait(&status)
용도
- 자식 프로세스가 exit()를 통해 아직 종료하지 않았을 경우 wait()는 자식 프로세스 중 하나가 종료할 때까지 현재 프로세스를 중지시킨다
- 자식의 종료 상태는 wait()의 인자를 통해 리턴된다
**** exeve(pathname, argv, envp)
새 프로그램을 메모리에 로드한다.
현재 프로그램 텍스트는 버려지고 스택, 데이터, 힙, 세그먼트는 새 프로그램을 위해 초기화된다
위의 일련의 작업을 새 프로그램을 실행한다고 한다
*** 새 프로세스의 생성: fork()                                  :minishell:
#+begin_src C
  #include <unistd.h>

  // 부모 프로세스: 성공하면 자식의 프로세스 ID를 리턴하고, 에러가 발생하면 -1을 리턴한다.
  // 성공적으로 생성된 프로세스: 항상 0을 리턴한다
  pid_t fork(void);
#+end_src
두 프로세스는 동일한 프로그램 텍스트를 실행하지만 각자의 스택, 데이터, 힙 세그먼트를 갖는다
자식의 스택, 데이터, 힙 세그먼트는 부모에서 대응하는 부분의 복제본으로 주어진다

새 프로세스가 생성되지 못했을 경우 'fork()'는 -1을 리턴한다
실패의 원인으로는 (실제) 사용자 ID에 허용된 프로세스 수를 정한 자원한도에 도달했거나, 시스템 수준에서 생성할 수 있는 총 프로세스 수에 도달했을 경우다

#+begin_src C
  pid_t childPid; /* fork()가 성공한 후에 자식의 PID를 저장하기 위해 부모에서 사용됨 */

  switch (childPid = fork()) {
    case -1: /* fork() 실패 */
      /* 에러 처리 */
    case 0: /* fork() 성공 후 자식 프로세스는 여기 도달 */
      /* 자식 프로세스의 작업 수행 */
    default: /* fork() 성공 후 부모 프로세스는 여기에 도달 */
      /* 부모 프로세스의 작업 수행 */
  }
#+end_src

fork() 이후에 두 프로세스 중 누가 먼저 CPU를 사용하도록 스케줄링될지는 정해지지 않았다
**** 부모와 자식 프로세스 간의 파일 공유
'fork()'가 실행되면, 자식은 부모의 파일 디스크립터 모두에 대해 복제본을 받는다
이 복제본은 'dup()'을 통해 만들어지는데, 즉 부모와 자식 프로세스에서 서로 일치하는 디스크립터는 동일한 열린 파일 디스크립터를 가리키게 된다

열린 파일디스크립터는
(read() write(), lseek()에 의해 변경되는) 현재 파일 오프셋과
(open()으로 설정되고, fcntl()의 F_SETFL 오퍼레이션으로 변경되는) 열린 파일 플래그로 구성된다.
예를 들어, 자식이 파일 오프셋을 변경하면 이 변경은 대응하는 디스크립터를 통해 부모에게도 보인다

이런 형태의 파일 디스크립터를 공유할 필요가 없는 경우라면, 응용 프로그램은 'fork()' 이후에 부모와 자식이 각기 다른 파일 디스크립터를 사용하도록 설계돼야 한다
**** fork()의 메모리 시맨틱
*** vfork() 시스템 호출
*** fork() 후의 경쟁 상태
'fork()' 이후에 부모와 자식 간의 특정 실행 순서를 가정할 수 없다
특정 순서를 보장해야 한다면, 동기화 기법을 사용해야 한다
(세마포어, 파일잠금, 파이프를 통한 프로세스 간의 메시지 보내기 ...)
*** 시그널 동기를 통한 경쟁 상태 회피
*** 정리
** 25장 프로세스 종료
*** 프로세스 종료하기: _exit()와 exit()                         :minishell:
프로세스 종료 방법
- 시그널에 의해 발생하는 비정상 종료
- '_exit()' 시스템 호출을 통해 정상 종료
**** _exit()
#+begin_src C
  #include <unistd.h>

  void _exit(int status);
#+end_src
'status'인자는 프로세스의 종료 상태를 설정한다
부모 프로세스는 'wait()' 호출을 통해 이 값을 얻을 수 있다
정수형으로 선언되었지만 실제로는 오직 하위 8비트만이 부모 프로세스에게 전달된다
통상적으로 종료상태가 0이면 프로세스가 성공적으로 수행했음을 뜻하고
0 외의 값은 수행이 성공적이지 못함을 뜻한다
하지만 0 외의 값을 어떻게 해석해야 하는지 정해진 규칙은 없다
**** exit()
#+begin_src C
  #include <stdlib.h>

  void exit(int status);
#+end_src
exit()는 _exit()를 호출하기 전에 여러 작업을 수행한다
- 종료 핸들러(exit handler('atexit()'와 'on_exit()'로 등록되는 함수))가 등록된 역순으로 호출된다
- stdio 스트림 버퍼가 출력된다
- '_exit()' 가 주어진 'status'값으로 호출된다

명시적으로 ~return n~을 실행하는 것은 대개 'exit(n)을 호출하는 것과 동일시된다
'main()'을 호출하는 런타임 함수가 'main()'의 리턴값을 사용해서 'exit()'을 호출하기 때문이다
*** 프로세스 종료 자세히 들여다보기
정상 종료이든 비정상 종료이든 다음의 과정을 거친다
- 열린 파일 디스크립터, 디렉토리 스트림, 메시지 카탈로그 디스크립터, 변환 디스크립터를 닫는다
- 파일 디스크립터를 닫기 때문에, 해당 프로세스가 갖고 있는 모든 잠금이 해제된다
- 연결됐던 시스템Ⅴ 의 공유 메모리 세그먼트가 풀리고, 각 세그먼트에 해당하는 'shm_nattch' 카운터 값이 하나 줄어든다
- 각 시스템Ⅴ 세마포어에서, 프로세스에 의해 설정된 'semadj' 값이 세마포어 값에 추가된다
- 종료되는 프로세스가 터미널을 제어하고 있다면, 'SIGHUP' 시그널이 현 프로세스의 포그라운드 프로세스 그룹에 있는 각 프로세스로 보내지고 터미널은 해당 세션과 분리된다
- 이미 'sem_close()'가 호출됐어도 프로세스 내에 열려 있는 POSIX 이름 있는 세마포어가 닫힌다
- 이미 'mq_close()'가 호출됐어도 프로세스 내에 열려 있는 POSIX 메시지 큐가 닫힌다
- 해당 프로세스가 종료됐기 때문에, 프로세스 그룹이 고아가 되고 이 그룹 안에 멈춘 프로세스가 생기면, 해당 그룹의 모든 프로세스에게 'SIGHUP' 시그널과 'SIGCONT' 시그널이 차례로 전송된다
- 해당 프로세스가 'mlock()'이나 'mlockall()'을 사용해 만든 메모리 잠금이 제거된다
- 해당 프로세스가 'mmap()'으로 만든 메모리 매핑이 풀린다
*** 종료 핸들러
*** fork(), stdio 버퍼, _exit()의 상호작용
*** 정리
** 26장 자식 프로세스 감시
자식프로세스를 감시할 때 (상태가 언제 바뀌는지: 종료, 중지) 두가지 방법이 쓰임
- 'wait()' 호출
- 'SIGCHLD' 시그널
*** 자식 프로세스 기다리기
**** wait() 시스템 호출                                        :minishell:
#+begin_src C
  #include <sys/wait.h>

  // 종료된 자식의 프로세스 ID를 리턴한다. 에러가 발생하면 -1을 리턴한다
  pid_t wait(int *status);
#+end_src
'wait()' 시스템 호출은 호출한 프로세스의 자식 프로세스가 종료되기를 기다렸다가 'status'가 가리키는 버퍼를 통해 자식의 종료상태를 리턴한다

동작방식
- 자식 프로세스가 종료되지 않았다면, 종료될 때까지 블록된다. 호출할 당시에 이미 종료됐다면, 'wait()'는 즉각적으로 리턴한다
- 'status'가 NULL이 아니라면, 자식 프로세스가 어떻게 종료됐는지에 대한 정보는 'status'가 가리키는 정숫값을 통해 리턴된다
- 커널은 프로세스 CPU 시간과 자원 사용통계를 부모 프로세스에 딸린 모든 자식 프로세스의 사용 총량에 추가한ㄷ나
- 리턴 값으로 'wait()'는 종료된 자식 프로세스의 프로세스 ID를 리턴한다

[ 에러 ]
에러 시 'wait()'는 -1을 리턴한다
예로 들어 호출한 프로세스가 자식이 없는 경우 에러가 발생한다.
이때 'errno' 값이 'ECHILD'다.
**** waitpid() 시스템 호출                                     :minishell:
#+begin_src C
  #include <sys/wait.h>

  // 자식의 프로세스 ID 또는 0(본문 참조)를 리턴한다. 에러가 발생하면 -1을 리턴한다
  pid_t waitpid(pid_t pid, int *status, int options);
#+end_src
[ 입력과 리턴 ]
'status'가 가리키는 버퍼를 통해 자식의 종료상태를 리턴한다
리턴 값으로 종료된 자식 프로세스의 프로세스 ID를 리턴한다

[ pid 인자 ]
- pid가 0보다 크면, pid와 동일한 프로세스 ID를 갖는 자식 프로세스를 기다린다
- pid가 0이면, 부모 프로세스와 동일한 프로세스 그룹에 속한 자식 프로세스를 기다린다
- pid가 -1보다 작으면, pid의 절대값과 동일한 프로세스 그룹 ID를 갖는 자식 프로세스를 기다린다
- pid가 -1이면, 아무 자식 프로세스 중 하나가 끝나기를 기다린다. =wait(&status)= 는 =waitpid(-1, &status, 0)=과 동일하다

[ options ]
options 인자는 다음 플래그 값을 통해 설정되는 비트마스크다
- WUNTRACED: 종료된 자식 프로세스에 대한 정보뿐만 아니라, 시그널에 의해 자식 프로세스가 멈춰질 때도 정보를 리턴한다
- WCONTINUED: 'SIGCONT' 시그널을 받고 다시 재개한 멈췄던 프로세스에 대한 정보도 리턴한다
- WNOHANG: pid로 명시된 자식 중 상태가 변경된 것이 없다면 (상태가 변경됨을 확인하고자) 블로킹되지 않고 즉각적으로 리턴한다. 이 경우 'waitpid()'는 0을 리턴한다. 호출한 프로세스가 pid로 명시한 자식 프로세스가 없다면, 'waitpid()'는 실패하고 'ECHILD'에러를 낸다 

'wait()'의 제약
- 부모가 여러 개의 자식 프로세스를 생성할 경우, 어떤 특정 프로세스가 끝나기를 기다리는 것이 불가능했다. 단지 다음에 종료되는 자식 프로세스를 기다릴 뿐이다
- 어떤 자식 프로세스도 종료되지 않는다면 'wait()'는 항상 블록된다. 블록 되지 않는 편이 유용할 수 있다. 예로들면 종료된 프로세스가 없음을 바로 알려주는 경우
- 'wait()'를 통해서는 종료된 자식에 대한 정보만 얻을 수 있다. 자식 프로세스가 시그널에 의해 멈춰있다거나 시그널에 의해 다시 재개된다는 등의 정보는 알 수 없다
**** 대기 상태 값
리턴하는 'status' 값을 통해 다음과 같이 이벤트를 구분할 수 있다
- 정상종료
- 시그널에 이한 종료
- 시그널에 의한 멈춤
- 시그널에 의한 재개
**** 시그널 핸들러로부터 프로세스 종료
**** waitid() 시스템 호출
**** wait3()와 wait4() 시스템 호출                             :minishell:
[ 'wait3()'와 'wait4()'와 'waitpid()'의 차이점 ]
'wait3()'와 'wait4()'는 종료된 자식 프로세스의 자원사용 정보를 'rusage'가 가리키는 구조체에 리턴한다
이 정보에는 프로세스가 사용한 CPU 시간과 메모리 사용 통계가 포함된다
'rusage' 인자이 사용을 제외하면, 'wait3()'는 불특정한 자식을 기다리고, 'wait4()' 는 기다릴 자식 프로세스를 구체적으로 명시할 때 쓰인다
*** 고아와 좀비 프로세스
[ 부모 프로세스가 먼저 죽는다면 ]
모든 프로세스의 조상이며 프로세스 ID가 1인 'init'가 고아 프로세스를 입양한다
부모 프로세스가 종료되면 'getppid()' 호출은 1을 리턴한다
이 방법으로 자식의 진짜 부모가 여전히 살아있는지 여부를 알 수 있다

[ 부모 프로세스가 'wait()'를 실행하기 전에 자식 프로세스가 죽는다면 ]
부모는 자식이 어떻게 종료됐는지 확인하기 위해 'wait()'를 실행하도록 허용해야 한다
커널은 자식 프로세스를 좀비로 만들어서 이 상황을 해결한다

[ 좀비 ]
자식 프로세스가 사용한 거의 모든 자원은 다른 프로세스가 재사용할 수 있도록 시스템으로 되돌려진다
남게 되는 유일한 부분은 자식 프로세스 ID, 종료 상태 및 자원 사용 통계를 기록한 커널 프로세스 테이블의 엔트리
만약 부모가 'wait()'를 실행하지 않고 종료되면, 'init' 프로세스가 자식 프로세스를 입양한 후에 자동으로 'wait()'를 실행해 좀비 프로세스를 시스템으로부터 제거한다
부모가 자식을 생성했지만 'wait()'를 실행하지 않는다면, 좀비가 된 자식 프로세스의 엔트리는 커널 프로세스 테이블 내에 끝까지 남게 된다
즉, 부모 프로세스는 'wait()'를 호출해서 죽은 자식 프로세스가 오랫동안 시스템에 상주하는 좀비가 되지 않고 항상 시스템으로부터 제거되게 해야한다
*** SIGCHLD 시그널
**** SIGCHLD 핸들러 설치
**** 중지된 자식에 대한 SIGCHLD 전달
**** 죽은 자식 프로세스 무시하기
*** 정리
** 27장 프로그램 실행
*** 새 프로그램 실행하기: execve()                              :minishell:
[ 기능 ]
'execve()' 시스템 호출은 새 프로그램을 프로세스의 메모리로 로드한다
이 과정에서 프로세스의 스택, 데이터, 힙이 새 프로그램의 것으로 교체된다

#+begin_src C
  #include <unistd.h>

  // 성공하면 아무것도 리턴하지 않고, 에러가 발생하면 -1을 리턴한다
  int execve(const char *pathname, char *const argv[], char *const envp[]);
#+end_src
[ 인자 ]
'pathname'인자는 프로세스의 메모리로 로드될 새 프로그램의 경로 정보를 담고 있다
절대경로('/')이거나 호출한 프로그램의 현재 작업 디렉토리에 대한 상대경로다

'argv'인자는 새 프로그램에 넘겨질 명령행 인자를 정한다
'argv[0]'에 해당하는 값은 명령 자신이다. 일반적으로 이 값은 'pathname'의 기본값(basename)과 같다

'envp'는 새 프로그램의 환경 변수 목록을 정한다
'envp' 인자는 새 프로그램의 'environ' 배열에 해당한다
이름=값 형태의 문자열을 가리키고 NULL로 종료되는 리스트

[ 리턴 ]
성공적이면 아무것도 리턴하지 않는다
-1을 리턴했다면 에러가 발생했다는 뜻이다
에러는 'errno'을 통해 확인 가능하다

[ 프로세스 ID ]
'execve()' 후에 프로세스의 프로세스 ID 는 그대로 남는다
몇 개의 프로세스 속성도 변하지 않는다

[ set-user-ID ]
'pathname'에 의해 정해진 프로그램 파일의 'set-user-' 권한 비트가 설정되어 있으면, 파일이 실행될 때 프로세스의 유효 사용자(그룹) ID는 파일 소유자(그룹)의 것과 같아진다
이는 특별한 프로그램이 실행될 때 임시적으로 권한을 주기 위한 방편이다
*** exec() 라이브러리 함수
**** PATH 환경 변수
**** 프로그램 인자를 리스트로 지정하기
**** 호출한 프로세스의 환경을 새 프로그램에 전달하기
**** 디스크립터가 가리키는 파일 실행하기: fexecve()
** 28장 더 자세히 살펴보는 프로세스 생성과 프로그램 실행
** 29장 프로세스 그룹, 세션, 작업 제어
** 30장 프로세스 우선순위와 스케줄링
** 31장 프로세스 자원
** 32장 데몬
** 33장 안전한 특권 프로그램 작성
** 34장 능력
** 35장 로그인 계정
** 36장 공유 라이브러리 기초
** 37장 공유라이브러리의 고급 기능
* 고급 리눅스 API
** 1장 스레드: 소개
** 2장 스레드: 스레드 동기화
** 3장 스레드: 스레드 안정성과 스레드별 저장소
** 4장 스레드: 스레드 취소
** 5장 스레드: 기타 세부사항
** 6장 프로세스 간 통신 개요
** 7장 파이프와 FIFO
파이프는 1970년대 초 유닉스 3판에 소개된 기술이다
유닉스 시스템 IPC 기술 중 가장 오래됐다

파이프는 2개의 프로세스가 각기 다른 프로그램으로 동작할 때 어떻게 한 프로그램의 결과를 다른 프로세스의 입력으로 사용할 것인가라는 문제에 대한 해결책이다
파이프는 연관된 프로세스 간에 데이터를 넘길 수 있다
*** 개요
파이프의 주요 특징
- 파이프는 바이트 스트림이다
  파이프가 바이트 스트림이라고 하는 것은 파이프를 사용할 때 메시지의 개념이나 규칙이 없음을 의미한다
  파이프를 통과하는 데이터는 순차적으로 전송되어 정확히 쓰여진 순서대로 읽힌다
  **읽기 프로세스**는 쓰기 프로세스에서 어떤 크기의 데이터를 쓰든지 간에 원하는 크기의 데이터 블록을 파이프로부터 읽을 수 있다

- 파이프 읽기
  비어 있는 파이프로부터 데이터를 읽어오려면 적어도 한 바이트를 파이프에 써야한다
  파이프의 쓰기가 닫혔다면 읽기 프로세스는 남아 있는 모든 데이터를 읽고 난 후에 EOF를 보게 될 것이다
  ('read()' 함수가 0을 리턴한다)

- 파이프는 단방향성
- PIPE_BUF 바이트씩 쓰면 아토믹이 보장된다
- 파이프의 용량은 제한되어 있다
*** 파이프 만들기와 사용하기                                    :minishell:
#+begin_src C
  #include <unistd.h>

  // 성공하면 0을 리턴하고 에러가 발생하면 -1을 리턴한다
  int pipe(int filedes[2]);
#+end_src
'filedes[2]'에서 하나는 파이프 읽는 쪽을 나타내고('filedes[0]'), 하나는 쓰는 쪽을 나타낸다('filedes[1]')

파이프에 I/O 오퍼레이션을 수행하려면 'read()'와 'write()' 시스템 호출을 사용해야 한다

파이프가 비어 있으면 블록된다
**** 사용하지 않는 파이프 파일 디스크립터 닫기
[ 읽기 프로세스의 쓰기 디스크립터 닫기 ]
파이프 읽기 프로세스는
자신의 쓰기 디스크립터를 닫은 후
다른 프로세스에서 쓰기를 완료하고 디스크립터를 닫으면
읽기 프로세스는 EOF를 보게 된다

이때 읽기 프로세스가 파이프 쓰기 끝을 닫지 않았다면
다른 프로세스는 자신의 쓰기 디스크립터를 닫고 난 후에
읽기 프로세스는 모든 데이터를 다 읽었다 하더라도 EOF를 볼 수 없을 것이다

대신 'read()'는 데이터를 기다리는 것을 블록할 텐데,
커널이 여전히 적어도 하나 이상의 쓰기 디스크립터가 파이프를 열고 있음을 알고 있기 때문이다

[ 쓰기 프로세스의 읽기 디스크립터 닫기 ]
시그널을 감지하려면 사용하지 않는 파이프의 읽기 디스크립터를 닫아야 한다

그 외에도
모든 파일디스크립터를 닫아야만 파이프가 폐기되고 자원을 다른 프로세스가 사용할 수 있기 때문이다.
이때 파이프 상의 읽지 않은 모든 데이터는 소멸된다
*** 파이프로 프로세스 동기화하기
*** 필터 연결에 파이프 사용하기
*** 파이프를 사용해 셸 명령과 대화하기: popen()
*** 파이프와 stdio 버퍼링
*** FIFO
*** FIFO를 사용하는 클라이언트/서버 응용 프로그램
*** 비블로킹 I/O
*** 파이프와 FIFO에서 read()와 write() 함수의 의미
*** 정리
** 8장 시스템 Ⅴ IPC 소개
** 9장 시스템 Ⅴ 메시지 큐
** 10장 시스템 Ⅴ 세마포어
** 11장 시스템 Ⅴ 공유 메모리
** 12장 메모리 매핑
** 13장 가상 메모리 오퍼레이션
** 14장 POSIX IPC 소개
** 15장 POSIX 메시지 큐
** 16장 POSIX 세마포어
** 17장 POSIX 공유 메모리
** 18장 파일 잠금
** 19장 소켓: 소개
** 20장 소켓: 유닉스 도메인
** 21장 소켓: TCP/IP 네트워크 기초
** 22장 소켓: 인터넷 도메인
** 23장 소켓: 서버 설계
** 24장 소켓: 고급 옵션
** 25장 터미널
*** 개요
*** 터미널 속성값 읽기와 수정                                   :minishell:
*** stty 명령
*** 터미널 특수문자
*** 터미널 플래그
*** 터미널 I/O 모드
**** 정규 모드
**** 비정규 모드
**** cooked, cbreak, raw 모드
*** 터미널 라인 속도(비트 전송률)
*** 터미널 라인 제어
*** 터미널 윈도우 크기
*** 터미널 식별                                                 :minishell:
*** 정리
** 26장 대체 I/O 모델
** 27장 가상 터미널
