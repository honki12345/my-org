* 기초 리눅스 API
** 1장 역사와 표준
*** 유닉스와 C의 간략한 역사
*** 리눅스의 간략한 역사
**** GNU 프로젝트
**** 리눅스 커널
*** 표준화
**** C 프로그래밍 언어
**** 최초의 POSIX 표준
**** X/Open Company와 오픈그룹
**** SUSv3와 POSIX.1-2001
**** SUSv4와 POSIX.1-2008
**** 유닉스 표준 연대표
**** 구현표준
**** 리눅스, 표준, 리눅스 스탠더드 베이스
*** 정리
** 2장 기본개념
*** 핵심 운영체제: 커널
*** 셸
*** 사용자와 그룹
*** 단일 디렉토리 계층구조, 디렉토리, 링크, 파일
*** 파일 I/O 모델
*** 프로그램
*** 프로세스
*** 메모리 매핑
*** 정적 라이브러리와 공유 라이브러리
*** 프로세스 간 통신과 동기화
*** 시그널
*** 스레드
*** 프로세스 그룹과 셸 작업 제어
*** 세션, 제어 터미널, 제어 프로세스
*** 가상 터미널
*** 날짜와 시간
*** 클라이언트/서버 아키텍처
*** 실시간
*** /proc 파일 시스템
*** 정리
** 3장 시스템 프로그래밍 개념
*** 시스템 호출
*** 라이브러리 함수
*** 표준 C 라이브러리: GNU C 라이브러리(glib)
*** 시스템 호출과 라이브러리 함수의 에러 처리                   :minishell:
시스템 호출이 실패하면 전역 정수 변수 'errno'를 특정 에러를 나타내는 양수로 설정한다.
헤더 파일 '<errno.h>을 사용하면 'errno' 선언 뿐만 아니라 다양한 에러 상수도 포함된다.
각 메뉴얼 'ERROS' 세션에는 각 시스템 호출이 리턴할 수 있는 'errno' 값의 목록이 나와 있다.

에러를 확인할 때는 언제나 함수의 리턴 값이 에러를 나타내는지를 확인하고, 그 경우에만 'errno'을 통해 에러의 원인을 찾아야 한다.
또는 호출 전에 'errno'을 0으로 설정하고, 호출 후에 다시 확인한다
**** perror()
#+begin_src C
  #include <stdio.h>

  void perror(const char *msg);
#+end_src

The 'perror()' function produces a message on standard error describing the last error encountered during a call to system or library function.
First (if 's' is not NULL and *s is not a null byte ('\0')),
the argument string 's' is printed, followed by a colon and a blank.
Then an error message corresponding to the current value of 'errno' and a new-line.
**** strerror()
#+begin_src C
  #include <string.h>

  char *strerror(int errnum);
#+end_src
'strerror()' 함수는 인자 'errnum'으로 주어진 에러 번호에 해당하는 에러 문자열을 리턴한다.
'strerror()'가 리턴한 문자열은 정적으로 할당되어 있을 수 있으므로, 이후의'strerror()'에 의해 다른 값으로 바뀔 수 있다.
'errnum'이 알 수 없는 에러 번호를 담고 있으면, 'strerror()'는 'Unknown error nnn'이라는 형태의 문자열을 리턴한다.
어떤 구현에서는 이런 경우 'strerror()'가 NULL을 리턴하기도 한다
*** 이 책의 예제 프로그램
**** 명령행 옵션과 인자
**** 공통 함수와 헤더 파일
*** 이식성 이슈
**** 기능 테스트 매크로
**** 시스템 데이터형
**** 기타 이식성 이슈
*** 정리
** 4장 파일 I/O: 범용 I/O 모델
*** 개요
I/O를 수행하는 모든 시스템 호출은 파일 디스크립터라는 음이 아닌 정수를 통해 열려 있는 파일을 참조한다.
파일 디스크립터는 파이프, FIFO, 소켓, 터미널, 디바이스, 일반 파일 등 종류에 상관없이 모든 열려 있는 파일을 참조할 때 쓴다
셸은 보통 세가지 파일 디스크립터가 언제나 열려 있는 채로 동작한다 (대화형 셸에서 이 세가지 파일 디스크립터는 셸이 동작중인 터미널을 가리킨다)
프로그램은 셸의 디스크립터의 복사본을 물려 받는다
명령행에서 I/O을 재지정하면 셸은 프로그램을 시작하기 전에 파일 디스크립터가 적절히 수정되도록 보장한다.

**** 파일 I/O을 수행하는 네가지 핵심 시스템 호출
***** `fd = open(pathname, flags, mode)`
`pathname`이 가리키는 파일을 열고, 열린 파일을 이후의 호출에서 참조할 때 쓸 파일 디스크립터를 리턴한다.
해당 파일이 존재하면 `flags`의 값에 따라 `open()`이 만들 수도 있다.
`flags`는 또한 파일을 읽기, 쓰기, 둘 다를 위해 열지를 지정한다.
`mode`는 파일을 만들 경우 파일에 부여할 권한을 지정한다.
`open()`는 파일을 만들지 않을 경우, 이 인자는 무시되므로 생략할 수 있다.
***** `numread = read(fd, buffer, count)`
`fd`가 가리키는 파일에서 최대 `count` 바이트를 읽어 `buffer`에 저장한다.
`read()`는 실제로 읽은 바이트 수를 리턴한다.
더 이상 읽을 수 없으면 (즉, 파일의 끝을 만나면) `read()`는 0을 리턴한다.
***** `numwritten = write(fd, buffer, count)`
`buffer`에서 최대 `count` 바이트를 `fd`가 열려 있는 파일에 쓴다.
`write()`는 실제로 쓴 바이트 수를 리턴하므로, `count`보다 작은 수를 리턴할 수 있다
***** `status = close(fd)`
모든 I/O를 마친 뒤에 파일 디스크립터 `fd`와 관련 커널 자원을 해제하기 위해 호출한다
*** I/O의 범용성
네가지 시스템 호출(`open(), read(), write(), close()`)이 터미널 같은 디바이스를 포함해 모든 종류의 파일에 대한 I/O를 수행한다.
따라서 이 시스템 호출만으로 프로그램을 작성하면, 어떤 종류의 파일에 대해서도 동작할 것이다.
이러한 I/O의 범용성은 각 파일 시스템과 드라이버가 같은 종류의 I/O 시스템 호출을 구현함으로써 가능해졌다.
파일 시스템이나 디바이스 특유의 기능을 써야할 때는 다목적 시스템 호출인 `ioctl()`를 사용할 수 있다.
*** 파일 열기: open()                                           :minishell:
#+begin_src C
  #include <sys/stat.h>
  #include <fcntl.h>

  // flags는 파일 접근모드, mode는 파일 권한(새로운 파일 만들 때)
  int open(const char *pathname, int flags, ... /* mode_t mode */);
#+end_src
 `open()` 시스템 호출은 기존 파일을 열거나 새로운 파일을 만들고 연다.
`pathname`이 가리키는 파일을 연다. `pathname`이 심볼릭 링크면 역참조한다.
성공하면 `open()`은 파일 디스크립터를 리턴하며, 이후의 시스템 호출에서는 이 파일 디스크립터를 통해 해당 파일을 참조할 수 있다.
에러가 발생하면 `open()`은 -1을 리턴하고 그에 맞춰 `errno`가 설정된다.
 `flags` 인자는 *파일 접근모드*를 지정하는 비스마스크다.
 `open()`으로 새로운 파일을 만들 때는 `mode` 비트 마스크 인자로 *파일 권한*을 설정한다.
`open()` 호출에 `O_CREAT`를 지정하지 않으면 `mode`는 생략해도 된다.
새로 만들어진 파일에 실제로 설정되는 권한은 mode 인자뿐만 아니라 프로세스의 'unmask'와 (선태적으로 존재하는) 부모 디렉토리의 기본 접근 제어 목록에 따라서도 달라진다
**** open()의 flags 인자
**** open()의 에러
**** creat() 시스템 호출
*** 파일 읽기: read()
*** 파일에 쓰기: write()                                        :minishell:
#+begin_src C
  #include <unistd.h>

  ssize_t write(int fd, void *buffer, size_t count);
#+end_src
write() 시스템 호출은 열려있는 파일에 데이터를 쓴다.
**** write의 인자와 리턴값
'buffer'는 쓸 데이터의 주소이고, 'count'는 'buffer'에서 읽어와 쓸 바이트 수이고, 'fd'는 데이터를 쓸 파일을 가리키는 파일 디스크립터이다.
성공하면 write()는 실제로 쓴 바이트 수를 리턴하는데 이는 'count'보다 작을 수 있다.
디스크 파일의 경우, 이는 디스크가 가득 찼거나, 파일 크기에 대한 프로세스 자원 한도에 다다랐을 경우 등에 발생할 수 있다.
*** 파일 닫기: close()                                          :minishell:
#+begin_src C
  #include <unistd.h>

  int close(int fd);
#+end_src
close() 시스템 호출은 열려 있는 파일 디스크립터를 닫고, 프로세스가 차후에 재사용할 수 있게 해제한다.
프로세스가 종료되면, 열려있던 모든 파일 디스크립터가 자동으로 닫힌다.

close() 호출은 다음과 같이 에러 확인 코드로 에워싸야한다.
#+begin_src C
  if (close(fd) == -1)
    errExit("close");
#+end_src
이는 열리지 않은 파일 디스크립터를 닫으려고 하거나, 같은 파일 디스크립터를 두 번 닫으려고 하는 등의 에러와,
특정 파일 시스템이 파일 닫기 동작 중 발견한 에러 상황을 잡아낼 수 있다
*** 파일 오프셋 변경: lseek()
*** 범용 I/O 모델 외의 오퍼레이션: ioctl()                      :minishell:
범용 I/O 모델에서 벗어나는 파일과 디바이스 오퍼레이션을 위한 범용 메커니즘이다.
#+begin_src C
  #include <sys/ioctl.h>

  // 성공할 경우 리턴값은 request에 따라 다르다. 에러가 발생하면 -1을 리턴한다
  int ioctl(int fd, int request, ... /*argp */);
#+end_src
'fd'인자는 'request'로 지정된 제어 오퍼레이션을 수행할 디바이스나 파일을 가리키는 파일 디스크립터다.'
디바이스별 헤더 파일에 request 인자로 넘길 수 있는 상수가 정의되어 있다.
ioctl()은 'request' 인자 값을 보고 'argp' 값의 데이터형을 알 수 있다. 보통 'argp'는 정수나 구조체를 가리키는 포인터이고, 경우에 따라 쓰이지 않기도 한다.
**** i-노드 플래그
커널에 의한 파일 처리의 다양한 측면을 제어한다

몇몇 리눅스 파일 시스템은 파일과 디렉토리에 설정되는 여러 가지 i-노드 플래그를 허용한다.
이런 특성은 표준이 아닌 리눅스 확장이다.

셸에서 i-노드 플래그는 'chattr'와 'lsattr' 명령을 사용해 설정하고 확인할 수 있다
프로그램 내에서 i-노드 플래그는 추출될 수 있고, ioctl() 시스템 호출을 사용해 수정할 수 있다
i-노드 플래그는 일반 파일과 디렉토리 모두에 설정될 수 있다.

*** 정리
** 5장 파일 I/O: 더 자세히
*** 원자성과 경쟁 상태
*** 파일 제어 오퍼레이션: fcntl()
*** 파일 상태 플래그 열기
*** 파일 디스크립터와 열려 있는 파일의 관계
*** 파일 디스크립터 복사하기                                    :minishell:
셸이 특정 파일을 단순히 두 번 여는것만으로는 충분하지 않다.
이유는 두 파일 디스크립터가 파일 오프셋 포인터를 공유하지 않고, 따라서 서로 상대방의 출력을 덮어쓸 것이기 때문이다.

**** dup()
#+begin_src C
  #include <unistd.h>

  // 성공하면 (새로운) 파일디스크립터를 리턴하고, 에러가 발생하면 -1을 리턴한다
  int dup(int oldfd);
#+end_src
dup() 호출은 인자로 열린 파일 디스크립터 'oldfd'를 받고, 동일한 열린 파일 디스크립터를 가라키는 새 디스크립터를 리턴한다.
새 디스크립터는 사용하지 않은 가장 작은 파일디스크립터임이 보장된다
**** dup2()
항상 원하는 파일 디스크립터를 얻으려면, dup2()을 사용할 수 있다
#+begin_src C
  #include <unistd.h>

  // 성공하면 (새로운) 파일 디스크립터를 리턴하고, 에러가 발생하면 -1을 리턴한다
  int dup2(int oldfd, int newfd);
#+end_src
dup2() 시스템호출은 'newfd'로 주어진 디스크립터 번호를 사용해서 'oldfd'로 주어진 파일디스크립터의 복제를 만든다
'newfd'에서 명시된 파일 디스크립터가 이미 열려 있으면, dup2()는 먼저 그 파일을 닫는다.
(이렇게 닫힐 때 일어나는 모든 에러는 조용히 무시된다. 좀 더 안전한 프로그래밍 습관은 'newfd'가 열려 있으면 dup2()를 호출하기 전에 명시적으로 'newfd'를 close() 하는 것이다)

'oldfd'가 유효한 파일 디스크립터가 아니라면, dup2()는 EBADF 에러를 내며 실패하고, 'newfd'는 닫히지 않는다.
'oldfd'가 유효한 파일 디스크립터이고 'oldfd'와 'newfd'의 값이 같으면 dup2()는 아무 일도 하지 않는다
('newfd'는 닫히지 않고, dup2()는 함수 결과로 'newfd'를 리턴한다)
*** 지정된 오프셋에서의 파일 I/O: pread()와 pwrite()
*** 스캐터-개더 I/O: readv()와 writev()
*** 파일 잘라내기: truncate()와 ftruncate()
*** 비블로킹 I/O
*** 큰 파일에 대한 I/O
*** '/dev/fd' 디렉토리
*** 임시파일 만들기
*** 정리
** 6장 프로세스
*** 프로세스와 프로그램
*** 프로세스 ID와 부모 프로세스 ID
*** 프로세스의 메모리 레이아웃
*** 가상 메모리 관리
*** 스택과 스택 프레임
*** 명령행 인자(argc, argv)
*** 환경 변수 목록                                              :minishell:
프로세스마다 환경변수목록이라는 문자열 배열이 있다.
이 문자열은 각각 '이름=값' 형태를 띠고 있다.
따라서 환경변수목록은 임의의 정보를 담고 있는 이름-값 쌍의 집합이다.
이 이름=값 목록에서 '이름'들을 환경변수(environment variable)라고 한다

새로운 프로세스가 만들어지면 부모의 환경 변수를 물려 받는다.
자식 프로세스는 생성될 당시에 부모 프로세스 환경 변수의 복사본을 받기 때문에, 이 정보전달은 일방향이고 한 번만 이뤄진다

환경변수는 셸에서 자주 쓰인다. 자신의 환경 변수에 값을 설정함으로써, 셸은 사용자 명령을 수행하기 위해 만드는 프로세스에 이 값을 전달할 수 있다.
예를 들어, 환경변수 'SHELL'은 셸 프로그램 자신의 경로명으로 설정된다. 많은 프로그램이 셸을 실행할 때 이 변수를 참조한다

대부분의 셸에서 'export' 명령을 통해 환경 변수에 값을 추가할 수 있다
#+begin_src bash
  SHELL=/bin/bash # 셸 변수를 만든다
  export SHELL # 변수를 셸 프로세스의 환경변수목록에 넣는다
#+end_src
모든 프로세스의 환경변수목록은 리눅스에 고유한 '/proc/PID/environ' 파일을 통해 확인할 수 있는데, 각각은은 '이름=값'의 쌍으로 되어있고 널 바이트로 끝난다
**** 프로그램에서 환경 변수에 접근하기
C프로그램에서 환경변수목록은 전역변수 ~char **environ~을 통해 접근할 수 있다
(C 런타임 시작 코드에서 이 변수를 정의하고 환경 변수 목록을 가리키도록 설정한다)
환경변수목록에 접근하는 다른 방법은 main() 함수의 세번째 인자를 선언하는 것이다
(이 기능은 유닉스 시스템 사이에 널리 구현되어 있지만, 스코프로 제한뿐만 아니라 SUSv3에 정의되어 있지 않으므로 사용하지 않는 편이 좋다)

getenv() 함수는 프로세스 환경 변수를 하나씩 읽을 수 있다
#+begin_src C
  #include <stdlib.h>

  // (값) 문자열을 가리키는 포인터를 리턴하거나, 해당 변수가 없으면 NULL을 리턴한다
  char *getenv(const char *name);
#+end_src
***** getenv() 이식성 문제
SUSv3는 getenv()가 리턴한 문자열을 응용 프로그램이 수정해서는 안된다고 규정하고 있다.
이는 이 문자열이 실은 환경 변수의 일부이기 때문이다.
환경 변수의 값을 바꿔야한다면 setenv()나 putenv() 함수를 쓸 수 있다

SUSv3에 따르면 getenv()가 정적으로 할당된 버퍼(이후의 getenv(), setenv(), putenv(), unsetenv() 호출로 인해 값이 바뀔 수 있는)를 이용해서 값을 구현해도 된다
getenv()의 glibc 구현은 이런식으로 정적버퍼를 쓰지 않지만, getenv()가 리턴한 문장려을 보존해야하는 이식성 있는 프로그램은 그 뒤에 이 함수들을 호출하기 전에 해당 문자열을 다른 곳에 복사해둬야 한다
*** 비지역 goto 수행: setjmp()와 longjmp()
*** 정리
** 7장 메모리 할당
*** 힙에 메모리 할당하기
**** 프로그램 브레이크 조정하기: brk()와 sbrk()
**** 힙에 메모리 할당하기: malloc()와 free()                   :minishell:
***** malloc()
#+begin_src C
  #include <stdlib.h>

  // 성공하면 할당된 메모리를 가리키는 포인터를 리턴하고, 에러가 발생하면 NULL을 리턴한다
  void *malloc(size_t size);
#+end_src
malloc() 함수는 힙에서 'size' 바이트를 할당하고 새로 할당된 메모리 블록의 시작을 가리키는 포인터를 리턴한다.
할당된 블록은 초기화되어 있지 않다
malloc()은 ~void *~을 리턴하기 때문에 어떤 형의 C 포인터에도 대입할 수 있다.
malloc()이 리턴하는 메모리 블록은 어떤 형의 C 데이터 구조도 효율적으로 접근할 수 있도록 언제나 적절한 경계에 정렬되어 있다.
이는 대부분의 아키텍처에서 8바이트나 16바이트 경계에 맞춰 할당됨을 뜻한다
SUSv3에는 malloc(0)이 NULL 또는 free()로 해제할 수 있는(그리고 해제해야 하는) 소량의 메모리를 가리키는 포인터를 리턴할 수 있다고 정의되어 있다.
리눅스에서 malloc(0)은 언제나 후자의 동작을 취한다
 (프로그램 브레이크의 상한에 도달했든지 하여) 메모리를 할당하지 못하면, malloc()은 NULL을 리턴하고 errno를 설정해 에러를 알린다.
메모리 할당 실패 가능성은 낮지만, 모든 malloc()과 관련 함수 호출은 이런 에러 리턴을 확인해야 한다.
***** free()
#+begin_src C
  #include <stdlib.h>

  void free(void *ptr);
#+end_src
free() 함수는 ptr이 가리키는 메모리 블록을 해제한다.
ptr은 이전에 malloc()이나 나중에 설명할 기타 힙 메모리 할당 함수가 리턴한 주소여야 한다.
free() 의 인자가 NULL 포인터면, 해당 호출은 아무 일도 하지 않는다
(즉, free() 에 NULL 포인터를 넘겨도 에러가 아니다)
free() 호출 이후에 ptr을 사용하면 예를 들어 ptr를 한 번 더 free() 에 넘기면 예측할 수 없는 에러를 야기할 수 있다
**** malloc()과 free()의 구현
**** 힙에 메모리를 할당하는 그 밖의 방법
*** 스택에 메모리 할당하기: alloca()
*** 정리
** 8장 사용자와 그룹
** 9장 프로세스 자격증명
** 10장 시간
** 11장 시스템 한도와 옵션
** 12장 시스템과 프로세스 정보
** 13장 파일 I/O 버퍼링
** 14장 파일 시스템
** 15장 파일 속성
*** 파일 정보 추출: stat()                                      :minishell:
stat(), lstat(), fstat() 시스템 호출은 파일에 관한 정보를 추출하며, 대부분의 정보는 파일 i-노드에서 얻는다
#+begin_src C
  #include <sys/stat.h>

  // 성공하면 0을 리턴하고 에러가 발생하면 -1을 리턴한다
  int stat(const char *pathname, struct stat *statbuf);
  int lstat(const char *pathname, struct stat *statbuf);
  int fstat(int fd, struct stat *statbuf);
#+end_src
**** 세가지 시스템호출(stat(), lstat(), fstat())의 차이점
파일이 명시된 방법만 다르다

- stat(): 명명된 파일에 관한 정보를 리턴한다
- lstat(): stat()와 유사하지만 명명된 파일이 심볼릭 링크인 경우, 링크가 가리키는 정보 대신에 링크 자체에 대한 정보가 리턴된다
- fstat(): 열린 파일 디스크립터에 의해 참조된 파일에 관한 정보를 리턴한다

stat()와 lstat() 시스템 호출은 파일 자체에 권한을 요구하지 않는다.
하지만 실행(검색)권한은 'pathname'에 명시된 모든 부모 디렉터리에서 요구된다.
반면 fstat()은 유효한 파일 디스크립터를 제공한다면 항상 성공적으로 리턴한다
**** stat 구조체
#+begin_src C
  struct stat {
    dev_t st_dev; /* 파일이 위치한 디바이스 ID */
    ino_t st_ino; /* 파일의 i-노드 수 */
    mode_t st_mode; /* 파일 형식과 권한 */
    nlink_t st_nlink; /* 파일의 (하드) 링크 수 */
    uid_t st_uid; /* 파일 소유자의 사용자 ID */
    gid_t st_gid; /* 파일 소유자의 그룹 ID */
    dev_t st_rdev; /* 디바이스 특정 파일의 ID */
    off_t st_size; /* 파일의 전체 크기(바이트) */
    blksize_t st_blksize; /* I/O의 최적 블록 크기(바이트) */
    blkcnt_t st_blocks; /* 할당된 블록의 수 (512B) */
    time_t st_atime; /* 마지막 파일 접근 시간 */
    time_t st_mtime; /* 마지막 파일 수정 시간 */
    time_t st_ctime; /* 마지막 상태 변경시간 */
#+end_src
*** 파일 타이스탬프
**** utime()과 utimes()을 이용한 파일 타임스탬프 변경
**** ultimensat()과 futimens()를 이용한 파일 타임스탬프 변경
*** 파일 소유권
**** 새로운 파일의 소유권
**** 파일 소유권 변경: chown(), fchown(), lchown()
*** 파일 권한
**** 일반 파일에 대한 권한
'stat' 구조체의 'st_mode' 필드의 마지막 12비트는 파일의 권한을 정의한다
이 비트의 처음 세 비트는 'set-user-ID', 'set-group-ID', 스티키 비트로 알려진 특별한 비트다
남은 9 비트는 파일에 접근하는 여러 범주의 사용자에게 허용되는 권한을 정의하는 마스크를 형성한다

파일 권한은 마스크는 세 가지로 구본된다
- 소유자(사용자): 파일이 소유자에게 허용된 권한
- 그룹: 파일 그룹 멤버인 사용자에게 허용된 권한
- 기타: 그 외의 모든 사용자에게 허용된 권한
각 사용저 범주에는 다음의 권한이 나누어진다
- 읽기: 파일의 내용을 읽는 권한
- 쓰기: 파일의 내용을 변경하는 권한
- 실행: 파일을 실행하는 권한(즉 프로그램 또는 스크립트)
  스크립트 파일을 실행하기 위해서는 읽기와 실행 권한이 요구된다

특정 권한 비트가 설정되어 있는지 확인하기 위해 ~<sys/stat.h>~ 헤더 파일은 'stat' 구조체의 'st_mode'로 AND(&) 될 수 있는 상수를 정의한다
(이런 상수는 open() 시스템 호출 정의가 포함된 ~<fcntl.h>~을 포함함으로써 정의된다)
**** 디렉토리에 대한 권한
디렉토리에 대한 권한은 다르게 해석된다

- 읽기: 디렉토리의 내용(파일이름의 목록)을 나열할 수 있다
- 쓰기: 디렉토리에서 파일을 생성하고 제거할 수 있다. 파일을 삭제하기 위해서 파일 자체에 어떤 권한을 가질 필요는 없다
- 실행: 디렉토리 내의 파일에 접근할 수 있다. 디렉토리에서 실행 권한은 검색권한이라고도 한다

디렉토리에서 읽기 권한은 단지 디렉토리 내의 파일이름 목록을 볼 수 있게 해줄 뿐이다.
디렉토리의 내용이나 파일의 i-노드 정보에 접근하려면 디렉토리에서 실행 권한이 필요하다
**** 권한 검사 알고리즘
**** 파일 접근권 검사 access()                                 :minishell:
**** set-user-ID, set-group-ID, 스티키 비트
**** 프로세스 파일 모드 생성 마스크: umask()
**** 파일 권한 변경: chmod()와 fchmod()
*** i-노드 플래그(ext2 확장 파일 속성)
*** 정리
** 16장 확장속성
** 17장 ACL
** 18장 디렉토리와 링크
*** 디렉토리와 (하드) 링크
*** 심볼릭(소프트) 링크
*** (하드) 링크 생성과 제거: link()와 unlink()                  :minishell:
*** 파일이름 변경: rename()
*** 심볼릭 링크 관련 작업: symlink()와 readlink()
*** 디렉토리 생성과 제거: mkdir()와 rmdir()
*** 파일이나 디렉토리 제거: remove()
*** 디렉토리 읽기: opendir()와 readdir()                        :minishell:
*** 파일트리검색: nftw()
*** 프로세스의 현재 작업 디렉토리                               :minishell:
*** 디렉토리 파일 식별자 관련 작업 운용
*** 프로세스의 루트 디렉토리 변경: chroot()
*** 경로명 결정: realpath()
*** 경로명 문자열 파싱: dirname()과 basename()
*** 정리
** 19장 파일 이벤트 감시
** 20장 시그널: 기본개념
*** 개념과 개요
*** 시그널 형식과 기본 동작
*** 시그널 속성 변경: signal()                                  :minishell:
*** 시그널 핸들러 소개
*** 시그널 전송: kill()                                         :minishell:
*** 프로세스 존재 여부 검사
*** 시그널을 보내는 그 밖의 방법: raise()와 killpg()
*** 시그널 설명 출력
*** 시그널 집합                                                 :minishell:
*** 시그널 마스크(시그널 전달 블록)
*** 보류 중인 시그널
*** 시그널은 큐에 들어가지 않는다
*** 시그널 속성 변경: sigaction()                               :minishell:
*** 시그널 대기: pause()
*** 정리
** 21장 시그널: 시그널 핸들러
** 22장 시그널: 고급 기능
** 23장 타이머와 수면
** 24장 프로세스 생성
*** fork(), exit(), wait(), execve() 소개
*** 새 프로세스의 생성: fork()                                  :minishell:
**** 부모와 자식 프로세스 간의 파일 공유
**** fork()의 메모리 시맨틱
*** vfork() 시스템 호출
*** fork() 후의 경쟁 상태
*** 시그널 동기를 통한 경쟁 상태 회피
*** 정리
** 25장 프로세스 종료
*** 프로세스 종료하기: _exit()와 exit()                         :minishell:
*** 프로세스 종료 자세히 들여다보기
*** 종료 핸들러
*** fork(), stdio 버퍼, _exit()의 상호작용
*** 정리
** 26장 자식 프로세스 감시
*** 자식 프로세스 기다리기
**** wait() 시스템 호출                                        :minishell:
**** waitpid() 시스템 호출                                     :minishell:
**** 대기 상태 값
**** 시그널 핸들러로부터 프로세스 종료
**** waitid() 시스템 호출
**** wait3()와 wait4() 시스템 호출
*** 고아와 좀비 프로세스
*** SIGCHLD 시그널
**** SIGCHLD 핸들러 설치
**** 중지된 자식에 대한 SIGCHLD 전달
**** 죽은 자식 프로세스 무시하기
*** 정리
** 27장 프로그램 실행
*** 새 프로그램 실행하기: execve()                              :minishell:
*** exec() 라이브러리 함수
**** PATH 환경 변수
**** 프로그램 인자를 리스트로 지정하기
**** 호출한 프로세스의 환경을 새 프로그램에 전달하기
**** 디스크립터가 가리키는 파일 실행하기: fexecve()
** 28장 더 자세히 살펴보는 프로세스 생성과 프로그램 실행
** 29장 프로세스 그룹, 세션, 작업 제어
** 30장 프로세스 우선순위와 스케줄링
** 31장 프로세스 자원
** 32장 데몬
** 33장 안전한 특권 프로그램 작성
** 34장 능력
** 35장 로그인 계정
** 36장 공유 라이브러리 기초
** 37장 공유라이브러리의 고급 기능
* 고급 리눅스 API
** 1장 스레드: 소개
** 2장 스레드: 스레드 동기화
** 3장 스레드: 스레드 안정성과 스레드별 저장소
** 4장 스레드: 스레드 취소
** 5장 스레드: 기타 세부사항
** 6장 프로세스 간 통신 개요
** 7장 파이프와 FIFO
*** 개요
*** 파이프 만들기와 사용하기                                    :minishell:
*** 파이프로 프로세스 동기화하기
*** 필터 연결에 파이프 사용하기
*** 파이프를 사용해 셸 명령과 대화하기: popen()
*** 파이프와 stdio 버퍼링
*** FIFO
*** FIFO를 사용하는 클라이언트/서버 응용 프로그램
*** 비블로킹 I/O
*** 파이프와 FIFO에서 read()와 write() 함수의 의미
*** 정리
** 8장 시스템 Ⅴ IPC 소개
** 9장 시스템 Ⅴ 메시지 큐
** 10장 시스템 Ⅴ 세마포어
** 11장 시스템 Ⅴ 공유 메모리
** 12장 메모리 매핑
** 13장 가상 메모리 오퍼레이션
** 14장 POSIX IPC 소개
** 15장 POSIX 메시지 큐
** 16장 POSIX 세마포어
** 17장 POSIX 공유 메모리
** 18장 파일 잠금
** 19장 소켓: 소개
** 20장 소켓: 유닉스 도메인
** 21장 소켓: TCP/IP 네트워크 기초
** 22장 소켓: 인터넷 도메인
** 23장 소켓: 서버 설계
** 24장 소켓: 고급 옵션
** 25장 터미널
*** 개요
*** 터미널 속성값 읽기와 수정                                   :minishell:
*** stty 명령
*** 터미널 특수문자
*** 터미널 플래그
*** 터미널 I/O 모드
**** 정규 모드
**** 비정규 모드
**** cooked, cbreak, raw 모드
*** 터미널 라인 속도(비트 전송률)
*** 터미널 라인 제어
*** 터미널 윈도우 크기
*** 터미널 식별                                                 :minishell:
*** 정리
** 26장 대체 I/O 모델
** 27장 가상 터미널
