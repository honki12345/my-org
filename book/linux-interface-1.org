* 기초 리눅스 API
** 1장 역사와 표준
*** 유닉스와 C의 간략한 역사
*** 리눅스의 간략한 역사
**** GNU 프로젝트
**** 리눅스 커널
*** 표준화
**** C 프로그래밍 언어
**** 최초의 POSIX 표준
**** X/Open Company와 오픈그룹
**** SUSv3와 POSIX.1-2001
**** SUSv4와 POSIX.1-2008
**** 유닉스 표준 연대표
**** 구현표준
**** 리눅스, 표준, 리눅스 스탠더드 베이스
*** 정리
** 2장 기본개념
*** 핵심 운영체제: 커널
*** 셸
*** 사용자와 그룹
*** 단일 디렉토리 계층구조, 디렉토리, 링크, 파일
*** 파일 I/O 모델
*** 프로그램
*** 프로세스
*** 메모리 매핑
*** 정적 라이브러리와 공유 라이브러리
*** 프로세스 간 통신과 동기화
*** 시그널
*** 스레드
*** 프로세스 그룹과 셸 작업 제어
*** 세션, 제어 터미널, 제어 프로세스
*** 가상 터미널
*** 날짜와 시간
*** 클라이언트/서버 아키텍처
*** 실시간
*** /proc 파일 시스템
*** 정리
** 3장 시스템 프로그래밍 개념
*** 시스템 호출
*** 라이브러리 함수
*** 표준 C 라이브러리: GNU C 라이브러리(glib)
*** 시스템 호출과 라이브러리 함수의 에러 처리                   :minishell:
시스템 호출이 실패하면 전역 정수 변수 'errno'를 특정 에러를 나타내는 양수로 설정한다.
헤더 파일 '<errno.h>을 사용하면 'errno' 선언 뿐만 아니라 다양한 에러 상수도 포함된다.
각 메뉴얼 'ERROS' 세션에는 각 시스템 호출이 리턴할 수 있는 'errno' 값의 목록이 나와 있다.

에러를 확인할 때는 언제나 함수의 리턴 값이 에러를 나타내는지를 확인하고, 그 경우에만 'errno'을 통해 에러의 원인을 찾아야 한다.
또는 호출 전에 'errno'을 0으로 설정하고, 호출 후에 다시 확인한다
**** perror()
#+begin_src C
  #include <stdio.h>

  void perror(const char *msg);
#+end_src

The 'perror()' function produces a message on standard error describing the last error encountered during a call to system or library function.
First (if 's' is not NULL and *s is not a null byte ('\0')),
the argument string 's' is printed, followed by a colon and a blank.
Then an error message corresponding to the current value of 'errno' and a new-line.
**** strerror()
#+begin_src C
  #include <string.h>

  char *strerror(int errnum);
#+end_src
'strerror()' 함수는 인자 'errnum'으로 주어진 에러 번호에 해당하는 에러 문자열을 리턴한다.
'strerror()'가 리턴한 문자열은 정적으로 할당되어 있을 수 있으므로, 이후의'strerror()'에 의해 다른 값으로 바뀔 수 있다.
'errnum'이 알 수 없는 에러 번호를 담고 있으면, 'strerror()'는 'Unknown error nnn'이라는 형태의 문자열을 리턴한다.
어떤 구현에서는 이런 경우 'strerror()'가 NULL을 리턴하기도 한다
*** 이 책의 예제 프로그램
**** 명령행 옵션과 인자
**** 공통 함수와 헤더 파일
*** 이식성 이슈
**** 기능 테스트 매크로
**** 시스템 데이터형
**** 기타 이식성 이슈
*** 정리
** 4장 파일 I/O: 범용 I/O 모델
*** 개요
I/O를 수행하는 모든 시스템 호출은 파일 디스크립터라는 음이 아닌 정수를 통해 열려 있는 파일을 참조한다.
파일 디스크립터는 파이프, FIFO, 소켓, 터미널, 디바이스, 일반 파일 등 종류에 상관없이 모든 열려 있는 파일을 참조할 때 쓴다
셸은 보통 세가지 파일 디스크립터가 언제나 열려 있는 채로 동작한다 (대화형 셸에서 이 세가지 파일 디스크립터는 셸이 동작중인 터미널을 가리킨다)
프로그램은 셸의 디스크립터의 복사본을 물려 받는다
명령행에서 I/O을 재지정하면 셸은 프로그램을 시작하기 전에 파일 디스크립터가 적절히 수정되도록 보장한다.

**** 파일 I/O을 수행하는 네가지 핵심 시스템 호출
***** `fd = open(pathname, flags, mode)`
`pathname`이 가리키는 파일을 열고, 열린 파일을 이후의 호출에서 참조할 때 쓸 파일 디스크립터를 리턴한다.
해당 파일이 존재하면 `flags`의 값에 따라 `open()`이 만들 수도 있다.
`flags`는 또한 파일을 읽기, 쓰기, 둘 다를 위해 열지를 지정한다.
`mode`는 파일을 만들 경우 파일에 부여할 권한을 지정한다.
`open()`는 파일을 만들지 않을 경우, 이 인자는 무시되므로 생략할 수 있다.
***** `numread = read(fd, buffer, count)`
`fd`가 가리키는 파일에서 최대 `count` 바이트를 읽어 `buffer`에 저장한다.
`read()`는 실제로 읽은 바이트 수를 리턴한다.
더 이상 읽을 수 없으면 (즉, 파일의 끝을 만나면) `read()`는 0을 리턴한다.
***** `numwritten = write(fd, buffer, count)`
`buffer`에서 최대 `count` 바이트를 `fd`가 열려 있는 파일에 쓴다.
`write()`는 실제로 쓴 바이트 수를 리턴하므로, `count`보다 작은 수를 리턴할 수 있다
***** `status = close(fd)`
모든 I/O를 마친 뒤에 파일 디스크립터 `fd`와 관련 커널 자원을 해제하기 위해 호출한다
*** I/O의 범용성
네가지 시스템 호출(`open(), read(), write(), close()`)이 터미널 같은 디바이스를 포함해 모든 종류의 파일에 대한 I/O를 수행한다.
따라서 이 시스템 호출만으로 프로그램을 작성하면, 어떤 종류의 파일에 대해서도 동작할 것이다.
이러한 I/O의 범용성은 각 파일 시스템과 드라이버가 같은 종류의 I/O 시스템 호출을 구현함으로써 가능해졌다.
파일 시스템이나 디바이스 특유의 기능을 써야할 때는 다목적 시스템 호출인 `ioctl()`를 사용할 수 있다.
*** 파일 열기: open()                                           :minishell:
#+begin_src C
  #include <sys/stat.h>
  #include <fcntl.h>

  // flags는 파일 접근모드, mode는 파일 권한(새로운 파일 만들 때)
  int open(const char *pathname, int flags, ... /* mode_t mode */);
#+end_src
 `open()` 시스템 호출은 기존 파일을 열거나 새로운 파일을 만들고 연다.
`pathname`이 가리키는 파일을 연다. `pathname`이 심볼릭 링크면 역참조한다.
성공하면 `open()`은 파일 디스크립터를 리턴하며, 이후의 시스템 호출에서는 이 파일 디스크립터를 통해 해당 파일을 참조할 수 있다.
에러가 발생하면 `open()`은 -1을 리턴하고 그에 맞춰 `errno`가 설정된다.
 `flags` 인자는 *파일 접근모드*를 지정하는 비스마스크다.
 `open()`으로 새로운 파일을 만들 때는 `mode` 비트 마스크 인자로 *파일 권한*을 설정한다.
`open()` 호출에 `O_CREAT`를 지정하지 않으면 `mode`는 생략해도 된다.



**** open()의 flags 인자
**** open()의 에러
**** creat() 시스템 호출
*** 파일 읽기: read()
*** 파일에 쓰기: write()                                        :minishell:
*** 파일 닫기: close()                                          :minishell:
*** 파일 오프셋 변경: lseek()
*** 범용 I/O 모델 외의 오퍼레이션: ioctl()                      :minishell:
*** 정리
** 5장 파일 I/O: 더 자세히
*** 원자성과 경쟁 상태
*** 파일 제어 오퍼레이션: fcntl()
*** 파일 상태 플래그 열기
*** 파일 디스크립터와 열려 있는 파일의 관계
*** 파일 디스크립터 복사하기                                    :minishell:
*** 지정된 오프셋에서의 파일 I/O: pread()와 pwrite()
*** 스캐터-개더 I/O: readv()와 writev()
*** 파일 잘라내기: truncate()와 ftruncate()
*** 비블로킹 I/O
*** 큰 파일에 대한 I/O
*** '/dev/fd' 디렉토리
*** 임시파일 만들기
*** 정리
** 6장 프로세스
*** 프로세스와 프로그램
*** 프로세스 ID와 부모 프로세스 ID
*** 프로세스의 메모리 레이아웃
*** 가상 메모리 관리
*** 스택과 스택 프레임
*** 명령행 인자(argc, argv)
*** 환경 변수 목록                                              :minishell:
*** 비지역 goto 수행: setjmp()와 longjmp()
*** 정리
** 7장 메모리 할당
*** 힙에 메모리 할당하기
**** 프로그램 브레이크 조정하기: brk()와 sbrk()
**** 힙에 메모리 할당하기: malloc()와 free()                   :minishell:
**** malloc()과 free()의 구현
**** 힙에 메모리를 할당하는 그 밖의 방법
*** 스택에 메모리 할당하기: alloca()
*** 정리
** 8장 사용자와 그룹
** 9장 프로세스 자격증명
** 10장 시간
** 11장 시스템 한도와 옵션
** 12장 시스템과 프로세스 정보
** 13장 파일 I/O 버퍼링
** 14장 파일 시스템
** 15장 파일 속성
*** 파일 정보 추출: stat()                                      :minishell:
*** 파일 타이스탬프
**** utime()과 utimes()을 이용한 파일 타임스탬프 변경
**** ultimensat()과 futimens()를 이용한 파일 타임스탬프 변경
*** 파일 소유권
**** 새로운 파일의 소유권
**** 파일 소유권 변경: chown(), fchown(), lchown()
*** 파일 권한
**** 일반 파일에 대한 권한
**** 디렉토리에 대한 권한
**** 권한 검사 알고리즘
**** 파일 접근권 검사 access()                                 :minishell:
**** set-user-ID, set-group-ID, 스티키 비트
**** 프로세스 파일 모드 생성 마스크: umask()
**** 파일 권한 변경: chmod()와 fchmod()
*** i-노드 플래그(ext2 확장 파일 속성)
*** 정리
** 16장 확장속성
** 17장 ACL
** 18장 디렉토리와 링크
*** 디렉토리와 (하드) 링크
*** 심볼릭(소프트) 링크
*** (하드) 링크 생성과 제거: link()와 unlink()                  :minishell:
*** 파일이름 변경: rename()
*** 심볼릭 링크 관련 작업: symlink()와 readlink()
*** 디렉토리 생성과 제거: mkdir()와 rmdir()
*** 파일이나 디렉토리 제거: remove()
*** 디렉토리 읽기: opendir()와 readdir()                        :minishell:
*** 파일트리검색: nftw()
*** 프로세스의 현재 작업 디렉토리                               :minishell:
*** 디렉토리 파일 식별자 관련 작업 운용
*** 프로세스의 루트 디렉토리 변경: chroot()
*** 경로명 결정: realpath()
*** 경로명 문자열 파싱: dirname()과 basename()
*** 정리
** 19장 파일 이벤트 감시
** 20장 시그널: 기본개념
*** 개념과 개요
*** 시그널 형식과 기본 동작
*** 시그널 속성 변경: signal()                                  :minishell:
*** 시그널 핸들러 소개
*** 시그널 전송: kill()                                         :minishell:
*** 프로세스 존재 여부 검사
*** 시그널을 보내는 그 밖의 방법: raise()와 killpg()
*** 시그널 설명 출력
*** 시그널 집합                                                 :minishell:
*** 시그널 마스크(시그널 전달 블록)
*** 보류 중인 시그널
*** 시그널은 큐에 들어가지 않는다
*** 시그널 속성 변경: sigaction()                               :minishell:
*** 시그널 대기: pause()
*** 정리
** 21장 시그널: 시그널 핸들러
** 22장 시그널: 고급 기능
** 23장 타이머와 수면
** 24장 프로세스 생성
*** fork(), exit(), wait(), execve() 소개
*** 새 프로세스의 생성: fork()                                  :minishell:
**** 부모와 자식 프로세스 간의 파일 공유
**** fork()의 메모리 시맨틱
*** vfork() 시스템 호출
*** fork() 후의 경쟁 상태
*** 시그널 동기를 통한 경쟁 상태 회피
*** 정리
** 25장 프로세스 종료
*** 프로세스 종료하기: _exit()와 exit()                         :minishell:
*** 프로세스 종료 자세히 들여다보기
*** 종료 핸들러
*** fork(), stdio 버퍼, _exit()의 상호작용
*** 정리
** 26장 자식 프로세스 감시
*** 자식 프로세스 기다리기
**** wait() 시스템 호출                                        :minishell:
**** waitpid() 시스템 호출                                     :minishell:
**** 대기 상태 값
**** 시그널 핸들러로부터 프로세스 종료
**** waitid() 시스템 호출
**** wait3()와 wait4() 시스템 호출
*** 고아와 좀비 프로세스
*** SIGCHLD 시그널
**** SIGCHLD 핸들러 설치
**** 중지된 자식에 대한 SIGCHLD 전달
**** 죽은 자식 프로세스 무시하기
*** 정리
** 27장 프로그램 실행
*** 새 프로그램 실행하기: execve()                              :minishell:
*** exec() 라이브러리 함수
**** PATH 환경 변수
**** 프로그램 인자를 리스트로 지정하기
**** 호출한 프로세스의 환경을 새 프로그램에 전달하기
**** 디스크립터가 가리키는 파일 실행하기: fexecve()
** 28장 더 자세히 살펴보는 프로세스 생성과 프로그램 실행
** 29장 프로세스 그룹, 세션, 작업 제어
** 30장 프로세스 우선순위와 스케줄링
** 31장 프로세스 자원
** 32장 데몬
** 33장 안전한 특권 프로그램 작성
** 34장 능력
** 35장 로그인 계정
** 36장 공유 라이브러리 기초
** 37장 공유라이브러리의 고급 기능
* 고급 리눅스 API
** 1장 스레드: 소개
** 2장 스레드: 스레드 동기화
** 3장 스레드: 스레드 안정성과 스레드별 저장소
** 4장 스레드: 스레드 취소
** 5장 스레드: 기타 세부사항
** 6장 프로세스 간 통신 개요
** 7장 파이프와 FIFO
*** 개요
*** 파이프 만들기와 사용하기                                    :minishell:
*** 파이프로 프로세스 동기화하기
*** 필터 연결에 파이프 사용하기
*** 파이프를 사용해 셸 명령과 대화하기: popen()
*** 파이프와 stdio 버퍼링
*** FIFO
*** FIFO를 사용하는 클라이언트/서버 응용 프로그램
*** 비블로킹 I/O
*** 파이프와 FIFO에서 read()와 write() 함수의 의미
*** 정리
** 8장 시스템 Ⅴ IPC 소개
** 9장 시스템 Ⅴ 메시지 큐
** 10장 시스템 Ⅴ 세마포어
** 11장 시스템 Ⅴ 공유 메모리
** 12장 메모리 매핑
** 13장 가상 메모리 오퍼레이션
** 14장 POSIX IPC 소개
** 15장 POSIX 메시지 큐
** 16장 POSIX 세마포어
** 17장 POSIX 공유 메모리
** 18장 파일 잠금
** 19장 소켓: 소개
** 20장 소켓: 유닉스 도메인
** 21장 소켓: TCP/IP 네트워크 기초
** 22장 소켓: 인터넷 도메인
** 23장 소켓: 서버 설계
** 24장 소켓: 고급 옵션
** 25장 터미널
*** 개요
*** 터미널 속성값 읽기와 수정                                   :minishell:
*** stty 명령
*** 터미널 특수문자
*** 터미널 플래그
*** 터미널 I/O 모드
**** 정규 모드
**** 비정규 모드
**** cooked, cbreak, raw 모드
*** 터미널 라인 속도(비트 전송률)
*** 터미널 라인 제어
*** 터미널 윈도우 크기
*** 터미널 식별                                                 :minishell:
*** 정리
** 26장 대체 I/O 모델
** 27장 가상 터미널
