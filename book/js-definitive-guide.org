#+title: Js Definitive Guide

* 자바스크립트 완벽 가이드
*** 서문
이 책의 목표는 자바스크립트 언어를 포괄적이고 완벽하게 문서화하고, 자바스크립트 프로그램에서 사용할 수 있는 클라이언트 및 서버사이드 API를 자세히 소개하는 것입니다

책을 읽다가 코어 자바스크립트 또는 클라이언트 사이드 자바스크립트에 대해 찾아보고 싶다면 MDN 웹사이트를 추천합니다
서버 사이드 노드 API에 궁금한 것이 있다면 노드 참조 문서를 추천합니다
** 자바스크립트 소개
자바스크립트는 웹의 프로그래밍 언어입니다

ECMAScript 명세는 ES6을 마지막으로, 버전번호 대신 년도를 사용하기로 결정했습니다
(e.g. ES2016, ES2017, ES2018 ...)

하위 호환성 유지 문제 때문에 제거할 수 없는 구식 기능이 있습니다
- ES5 이후 버전에서는 초기 버전의 실수를 대부분 해결한 스트릭트 모드를 사용할 수 있습니다
- ES6 이후에는 새로운 기능을 사용할 때 묵시적으로 스트릭트 모드에 진입하는 경우가 잦습니다
  (e.g. class 키워드[클래스 내부 코드], ES6 모듈[모듈 내부 코드])

자바스크립트 코어에는 입출력에 관한 부분은 정의되어 있지 않습니다
- 입출력, 네트워크, 스토리지, 그래픽 같은 기능은 자바스크립트가 임베드된 '호스트 환경'이 담당합니다
  - 웹브라우저 환경: 사용자의 마우스와 키보드 입력을 받고 HTTP 요청을 보내고 HTML과 CSS 표시
  - 노드: 운영체제 전체에 접근해 파일을 읽고 쓰고, 네트워크를 통해 데이터 송수신, HTTP 요청을 보내고 받기

이 장은 소개 목적이므로 이어질 장을 이해하는 데 필수적인 핵심 기능을 간단히 훑어 나가기만 합니다
*** 자바스크립트 탐험
*** Hello World
*** 자바스크립트 여행
객체는 문자열과 값의 연결입니다
- 객체의 프로퍼티는 . 또는 []로 접근합니다
- 할당을 통해 프로퍼티를 새로 만들 수 있습니다


자바스크립트는 배열, 즉 *숫자로 인덱스된* 리스트도 지원합니다


자바스크립트에서 표현식이란 어떤 값으로 평가(evaluate)되는 구절입니다


표현식은 값을 계산할 뿐 프로그램의 상태를 바꾸지 않습니다
문은 값을 갖지 않지만 프로그램의 상태를 바꿉니다
- 변수 이름 역시 표현식입니다


함수(function)는 한 번 정의하면 몇 번이고 호출할 수 있는, 이름이 있고 매개변수를 받을 수 있는 자바스크립트 코드 블록입니다


객체와 함께 사용하는 함수를 *메서드*라고 부릅니다
- 객체 프로퍼티로 할당된 함수를 메서드라고 부릅니다
- 자바스크립트의 객체는 모두 (배열도 포함하여 ) 메서드를 갖습니다


"this" 키워드는 메서드를 정의하는 대상 객체입니다
*** 예제: 글자 빈도 히스토그램
*** 요약
** 어휘구조
어휘구조는 그 언어로 프로그램을 작성할 때 지켜야 할 기본적인 규칙의 집합입니다
- 대소문자 구분, 스페이스, 줄바꿈
- 주석
- 리터럴
- 식별자와 예약어
- 유니코드
- (선택사항)세미콜론
*** 자바스크립트 프로그램의 텍스트
자바스크립트는 토큰 사이의 공백을 무시합니다
- 자바스크립트는 일반적인 스페이스 문자(~\u0020~) 외에 탭, ASCII 제어문자, 다양한 유니코드 스페이스 문자를 모두 공백으로 인식합니다
*** 주석
*** 리터럴
리터럴은(literal)은 프로그램 안에 직접 쓴 데이터 값입니다
*** 식별자와 예약어
식별자는 상수, 변수, 프로퍼티, 함수, 클래스, 루프의 라벨로 사용합니다

식별자 규칙
- 시작
  - 글자(알파벳 권장)
  - 밑줄(`_`)
  - 달러기호($)
- 나머지
  - 글자, *숫자*, 밑줄, 달러기호
첫 자리에 숫자를 허용하지 않는 이유는 식별자와 숫자를 쉽게 구별하기 위해서입니다
*** 유니코드
자바스크립트 프로그램은 유니코드 문자셋으로 작성됩니다
**** 유니코드 이스케이프 시퀀스
이스케이프 시퀀스
- ASCII 문자만으로 유니코드를 표현
- `\u` 문자로 시작하고 그 뒤에 16진수 숫자를 4개 사용하거나 중괄호 안에 1~6개 사용가능
- 자바스크립트 문자열 리터럴, 정규표현식 리터럴, 식별자에 사용할 수 있습니다
**** 유니코드 정규화
유니코드에 그 문자를 인코딩 방법이 하나 이상 있음을 인지해야합니다
- e.g. é
  - 단일 유니코드 ~\u00E9~
  - ASCII문자 e + 악센트 조합기호 ~\u0301~

유니코드 정규화 과정
- 유니코드 표준에는 모든 문자에 대해 선호하는 인코딩이 있다
- 텍스트를 비교에 적합한 정식(canonical) 형태로 변환

자바스크립트는 해석하고 있는 소스코드가 이미 정규화를 마친 상태라고 가정
- 스스로 정규화를 수행하지 않는다
- 자바스크립트 프로그램에서 유니코드 문자를 쓸 계획이라면 소스코드를 따로 유니코드 정규화해야한다
*** 선택사항인 세미콜론
자바스크립트는 세미콜론(;)을 사용해 *문*을 구분합니다

자바스크립트는 두 문 사이에 *줄바꿈*이 있을 때는 *대부분* 세미콜론을 생략해도 됩니다
- 프로그램 끝에서도 생략할 수 있음
- 그 다음 토큰이 닫는 중괄호(})일 때도 생략할 수 있음

자바스크립트가 줄바꿈을 *전부* 세미콜론으로 취급하지 않습니다
자바스크립트가 줄바꿈을 세미콜론으로 취급하는 경우
- 줄바꿈 다음에 오는 공백 아닌 문자를 현재 문에 이어진다고 판단할 수 없을 때 줄바꿈을 세미콜론으로 취급
  - 3가지 예외
    - ~return, throw, yield, break, continue~ 문
    - ~++~, ~--~ 연산자
    - 화살표 함수 ~=>~
- 일반적으로 문이 ~(, [, /, +~로 시작한다면 그 문은 이전 문이 계속되는 것으로 해석될 가능성이 있습니다
*** 요약
** 타입, 값, 변수
*** 개요와 정의
자바스크립트 타입은 기본타입과 객체타입으로 나뉩니다

기본타입
- 숫자
- 문자열
- 불(boolean)
- null
- undefined
- symbol
객체타입
- 기본타입이 아닌 모든 것

객체
- 프로퍼티의 집합
- 종류
  - 일반적인 객체: 이름 붙은 값의 *순서 없는* 집합
  - 배열: 숫자가 붙은 값의 *순서 있는* 집합
  - Set: 값의 집합
  - Map: 키와 값의 연결
  - 형식화배열: 바이트배열과 다른 *이진데이터* 연결
  - RegExp: 텍스트 패턴
  - Date: 날짜와 시간 표현
  - Error:
  - 함수:
  - 클래스:

 자바스크립트의 기본 타입은 불변(immutable)이고 객체 타입은 가변(mutable)입니다
*** 숫자
숫자타입 Number은 정수와 함께 실수를 대략적으로 표현합니다

IEEE754 표준에서 정의하는 64비트 부동소수점 형식을 사용해 숫자를 표현합니다
- 배열인덱싱이나 비트연산자는 32비트 정수를 사용합니다

**** 정수 리터럴
16진수: ~0x~ ~0X~
2진수: ~0b~ ~0B~
8진수: ~0o~ ~0O~

**** 부동 소수점 리터럴
실수 또는 지수표기법으로 표현할 수 있습니다
- 지수표기법은 실수에 10의 지수 승을 곱하는 방식으로 표현합니다

**** 자바스크립트의 산술 연산
#+begin_src javascript
  Math.pow(2, 53)         // => 2의 53승
  Math.round(.6)        // => 1.0: 가장 가까운 정수로 반올림
  Math.ceil(.6)         // => 1.0: 정수로 올림
  Math.floor(.6)        // => 0.0: 정수로 올림
  Math.abs(-5)          // => 5: 절댓값
  Math.max(x,y,z)       // 인자 중 가장 큰 것을 반환
  Math.min(x,y,z)       // 가장 작은 인자를 반한합니다
  Math.random()
  Math.PI
  Math.E                // e: 자연 로그의 밑
  Math.sqrt(3)          // => 3**0.5: 3의 제곱근
  Math.pow(3, 1/3)      // => 3**(1/3): 3의 세제곱근
  Math.sin(0)
  Math.log(10)          // 10의 자연로그
  Math.log(100)/Math.LN10       // 100의 상용로그
  Math.log(512)/Math.LN2        // 512의 이진로그
  Math.exp(3)           // Math.E의 세제곱

  // ES6에서 추가된 함수들
  Math.cbrt(27)         // => 3: 세제곱근
  Math.hypot(3,4)       // => 5: 인자의 제곱의 합의 제곱근
  Math.log10(100)       // => 2: 상용로그
  Math.log2(1024)       // => 10: 이진로그
  Math.expm1(x)         // Math.exp(x)-1
  Math.sign(x)          // 인자의 부호에 따라 -1, 0, 1을 반환
  Math.imul(2,3)        // => 6: C언어의 방식을 차용한 32비트 정수의 곱셈
  Math.clz32(0xf)       // => 28: 32비트 정수에서 맨 앞의 0비트 개수
  Math.trunc(3.9)       // => 3: 소수점 아래를 잘라내어 정수로 변환
  Math.fround(x)        // 가장 가까운 32비트 부동소수점 숫자로 반올림
  Math.sinh(x)          // 하이퍼볼릭 사인
  Math.asinh(x)         // 하이퍼볼릭 아크사인
#+end_src

***** 에러
산술연산 과정에 0으로 나누거나, 오버플로, 언더플로가 발생해도 에러를 일으키지 않습니다

~Infinity~와 ~NaN~은 전역상수이며 이들은 ~Number~ 객체의 프로퍼티로도 존재합니다
****** Infinity, -Infinity
~Infinity~
- 오버플로(자바스크립트가 표현할 수 있는 가장 큰 숫자보다 큰 경우)

~-Infinity~
- 가장 큰 음수의 절댓값보다 큰 경우

무한한 값에 다른 숫자를 더하거나, 빼거나, 곱하거나, 나누더라도 결과는 여전히 무한한 값입니다 (부호는 바뀔 수 있습니다)
****** 언더플로
자바스크립트가 표현할 수 있는 가장 작은 숫자보다도 0에 가까울 때 0을 반환합니다

음수에서 언더플로가 일어나면 '음의 0'이라는 특별한 값을 반환합니다
- 이 값은 0과 거의 완전히 같으며 자바스크립트 프로그래머가 여기에 신경쓸 필요는 없습니다
****** 0으로 나누기
0이 아닌 값을 0으로 나누면 무한대 또는 음의 무한대를 반환합니다

0을 0으로 나누면 NaN를 반환합니다
****** NaN
- 0을 0으로 나누면 NaN를 반환합니다
- 무한대를 무한대로 나누기
- 음수의 제곱근을 구하기
- 숫자로 변환할 수 없는 피연산자에 산술연산자를 적용할 때
- NaN 값은 자기 자신을 포함해 어떤 값과도 같지 않습니다
  - ~x === NaN~ 을 쓸 수 없습니다
  - ~x != x~ 또는 ~Number.isNaN(x)~ 을 써야 합니다
****** Number.isFinite()
- 인자가 ~NaN~, ~Infinity~, ~-Infinity~ 가 아닐 때 true를 반환
- 전역함수 ~isFinite()~ 와는 다르게 첫번째 매개변수를 변환시키지 않음
****** Example
#+begin_src javascript
  Infinity                      // 표현하기엔 너무 큰 양수
  Number.POSITIVE_INFINITY      // 같은 값
  1/0                           // => Infinity
  Number.MAX_VALUE * 2          // => Infinity; 오버플로

  -Infinity                     // 표현하기엔 절댓값이 너무 큰 음수
  Number.NEGATIVE_INFINITY      // 같은 값
  -1/0                          // => -Infinity
  -Number.MAX_VALUE * 2         // => -Infinity

  NaN                           // 숫자가 아닌 값
  Number.NaN                    // NaN과 같은 값이며 표현만 다릅니다
  0/0                           // => NaN
  Infinity/Infinity             // => NaN

  Number.MIN_VALUE / 2          // => 0: 언더플로
  -Number.MIN_VALUE / 2         // => -0: 음의 0
  -1 / Infinity                 // => -0: 음의 0
  -0

  // 다음 Number 프로퍼티는 ES6에서 정의했습니다.
  Number.parseInt()             // 전역 함수 parseInt()와 같습니다
  Number.parseFloat()           // 전역 함수 parseFloat()과 같습니다.
  Number.isNaN(x)               // x는 NaN인가?
  Number.isFinite(x)            // x는 유한한 숫자인가?
  Number.isInteger(x)           // x는 정수인가?
  Number.isSafeInteger(x)       // x는 -(2**53)보다 크고 2**53보다 작은 정수인가?
  Number.MIN_SAFE_INTEGER
  Number.MAX_SAFE_INTEGER
  Number.EPSILON                // 2**-52: 숫자를 구별할 수 있는 가장 작은 차이
#+end_src
****** 음의 0
이 값은 일치 연산자(===)로 양의 0과 비교해도 true를 반환

#+begin_src javascript
  let zero = 0;                 // 일반적인 0
  let negz = -0;                // 음의 0
  zero === negz                 // => true: 0과 음의 0은 일치합니다.
  1/zero === 1/negz             // => false: Infinity와 -Inifinity는 일치하지 않습니다.
#+end_src
**** 이진 부동 소수점 숫자와 반올림 오류
자바스크립트의 IEEE 754 부동소수점 표현은 이진 표현이며, ~0.1~ 같은 단순한 숫자를 정확히 표현하지 못합니다

부동 소수점 근삿값 때문에 문제가 생긴다면 정수로 변환하는 것을 고려해보십시오
- 돈을 계산할 때 0.1 달러 대신 10센ㅌ로 계산하는 것입니다
**** BigInt로 임의 정확도를 부여한 정수
~BigInt~는 ES2020에서 정의한 기능입니다
- 값이 정수인 숫자 타입입니다
- 64비트 정수를 표현하기 위해 추가됐습니다
- 타이밍 공격을 방지 할 수 없으므로 암호화에는 사용할 수 없습니다

~BigInt~ 리터럴은 연속된 숫자 다음에 소문자 n을 붙인 형식입니다
- ~1234n~

~BigInt()~로 숫자나 문자열을 ~BigInt~로 변환할 수 있습니다

***** 연산자
~+, -, *, /, %, **~ 와 같은 표준 연산자를 쓸 수 있지만,
*일반적인 숫자* 피연산자를 섞어 쓸 수 없습니다

비교연산자는 일반적인 숫자를 피연산자로 섞어도 괜찮습니다
**** 날짜와 시간
~Date~ 클래스는 날짜와 시간에 대응하는 *숫자*를 표현하고 조작합니다
- ~Date~ 는 *타임스탬프* 인 숫자 표현을 가지고 있습니다
*** 텍스트
문자열
- 부호 없는 16비트 값이 *순서에 따라 이어진* 형태
- 기본값(primitive)이므로 불변입니다
- 길이(length)는 문자열에 포함된 16비트 값의 개수입니다
- 유니코드 문자셋의 UTF-16인코딩을 사용합니다


자바스크립트의 문자열 메서드는 대부분 문자가 아니라 *16비트 값* 단위로 동작합니다
- 문자열 메서드는 써로케이트 페어를 특별 취급하지 않습니다
- 따로 정규화하지도 않고,문자열이 정확한 UTF-16 형식인지 검사하지 않습니다


ES6에서 문자열은 이터러블(iterable)이고
for/of 루프나 ~...~ 연산자를 사용하면 16비트 값이 아닌 실제 문자를 순회합니다


문자열은 읽기 전용 배열로 취급할 수도 있으며
~charAt()~ 메서드 대신 대괄호를 써서 문자열의 개별문자(16비트 값)에 접근할 수 있습니다
**** 문자열 리터럴
보간(interpolation)
- 백틱으로 감싼 문자열
- ES6 기능
- 문자열 리터럴 안에 자바스크립트 표현식을 넣을 수 있다

#+begin_src javascript
  // 두 행을 한 행으로 표현했습니다.
  'two\nlines'

  // 한 행을 세 행으로 나눠 썼습니다.
  "one\
   long\
   line"

  // 두 행 문자열을 두 행에 나눠 썼습니다.
  `이 행의 마지막에 있는 줄바꿈 문자는
  있는 그대로 문자열의 일부입니다`
#+end_src

HTML도 문자열에 작은따옴표와 큰따옴표를 모두 쓸 수 있습니다
- 따라서 자바스크립트와 HTML을 섞어 쓸 때는 따옴표를 구분하는 규칙을 정해 두는게 좋습니다
#+begin_src html
  <button onclick="alert('Thank you')">Click Me</button>
#+end_src
**** 문자열 리터럴 안의 이스케이프 시퀀스
역슬래시는 그 다음 문자와 조합해서 일반적인 방법으로는 문자열에 표시할 수 없는 문자를 표현합니다

| 시퀀스 | 문자                                                |
|--------+-----------------------------------------------------|
| \xnn   | 16진수 숫자 두개 nn으로(인코딩) 표현하는 유니코드 문자    |
| \unnnn | 16진수 숫자 네 개 nnnn으로(인코딩) 표현하는 유니코드 문자 |
| \u{n}  | 코드포인트 n으로 표현하는 유니코드 문자                                              |
**** 문자열 다루기
연산자를 문자열에 쓰면 두번째 문자열을 첫번째 문자열 뒤에 이어 붙입니다

문자열 비교 `===`, `!==`
- 두 문자열이 정확히 같은 16비트 값의 연속으로 이루어졌을 때에 일치
- 문자열 비교는 16비트 값을 비교하는 방식으로 이루어집니다
**** 문자열 API
#+begin_src javascript
  let s = "Hello, world";       // 이 텍스트를 예제에 사용합니다.

  // 문자열의 일부를 가져옵니다.
  s.substring(1,4)              // => "ell": 두 번째, 세 번째, 네 번째 문자
  s.slice(1,4)                  // => "ell": 같은 결과입니다.
  s.split(", ")                 // => ["Hello", "world"] 구분자를 기준으로 나눕니다.

  // 문자열 검색
  s.indexOf("l")                // => 2: l이 처음 나타나는 위치
  s.indexOf("l", 3)             // => 3: 3번 문자부터 시작해 l이 처음 나타나는 위치
  s.indexOf("zz")               // => -1: s에는 zz라는 문자열이 들어 있지 않습니다.
  s.lastIndexOf("l")            // => 10: l이 마지막으로 나타나는 위치

  // 불을 반환하는 검색 함수는 ES6에서 추가됐습니다.
  s.startsWith("Hell")          // true: s는 Hell로 시작합니다.
  s.endsWith("!")               // false: s는 !로 끝나지 않습니다.
  s.includes("or")              // true: s에는 or이 들어 있습니다.

  // 문자열을 변경합니다.
  s.replace("llo", "ya")        // => "Heya, world"
  s.toLowerCase()               // => "hello, world"
  s.toUpperCase()               // => "HELLO, WORLD"
  s.normalize()                 // 유니코드 NFC 정규화는 ES6에서 추가됐습니다.
  s.normalize("NFD")            // NFD 정규화, NFKC, NFKD도 있습니다.

  // 문자열의 각 16비트 문자를 검사합니다.
  s.charAt(0)                   // => "H": 첫 번째 문자
  s.charAt(s.length-1)          // => "d": 마지막 문자
  s.charCodeAt(0)               // => 72: 주어진 위치의 16비트 숫자
  s.codePointAt(0)              // => 72: 16비트보다 큰 코드 포인트에서 동작하는 ES6 기능

  // 패딩 함수는 ES2017에서 추가됐습니다.
  "x".padStart(3)               // => "   x": 왼쪽에 스페이스를 두 개 더합니다.
  "x".padEnd(3)                 // => "x   ": 오른쪽에 스페이스를 두 개 더합니다
  "x".padStart(3, "*")          // => "**x": *를 왼쪽에 붙여 길이를 3에 맞춥니다
  "x".padEnd(3, "-")            // => "x--": -를 오른쪽에 붙여 길이를 3에 맞춥니다.

  // 공백 제거. trim()은 ES5, 나머지는 ES2019 기능입니다.
  " test ".trim()               // => "test": 앞뒤 공백을 제거합니다.
  " test ".trimStart()          // => "test ": 왼쪽 공백을 제거합니다. trimLeft도 있습니다.
  " test ".trimEnd()            // => " test": 오른쪽 공백을 제거합니다. trimRight도 있습니다.

  // 그 외의 문자열 메서드
  s.concat("!")                 // => "Hello, world!": + 연산자를 쓰는 게 더 간단합니다.
  "<>".repeat(5)                // => "<><><><><>": n번 복사합니다. ES6에서 추가됐습니다.
#+end_src
**** 템플릿 리터럴
백틱으로 둘러싼 문자열 리터럴의 최종값은
- 그 안에 포함된 표현식을 평가해서
- 그 표현식의 값을 문자열로 변환한 다음,
- 변환된 문자열을 백틱 안에 들어있는 리터럴 문자와 결합한 값으로 결정됩니다

***** 태그된 템플릿 리터럴
여는 백틱 바로 앞에 함수 이름(태그)이 있으면 템플릿 리터럴의 텍스트와 표현식 값이 함수에 전달됩니다
그리고 이 '태그된 템플릿 리터럴'의 값이 함수의 반환 값입니다
- 이 기능은 HTML이나 SQL을 텍스트에 붙이기 전에 이스케이프 하는 용도로 사용할 수 있습니다

**** 패턴 매칭
정규표현식(RegExp)
- 자바스크립트의 데이터 타입
  - 기본적인 데이터 타입은 아니지만 리터럴 문법이 있으므로 기본적인 데이터 타입처럼 보입니다
- 문자열 내부의 패턴을 정의하고 매칭합니다

***** 정규표현식 리터럴
슬래시 한 쌍 사이에 텍스트를 씁니다
두 번째 슬래시 뒤에도 글자 하나 이상 쓸 수 있으며 이 글자는 *패턴의 의미*를 수정합니다

#+begin_src javascript
  /^HTML/;                      // 문자열의 시작 부분에 있는 H T M L 에 일치합니다
  /[1-9][0-9]*/;                // 0이 아닌 숫자가 하나 있어야 하고 그 뒤의 숫자는 제한이 없습니다.
  /\bjavascript\b/i;            // javascript가 한 단어로 들어가야 하고 대소문자를 구분하지 않습니다.
#+end_src
***** 정규표현식 API
#+begin_src javascript
  let text = "testing: 1, 2, 3";                // 샘플 텍스트
  let pattern = /\d+/g;                         // 연속된 숫자 전체에 일치합니다.
  pattern.test(text)                            // => true: 패턴에 맞는 것이 있습니다.
  text.search(pattern)                          // => 9: 첫 번째로 일치하는 부분의 위치
  text.match(pattern)                           // => ["1", "2", "3"]: 일치하는 부분이 모두 포함된 배열
  text.replace(pattern, "#")                    // => "testing: #, #, #"
  text.split(/\D+/)                             // => ["", "1", "2", "3"]: 숫자 아닌 것에서 나눕니다.
#+end_src
*** 불 값
자바스크립트 값은 모두 불 값으로 변환될 수 있습니다

falsy
- undefined
- null
- 0
- -0
- NaN
- ""(빈 문자열)
truthy
- falsy 외에 모든 값
*** null과 undefined
~null~ 은 값이 없음을 나타낼 때 사용하는 값입니다

~null~에 ~typeof~ 연산자를 사용하면 문자열 "object"를 반환합니다
- 이를 미루어 ~null~은 '객체가 없다'라는 것을 나타내는 특별한 *객체* 값이라고 볼 수 있습니다
  - 객체뿐만 아니라 숫자나 문자열에도 '값이 없다'를 의미할 수 있습니다
- ~null~ 은 해당 타입의 유일한 멤버로 인식됩니다

~undefined~
- 초기화되지 않은 변수의 값
- 객체의 존재하지 않는 프로퍼티에 접근했을 때
- 존재하지 않는 배열요소에 접근했을 때
- 값을 명시적으로 반환하지 않는 함수의 반환 값
- 전달되지 않은 인자의 값

~undefined~ 는 미리 정의된 전역 상수이며, 그 값은 ~undefined~로 초기화됩니다
~undefined~ 에 ~typeof~ 연산자를 적용하면 문자열 "undefined"를 반환합니다
~undefined~ 는 특별한 타입이고 멤버는 그 하나뿐입니다
*** 심벌
심벌은 프로퍼티 이름으로 ES6에서 추가됐습니다

심벌 타입에는 리터럴 문법이 없습니다

심벌은 자바스크립트 언어를 확장하는 메커니즘
- 특정 문자열 이름을 표준화(메서드, 프로퍼티)하면 기존 코드가 깨질 수 있음
- ~Symbol()~ 를 호출해 심벌 값을 얻었다면 객체의 기존 프로퍼티를 같은 이름으로 *덮어 쓸 염려 없이* 그 값을 프로퍼티 이름으로 추가할 수 있습니다
**** 심벌 값
심벌 값(value)를 가져올 때는 ~Symbol()~ 함수를 호출합니다
- 이 함수는 같은 인자로 호출하더라도 다른 값을 반환합니다

~Symbol()~ 함수는 선택사항 인자로 문자열을 받고 고유한 심벌 값을 반환합니다
- 문자열 인자를 전달하면 그 문자열은 심벌의 ~toString()~ 메서드 결과에 포함됩니다
- 하지만 같은 문자열을 전달해 ~Symbol()~ 을 다시 호출하더라도 결과는 완전히 다릅니다
**** 전역 심벌 레지스트리
목적
- 다른 코드에서도 쓸 수 있도록 심벌을 정의하고 공유하고 싶을 때 사용합니다

~Symbol.for()~
- 문자열 인자를 받고 그 문자열과 연관된 심벌 값을 반환합니다
- 그 문자열과 연관된 심벌이 존재하지 않으면 새 심벌을 생성해 반환하고, 존재하면 기존 심벌을 반환합니다

~Symbol.keyFor()~
- 반환된 심벌에 호출하면 해당 문자열을 얻을 수 있습니다
*** 전역 객체
전역 객체의 프로퍼티는 전역으로 정의된 식별자이며, 모든 자바스크립트 프로그램에서 사용할 수 있습니다

자바스크립트 인터프리터를 시작할 때마다(또는 웹 브라우저가 새 페이지를 로드할 때마다)
아래의 프로퍼티를 가진 새 전역 객체를 생성합니다
- undefined,Infinity, NaN 같은 전역 상수
- isNaN(), parseInt(), eval() 같은 전역 함수
- Date(), RegExp(), String(), Object(), Array() 같은 생성자 함수
- Math와 JSON 같은 전역 객체

전역 객체의 초기 프로퍼티는 예약어로 간주해야 합니다


노드의 전역 객체에는 global이라는 프로퍼티가 있으며, 그 값은 전역객체 자체입니다
- 따라서 노드 프로그램에서는 ~global~로 전역객체를 참조할 수 있습니다

웹 브라우저에서는 Window 객체가 모든 자바스크립트 코드의 전역 객체입니다.
이 전역 Window 객체에서는 자신을 참조하는 window 프로퍼티가 있으므로 이 프로퍼티를 통해 전역 객체를 참조할 수 있습니다

웹 워커 스레드의 전역 객체는 다릅니다.
- 워커의 코드는 ~self~ 로 전역객체를 참조합니다

globalThis
- 어떤 환경에서든 전역 객체를 참조하는 표준입니다
*** 불변인 기본 값과 가변인 객체 참조
기본 값은 객체와 달리 불변입니다
- 변경하는 방법이 없습니다
객체는 가변입니다
- 값을 변경할 수 있습니다

기본 값은 값으로 비교합니다
객체는 값으로 비교하지 않습니다
- 객체는 참조로 비교합니다. 두 객체 값이 같은 객체를 참조할 때만 성립합니다
- 두 객체의 프로퍼티와 값이 같다고 해서 같은 객체가 아닙니다
- 또한 두 배열에 같은 요소가 같은 순서로 존재한다 해도 같은 배열이 아닙니다
*** 타입 변환
| 값                      | 문자열로          |       숫자로 | 불 값으로 |
|-------------------------+------------------+--------------+----------|
| undefined               | "undefined"      |          NaN | false    |
| null                    | "null"           |            0 | false    |
| true                    | "true"           |            1 |          |
| false                   | "false"          |            0 |          |
| ""(빈문자열)             |                  |            0 | false    |
| "1.2"(숫자)             |                  |          1.2 | true     |
| "one"                   |                  |          NaN | true     |
| 0                       | "0"              |              | false    |
| -0                      | "0"              |              | false    |
| 1(0이 아닌 유한한 숫자)   | "1"              |              | true    |
| Infinity                | "Infinity"       |              | true     |
| -Infinity               | "-Infinity"      |              | true     |
| NaN                     | "NaN"            |              | false    |
| {}(객체)                | 3.9.3절 참조     | 3.9.3절 참조 | true     |
| [](빈배열)              | ""               |            0 | true     |
| [9](숫자요소하나)        | "9"              |            9 | true     |
| ['a'](임의의 배열)       | join()메서드 사용 |          NaN | true     |
| function(){}(임의의함수) | 3.9.3절 참조     |          NaN | true     |
**** 변환과 일치
**** 명시적 변환
#+begin_src javascript
  Number("3")           // => 3
  String(false)         // => "false": false.toString()과 같습니다
  Boolean([])           // => true

  let n = 17;
  let binary = "0b" + n.toString(2);    // binary == "0b10001"
  let octal = "0o" + n.toString(8);     // octal == "0o21"
  let hex = "0x" + n.toString(16);      // hex == "0x11"

  let n = 123456.789;
  n.toFixed(0)          // => "123457"
  n.toFixed(2)          // => "123456.79"
  n.toFixed(5)          // => "123456.78900"
  n.toExponential(1)    // => "1.2e+5"
  n.toExponential(3)    // => "1.235e+5"
  n.toPrecision(4)      // => "1.235e+5"
  n.toPrecision(7)      // => "123456.8"
  n.toPrecision(10)     // => "123456.7890"

#+end_src
~Number()~
- 문자열을 정수나 부동소수점 리터럴로 변환 시도
- 10진수 정수에만 동작
- 리터럴의 일부가 아닌 문자는 모두 무시

~parseInt()~
- 정수 부분만 유지
- 0x 또는 0X로 시작할 경우 16진수로 해석
- 시작부분의 공백은 무시, 숫자를 최대한 해석한 두 숫자 아닌 부분은 무시
- 첫번째 숫자가 유효한 숫자 리터럴이 아니라면 NaN 반환
- 선택으로 두번째 인수로 기수를 받습니다

~parseFloat()~
- 정수와 부동소수점 숫자 모두 유지
- 시작부분의 공백은 무시, 숫자를 최대한 해석한 두 숫자 아닌 부분은 무시
- 첫번째 숫자가 유효한 숫자 리터럴이 아니라면 NaN 반환
**** 객체를 기본 값으로 변환
자바스크립트가 객체를 기본 값으로 변환하는 규칙이 복잡한 이유 중 하나는 일부 객체는 *여러 가지* 기본 값으로 표현될 수 있다는 점입니다

객체를 기본 값으로 변환하는 알고리즘
- 문자열 선호
  - 기본 값을 반환할 때 문자열로 변환할 수 있다면 문자열 값을 우선합니다
- 숫자 선호
  - 기본 값을 반환할 때 숫자로 변환할 수 있다면 숫자 값을 우선합니다
- 선호 없음
  - 어떤 기본 타입을 선호하는지 정해 놓지 않았으며, 클래스에서 변환 방법을 정의할 수 있습니다

Date를 제외한 모든 타입: 숫자 선호
Date클래스: 문자열 선호
***** 객체를 불로 변환
모든 객체는 true로 변한됩니다
***** 객체를 문자열로 변환
객체를 문자열로 변한해야 할 때
문자열 선호 알고리즘을 사용해 기본 값으로 변환한 다음, 규칙에 따라 그 기본 값을 문자열로 변환합니다
- 문자열 인자를 예상하는 내장 함수에 객체를 전달할 때
- String()을 변환 함수로 호출할 때
- 템플릿 리터럴에 객체를 사용할 때
***** 객체를 숫자로 변환
객체를 숫자로 변환해야할 때
숫자 선호 알고리즘에 따라 기본 값으로 변환한 다음, 규칙에 따라 그 가본 값을 숫자로 변환합니다
- 숫자 인자를 예사하는 내장 함수에 객체를 전달할 때
- 숫자 피연산자를 예상하는 연산자 대부분
***** 특별한 케이스인 연산자 변환
****** + 연산자
~+~ 연산자의 피연산자 중 하나가 객체라면 자바스크립트는 해당 피연산자를 선호 없음 알고리즘에 따라 기본 값으로 변환합니다
알고리즘을 적용해서 두 개의 기본 값이 남으면 타입을 체크합니다
- 피연산자 중 하나라도 문자열이면 다른 하나도 문자열로 변환한 다음 병합합니다
- 피연산자 모두 문자열이 아니라면 둘 다 숫자로 변환한 다음 더합니다
****** ==, !=
~==~, ~!=~ 연산자는 타입 변환을 허용합니다
피연산자 중 하나가 객체이고 다른 하나가 기본 값이라면 선호 없음 알고리즘을 써서 객체를 기본 값으로 변한한 다음 비교합니다
****** <, <=, >, >=
피연산자 중 하나가 객체라면 숫자 선호 알고리즘을 통해 기본값으로 변환합니다
여기서 숫자 선호 알고리즘이 반환하는 기본 값은 숫자로 변환되지 않습니다
***** toString(), valueOf() 메서드
~toString()~
- 객체의 문자열 표현을 반환합니다


~valueOf()~
- 객체를 표현하는 기본 값이 존재한다면 그 값으로 객체를 변환합니다
  - 아니라면 기본 값이 아니라 객체 자체를 반환합니다
****** 객체에서 기본 값으로 변환하는 알고리즘
******* 문자열 선호 알고리즘
1. ~toString()~ 메서드를 시도합니다
2. ~toString()~ 이 존재하지 않거나 객체를 반환한다면
   ~valueOf()~ 메서드를 시도합니다
3. ~valueOf()~ 이 존재하지 않거나 객체를 반환한다면
   ~TypeError~ 가 일어납니다
******* 숫자 선호 알고리즘
문자열 선호 알고리즘과 비슷하지만 ~valueOf()~ 를 먼저 시도하고 ~toString()~ 을 두번째로 시도 합니다
******* 선호 없음 알고리즘
Date 객체일 경우 문자열 선호 알고리즘
그 외의 알고리즘은 숫자 선호 알고리즘
*** 변수 선언과 할당
*** 요약
** 표현식과 연산자
*** 기본 표현식
*** 객체와 배열 초기화 표현식
*** 함수 정의 표현식
*** 프로퍼티 접근 표현식
*** 호출 표현식
*** 객체 생성 표현식
*** 연산자 개요
*** 산술 표현식
*** 관계 표현식
*** 논리 표현식
*** 할당 표현식
*** 평가 표현식
*** 기타 연산자
*** 요약
** 문
*** 표현문
*** 복합문과 빈 문
*** 조건문
*** 반복문
*** 점프 문
*** 기타 문
*** 선언
*** 자바스크립트 문 요약
** 객체
*** 객체 소개
*** 객체 생성
*** 프로퍼티 검색과 설정
*** 프로퍼티 삭제
*** 프로퍼티 테스트
*** 프로퍼티 열거
*** 객체 확장
*** 객체 직렬화
*** 객체 메서드
*** 확장된 객체 리터럴 문법
*** 요약
** 배열
*** 배열 생성
*** 배열 요소 읽기와 쓰기
*** 성긴 배열
*** 배열 길이
*** 배열 요소 추가와 삭제
*** 배열 순회
*** 다차원 배열
*** 배열 메서드
*** 배열 비슷한 객체
*** 배열인 문자열
*** 요약
** 함수
*** 함수 정의
*** 함수 호출
*** 함수 매개변수
*** 값인 함수
*** 네임스페이스인 함수
*** 클로저
*** 함수 프로퍼티, 메서드, 생성자
*** 함수형 프로그래밍
*** 요약
** 클래스
*** 클래스와 프로토타입
*** 클래스와 생성자
*** class 키워드를 사용하는 클래스
*** 기존 클래스에 메서드 추가
*** 서브클래스
*** 요약
** 모듈
*** 클래스, 객체, 클로저를 사용하는 모듈
*** 노드모듈
*** ES6 모듈
*** 요약
** 자바스크립트 표준 라이브러리
*** 세트와 맵
*** 형식화 배열과 이진 데이터
*** 정규 표현식과 패턴 매칭
*** 날짜와 시간
*** Error 클래스
*** JSON 직렬화와 분석
*** 국제화 API
*** 콘솔 API
*** URL API
*** 타이머
*** 요약
** 이터레이터와 제너레이터
*** 이터레이터의 동작방법
*** 이터러블 객체 만들기
*** 제너레이터
*** 고급 제너레이터 기능
*** 요약
** 비동기 자바스크립트
*** 콜백과 비동기 프로그래밍
*** 프라미스
*** async와 await
*** 비동기 순회
*** 요약
** 메타프로그래밍
*** 프로퍼티 속성
*** 객체 확장성
*** 프로토타입 속성
*** 잘 알려진 심벌
*** 템플릿 태그
*** 리플렉트 API
*** 프록시 객체
*** 요약
** 웹 브라우저의 자바 스크립트
*** 웹 프로그래밍 기본
*** 이벤트
*** 문서 스크립트
*** CSS 스크립트
*** 문서 지오메트리와 스크롤
*** 웹 컴포넌트
*** SVG
*** <canvas>의 그래픽
*** 오디오 API
*** 위치, 내비게이션, 히스토리
*** 네트워크
*** 스토리지
*** 워커 스레드와 메시지
*** 만델브로트 세트
*** 요약 및 추천문서
** 노드와 서버 사이드 자바스크립트
*** 노드 프로그래밍 기본
*** 노드는 기본적으로 비동기적입니다
*** 버퍼
*** 이벤트와 이벤트이미터
*** 스트림
*** 프로세스, CPU, 운영체제 세부사항
*** 파일 작업
*** HTTP 클라이언트와 서버
*** HTTP를 사용하지 않는 네트워크 서버와 클라이언트
*** 자식 프로세스
*** 워커 스레드
*** 요약
** 자바스크립트 도구와 확장
*** ES린트를 이용한 린팅
*** 프리티어를 사용한 자바스크립트 포맷
*** 제스트를 통한 단위 테스트
*** npm을 통한 패키지 관리
*** 코드 번들링
*** 바벨을 이용한 트랜스파일
*** JSX: 자바스크립트의 마크업 표현식
*** 플로를 이용한 타입체크
*** 요약
