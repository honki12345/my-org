#+title: Python Distilled

* Python distilled
*** 지은이의 글
정보검색이 쉬워지고 파이썬 세계가 확장되면서
- 어디서부터 시작해야 할지 막막해졌다
- 언어의 핵심 그 자체와 다양한 도구가 제공하는 기능을 구별하기 어려워졌다

본 책은 파이썬 프로그래밍에 관한 책이다
- 이 책은 파이썬의 모든 것을 문서화하지 않는다
- 이 책의 초점은 파이썬 언어의 현대적이면서도 엄선된(정제된) *핵심*을 제공하는데 있다

프로그래밍은 재밌어야 한다
- 독자들이 생산적인 파이썬 프로그래머가 되는 데 도움을 받길 바람
  - 사람들이 별을 탐험하고
  - 화성에서 헬리콥터를 조종하고
  - 뒤뜰에서 다람쥐에게 물대포를 쏘기
** 파이썬의 기초
이 장에서는 파이썬 언어의 핵심을 대략 살펴본다
*** 파이썬 실행
파이썬 프로그램은 인터프리터에서 실행된다
인터프리터의 핵심은 명령셸에서 ~python~을 입력해 시작하는 텍스트 기반 응용 프로그램이다
*** 파이썬 프로그램
파이썬 소스 파일은 UTF-8로 인코딩된 텍스트파일이다
*** 기본 자료형, 변수 그리고 표현식
파이썬은 정수, 실수, 문자열과 같은 기본타입(primitive types)을 제공한다

변수는 값을 참조하고 있는 *이름*이다
- 값은 특정 타입 객체를 나타낸다

표현식은 값을 생성하기 위한 기본 타입, 이름, 연산자의 조합이다

~f-문자열~에서 변수 이름과 표현식은 중괄호로 감싸 평가할 수 있다
- 선택적으로 구성 요소마다 포매팅 지정자를 첨부할 수 있다
*** 산술 연산자
| 연산   | 설명                 |
|--------+----------------------|
| x + y  | 더하기               |
| x - y  | 빼기                 |
| x * y  | 곱하기               |
| x / y  | 나누기               |
| x // y | 끝수를 버리는 나누기 |
| x ** y | 제곱(x^y)            |
| x % y  | 나머지(x mod y)      |
| -x     | 단항 마이너스        |
| +x     | 단항 플러스          |

일반 수학 함수
| 함수                 | 설명                                |
|----------------------+-------------------------------------|
| abs(x)               | 절댓값                              |
| divmod(x, y)         | (x // y, x % y) 반환                |
| pow(x, y [, modulo]) | (x ** y) % modulo 반환              |
| round(x, [n])        | 10의 -n승의 가장 가까운 수로 반올림 |
~round()~ 함수는 '은행원식 반올림(banker's rounding)'을 수행한다

비트 조작 연산자
| 연산   | 설명                   |
|--------+------------------------|
| x << y | 왼쪽 이동              |
| x >> y | 오른쪽 이동            |
| x & y  | 비트 and               |
| x l y  | 비트 or                |
| x ^ y  | 비트 xor(exclusive or) |
| ~x     | 비트 negation          |
비트 연산자 동작 방식은 정수를 2의 보수 이진 표현(complement binary representation)으로 나타내고, 부호 비트가 왼쪽으로 무한히 확장된다고 가정한다
- 파이썬은 비트를 버리거나 값의 오버플로를 허용하지 않기 때문에 원시(raw) 비트 패턴으로 작업하는 경우 주의가 필요하다

비교 연산자
| 연산   | 설명              |
|--------+-------------------|
| x == y | ~와 같은          |
| x != y | ~와 다른          |
| x < y  | ~보다 작은        |
| x > y  | ~보다 큰          |
| x >= y | ~보다 크거나 같은 |
| x <= y | ~보다 작거나 같은 |

논리 연산자
| 연산    | 설명                                                 |
|---------+------------------------------------------------------|
| x or y  | x가 거짓이면 y를 반환. 그렇지 않으면 x를 반환        |
| x and y | x가 거짓이면 x를 반환. 그렇지 않으면 y를 반환        |
| not x   | x가 거짓이면 True를 반환. 그렇지 않으면 False를 반환 |
False, None, 0, 빈 문자열은 거짓으로 간주한다

파이썬은 증가(++), 감소(--) 연산자가 없다
~+, -, *, **, /, //, %, &, |, ^, <<, >>~ 연산자와 함께 축약형태의 대입 가능
*** 조건식과 제어흐름
해당 절에서 실행할 문장이 없다면 ~pass~ 문을 사용한다

조건부 표현식(conditional expression)
#+begin_src python
maxval = a if a > b else b
#+end_src

break문
- 루프를 빠져나올 때 사용하며, 빠져 나오는 것은 가장 안쪽 루프에만 적용된다
continue문
- 루프의 맨 앞으로 돌아간다
**** 대입 표현식(assignment expression)
변수 대입과 조건부를 결합한 코드
대입 표현식에서는 표현식을 감싸는 *괄호*가 필요하다
*** 문자열
작음따옴표, 큰따옴표, 또는 삼중따옴표로 문자열 리터럴을 정의
- 논리적으로 한 줄 안에 있어야 하는 작은따옴표나 큰따옴표와 달리, 삼중따옴표는 종료를 알리는 삼중따옴표가 나오기 전까지의 텍스트를 모두 담는다

바로 인접한 문자열 리터럴은 하나의 문자열로 연결할 수 있다

문자열은 유니코드 문자의 시퀀스로 저장된다

문자열 메서드 일부
| 메서드                               | 설명                                                                     |
|--------------------------------------+--------------------------------------------------------------------------|
| s.endwith(prefix [, start [, end]])  | 문자열이 prefix로 끝나는지 검사                                          |
| s.find(sub [, start [, end]])        | 부분 문자열 sub가 처음으로 나타나는 위치를 찾으며, 찾지 못하면 -1을 반환 |
| s.lower()                            | 소문자로 변경                                                            |
| s.replace(old, new [,count])         | 부분 문자열을 대체                                                       |
| s.split([sep [,maxsplit]])           | sep를 분리 기호로 사용하여 문자열을 분할. maxsplit은 최대분할횟수를 지정 |
| s.startswith(prefix [,start [,end]]) | 문자열이 prefix로 시작하는지 검사                                        |
| s.strip([chrs])                      | 앞이나 뒤에 나오는 공백문자나 chrs로 지정된 문자를 제거                  |
| s.upper()                            | 대문자로 변경                                                            |

파이썬은 암묵적으로 문자열의 내용을 숫자 데이터로 해석하지 않는다

문자열이 아닌 값은 ~str()~, ~repr()~, ~format()~ 함수를 사용해 문자열로 변환할 수 있다
- ~str()~ 은 ~print()~ 함수를 사용할 때와 동일한 결과를 생성하지만,
- ~repr()~ 은 객체의 값을 정확히 표현하기 위해 사용자가 프로그램에 입력한 문자열을 그대로 생성한다
  - 디버깅할 때는 ~repr(s)~ 를 사용해 출력을 생성한다
    왜냐하면 ~repr(s)~ 함수가 값과 타입에 대한 추가 정보를 제공하기 때문이다

~format()~ 함수는 주어진 값을 특정 *포맷*이 적용된 문자열로 변환한다
- 사용되는 서식 코드는 ~f-문자열~ 에서 포맷을 적용해 출력하기 위해 사용하는 코드와 똑같다
*** 파일 입출력
기본적으로 파일에는 UTF-8로 인코딩된 텍스트가 들어있다
- 다른 텍스트 인코딩을 다루기 위해서는 파일을 열 때 ~encoding~ 인수를 추가로 사용한다
*** 리스트
임의 객체들의 시퀀스

~append()~
- 리스트 끝에 새로운 항목 추가하기

~insert()~
- 특정 위치에 항목 삽입하기

~for~ 루프
- 리스트 항목 순회

슬라이스 연산자
- 리스트 일부 추출 혹은 재할당

플러스 연산자(+)
- 리스트 연결

빈 리스트 생성
#+begin_src python
names = []
names = list()
#+end_src

데이터를 리스트로 변환
#+begin_src python
letters = list('Dave')  # letters = ['D', 'a', 'v', 'e']
#+end_src

중첩 리스트에 들어있는 항목에 접근하려면 인덱스 연산자를 여러 번 사용하면 된다
*** 튜플
0개, 1개의 요소가 있는 튜플 정의하기
#+begin_src python
a = ()
b = (item,)
#+end_src

이미 생성된 튜플은 요소를 대체하거나 삭제하거나 새로운 요소를 추가할 수 없다
**** 튜플 vs 리스트
리스트: 서로 다른 객체의 묶음(collection)
튜플: 여러 부분으로 이뤄진 변경불가능한 *단일 객체*
*** 집합
고유한 객체의 순서 없는 모음(collection)이다
- 순서가 없으므로 숫자로 인덱스 할 수 없다

집합은 고유한 값을 찾거나 포함 관계(membership) 같은 문제를 다룰 때 사용된다
- 합집합, 교집합, 대칭 차집합과 같은 표준 연산을 지원한다
- 차집합(difference): a에 있지만 b에는 없는 항목을 제공
- 대칭 차집합(symmetric difference): a나 b 중 하나의 집합에만 들어있는 항목을 제공

add()[단일] 또는 update()[여러 항목]로 집합에 새로운 항목을 *추가*할 수 있다
remove() 또는 discard()로 항목을 *삭제*할 수 있다
*** 사전
사전은 키와 값을 매핑한다
- 사전은 이름이 있는 필드로 구성된 객체를 정의할 때 유용하다
- 순서가 정해지지 않은 데이터를 빠르게 조회할 수 있는 매핑 용도로 주로 이용

사전에 어떤 키가 들어 있는지는 ~in~ 연산자로 검사한다
사전에서 하나의 요소를 삭제할 때는 ~del~ 문을 사용한다

keys
- 리스트, 집합, 사전과 같이 내용이 바뀔 수 있는 자료구조는 키로 사용할 수 없다
- 키는 항목이 사전에 처음 삽입된 순서와 항상 동일한 순서로 나타난다
- keys()는 사전에 있는 특별한 키뷰(keys view)를 반환하며, 사전에서 이루어진 변경사항도 적극적으로 반영한다
*** 반복과 루프
**** range
range() 함수로 생성된 객체는 검색을 요청하는 시점에 값을 계산한다
*** 함수
함수의 첫 번째 문장으로 문서화 문서열(documentation string)을 작성한다
- 이 문자열은 help() 명령에 제공되고 IDE 또는 기타개발도구에서 사용된다

함수에서 여러 값을 반환하려면 *튜플*을 사용한다
- 여러 개의 반환값은 개별 변수로 언패킹할 수 있다

함수 매개변수에 기본값을 할당하기
#+begin_src python
  def connect(hostname, port, timeout=3000):
      ...
#+end_src
- 함수 정의 과정에서 기본값을 지정하면, 함수호출에서 해당 값은 *생략*할 수 있다
  - 생략한 값은 지정한 기본값을 가지게 된다
- 선택적인 인수가 많으면 가독성이 떨어진다. 그럴 때는 키워드인수(keyword argument)를 사용하여 인수를 지정해준다
  - 이름이 지정되면 매개변수의 나열 순서는 중요하지 않다
*** 예외
*** 프로그램 종료
*** 객체와 클래스
class 문은 새로운 객체 타입 정의에 사용한다


**** dir()
dir() 함수는 객체가 제공하는 메서드의 목록을 나열한다
- IDE를 사용할 수 없는 상황에서 대화식으로 이것저것 실험할 때 유용하게 사용가능
**** 메서드
각 메서드의 첫 번째 인수는 항상 객체 자기 자신을 가리킨다
- 관습적으로 이 인수의 이름은 self이다
- 객체의 속성과 관련된 연산에서는 명시적으로 self 변수를 참조해야한다
*** 모듈
큰 프로그램의 손쉬운 관리를 위해 여러 파일로 나누고 싶다
- 이때 ~import~ 문을 사용

모듈을 생성하려면 모듈과 동일한 이름을 갖는 파일에 관련 정의와 문장을 넣으면 된다

~import~문은 새로운 네임스페이스/환경을 생성하고 해당 .py 파일 안에 있는 문장을 네임스페이스 안에서 모두 실행한다
- 해당 네임스페이스 안에 접근할려면 모듈의 이름으로 접근하면 된다

~ImportError~ 예외
- 해당 모듈 파일이 존재하는지 확인
- ~sys.path~에 나열된 디렉터리 확인

모듈을 다른 이름으로 불러오고 싶으면 ~as~ 한정어(qualifier)를 사용

특정 정의만을 현재 네임스페이스에 불러오고 싶다면, ~from~ 문을 사용

~dir()~ 함수를 쓰면 모듈의 내용을 볼 수 있다
*** 스크립트 작성
**** ~__name__~
python readport.py
- ~__name__~ = ~__main__~
import readport
- ~__name__~ = 'readport'
*** 패키지
패키지는 계층적인 모듈의 모임이다

디렉터리에는 ~__init__.py~ 이 있어야한다
- 중첩 import 문을 만들 수 있다
- e.g. ~import tutorial.readport~
*** 응용 프로그램의 구조화
*** 서드파티 패키지의 원리
*** 파이써닉한 파이썬: 두뇌에 맞는 언어
** 연산자, 표현식, 데이터 조작
*** 리터럴
*** 표현식과 위치
*** 표준 연산자
*** 제자리 대입
*** 객체 비교
*** 순서 비교 연산자
*** 불리언 표현식과 진릿값
*** 조건 표현식
*** 반복 가능한 연산
*** 시퀀스에 대한 연산
*** 변경 가능한 시퀀스에 대한 연산
*** 집합에 대한 연산
*** 매핑 객체의 연산
*** 리스트, 집합, 사전 컴프리헨션
*** 제너레이터 표현식
*** 속성 연산자
*** 함수 호출 () 연산자
*** 평가 순서
*** 파이써닉한 파이썬: 데이터의 비밀스러운 삶
** 프로그램 구조와 제어 흐름
** 객체, 타입, 프로토콜
** 함수
** 제너레이터
** 클래스와 객체지향 프로그래밍
** 모듈과 패키지
** 입력과 출력
** 내장 함수와 표준 라이브러리
