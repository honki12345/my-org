#+title: Python Distilled

* Python distilled
*** 지은이의 글
정보검색이 쉬워지고 파이썬 세계가 확장되면서
- 어디서부터 시작해야 할지 막막해졌다
- 언어의 핵심 그 자체와 다양한 도구가 제공하는 기능을 구별하기 어려워졌다

본 책은 파이썬 프로그래밍에 관한 책이다
- 이 책은 파이썬의 모든 것을 문서화하지 않는다
- 이 책의 초점은 파이썬 언어의 현대적이면서도 엄선된(정제된) *핵심*을 제공하는데 있다

프로그래밍은 재밌어야 한다
- 독자들이 생산적인 파이썬 프로그래머가 되는 데 도움을 받길 바람
  - 사람들이 별을 탐험하고
  - 화성에서 헬리콥터를 조종하고
  - 뒤뜰에서 다람쥐에게 물대포를 쏘기
** 파이썬의 기초
이 장에서는 파이썬 언어의 핵심을 대략 살펴본다
*** 파이썬 실행
파이썬 프로그램은 인터프리터에서 실행된다
인터프리터의 핵심은 명령셸에서 ~python~을 입력해 시작하는 텍스트 기반 응용 프로그램이다
*** 파이썬 프로그램
파이썬 소스 파일은 UTF-8로 인코딩된 텍스트파일이다
*** 기본 자료형, 변수 그리고 표현식
파이썬은 정수, 실수, 문자열과 같은 기본타입(primitive types)을 제공한다

변수는 값을 참조하고 있는 *이름*이다
- 값은 특정 타입 객체를 나타낸다

표현식은 값을 생성하기 위한 기본 타입, 이름, 연산자의 조합이다

~f-문자열~에서 변수 이름과 표현식은 중괄호로 감싸 평가할 수 있다
- 선택적으로 구성 요소마다 포매팅 지정자를 첨부할 수 있다
*** 산술 연산자
| 연산   | 설명                 |
|--------+----------------------|
| x + y  | 더하기               |
| x - y  | 빼기                 |
| x * y  | 곱하기               |
| x / y  | 나누기               |
| x // y | 끝수를 버리는 나누기 |
| x ** y | 제곱(x^y)            |
| x % y  | 나머지(x mod y)      |
| -x     | 단항 마이너스        |
| +x     | 단항 플러스          |

일반 수학 함수
| 함수                 | 설명                                |
|----------------------+-------------------------------------|
| abs(x)               | 절댓값                              |
| divmod(x, y)         | (x // y, x % y) 반환                |
| pow(x, y [, modulo]) | (x ** y) % modulo 반환              |
| round(x, [n])        | 10의 -n승의 가장 가까운 수로 반올림 |
~round()~ 함수는 '은행원식 반올림(banker's rounding)'을 수행한다

비트 조작 연산자
| 연산   | 설명                   |
|--------+------------------------|
| x << y | 왼쪽 이동              |
| x >> y | 오른쪽 이동            |
| x & y  | 비트 and               |
| x l y  | 비트 or                |
| x ^ y  | 비트 xor(exclusive or) |
| ~x     | 비트 negation          |
비트 연산자 동작 방식은 정수를 2의 보수 이진 표현(complement binary representation)으로 나타내고, 부호 비트가 왼쪽으로 무한히 확장된다고 가정한다
- 파이썬은 비트를 버리거나 값의 오버플로를 허용하지 않기 때문에 원시(raw) 비트 패턴으로 작업하는 경우 주의가 필요하다

비교 연산자
| 연산   | 설명              |
|--------+-------------------|
| x == y | ~와 같은          |
| x != y | ~와 다른          |
| x < y  | ~보다 작은        |
| x > y  | ~보다 큰          |
| x >= y | ~보다 크거나 같은 |
| x <= y | ~보다 작거나 같은 |

논리 연산자
| 연산    | 설명                                                 |
|---------+------------------------------------------------------|
| x or y  | x가 거짓이면 y를 반환. 그렇지 않으면 x를 반환        |
| x and y | x가 거짓이면 x를 반환. 그렇지 않으면 y를 반환        |
| not x   | x가 거짓이면 True를 반환. 그렇지 않으면 False를 반환 |
False, None, 0, 빈 문자열은 거짓으로 간주한다

파이썬은 증가(++), 감소(--) 연산자가 없다
~+, -, *, **, /, //, %, &, |, ^, <<, >>~ 연산자와 함께 축약형태의 대입 가능
*** 조건식과 제어흐름
해당 절에서 실행할 문장이 없다면 ~pass~ 문을 사용한다

조건부 표현식(conditional expression)
#+begin_src python
maxval = a if a > b else b
#+end_src

break문
- 루프를 빠져나올 때 사용하며, 빠져 나오는 것은 가장 안쪽 루프에만 적용된다
continue문
- 루프의 맨 앞으로 돌아간다
**** 대입 표현식(assignment expression)
변수 대입과 조건부를 결합한 코드
대입 표현식에서는 표현식을 감싸는 *괄호*가 필요하다
*** 문자열
작음따옴표, 큰따옴표, 또는 삼중따옴표로 문자열 리터럴을 정의
- 논리적으로 한 줄 안에 있어야 하는 작은따옴표나 큰따옴표와 달리, 삼중따옴표는 종료를 알리는 삼중따옴표가 나오기 전까지의 텍스트를 모두 담는다

바로 인접한 문자열 리터럴은 하나의 문자열로 연결할 수 있다

문자열은 유니코드 문자의 시퀀스로 저장된다

문자열 메서드 일부
| 메서드                               | 설명                                                                     |
|--------------------------------------+--------------------------------------------------------------------------|
| s.endwith(prefix [, start [, end]])  | 문자열이 prefix로 끝나는지 검사                                          |
| s.find(sub [, start [, end]])        | 부분 문자열 sub가 처음으로 나타나는 위치를 찾으며, 찾지 못하면 -1을 반환 |
| s.lower()                            | 소문자로 변경                                                            |
| s.replace(old, new [,count])         | 부분 문자열을 대체                                                       |
| s.split([sep [,maxsplit]])           | sep를 분리 기호로 사용하여 문자열을 분할. maxsplit은 최대분할횟수를 지정 |
| s.startswith(prefix [,start [,end]]) | 문자열이 prefix로 시작하는지 검사                                        |
| s.strip([chrs])                      | 앞이나 뒤에 나오는 공백문자나 chrs로 지정된 문자를 제거                  |
| s.upper()                            | 대문자로 변경                                                            |

파이썬은 암묵적으로 문자열의 내용을 숫자 데이터로 해석하지 않는다

문자열이 아닌 값은 ~str()~, ~repr()~, ~format()~ 함수를 사용해 문자열로 변환할 수 있다
- ~str()~ 은 ~print()~ 함수를 사용할 때와 동일한 결과를 생성하지만,
- ~repr()~ 은 객체의 값을 정확히 표현하기 위해 사용자가 프로그램에 입력한 문자열을 그대로 생성한다
  - 디버깅할 때는 ~repr(s)~ 를 사용해 출력을 생성한다
    왜냐하면 ~repr(s)~ 함수가 값과 타입에 대한 추가 정보를 제공하기 때문이다

~format()~ 함수는 주어진 값을 특정 *포맷*이 적용된 문자열로 변환한다
- 사용되는 서식 코드는 ~f-문자열~ 에서 포맷을 적용해 출력하기 위해 사용하는 코드와 똑같다
*** 파일 입출력
기본적으로 파일에는 UTF-8로 인코딩된 텍스트가 들어있다
- 다른 텍스트 인코딩을 다루기 위해서는 파일을 열 때 ~encoding~ 인수를 추가로 사용한다
*** 리스트
임의 객체들의 시퀀스

~append()~
- 리스트 끝에 새로운 항목 추가하기

~insert()~
- 특정 위치에 항목 삽입하기

~for~ 루프
- 리스트 항목 순회

슬라이스 연산자
- 리스트 일부 추출 혹은 재할당

플러스 연산자(+)
- 리스트 연결

빈 리스트 생성
#+begin_src python
names = []
names = list()
#+end_src

데이터를 리스트로 변환
#+begin_src python
letters = list('Dave')  # letters = ['D', 'a', 'v', 'e']
#+end_src

중첩 리스트에 들어있는 항목에 접근하려면 인덱스 연산자를 여러 번 사용하면 된다
*** 튜플
0개, 1개의 요소가 있는 튜플 정의하기
#+begin_src python
a = ()
b = (item,)
#+end_src

이미 생성된 튜플은 요소를 대체하거나 삭제하거나 새로운 요소를 추가할 수 없다
**** 튜플 vs 리스트
리스트: 서로 다른 객체의 묶음(collection)
튜플: 여러 부분으로 이뤄진 변경불가능한 *단일 객체*
*** 집합
고유한 객체의 순서 없는 모음(collection)이다
- 순서가 없으므로 숫자로 인덱스 할 수 없다

집합은 고유한 값을 찾거나 포함 관계(membership) 같은 문제를 다룰 때 사용된다
- 합집합, 교집합, 대칭 차집합과 같은 표준 연산을 지원한다
- 차집합(difference): a에 있지만 b에는 없는 항목을 제공
- 대칭 차집합(symmetric difference): a나 b 중 하나의 집합에만 들어있는 항목을 제공

add()[단일] 또는 update()[여러 항목]로 집합에 새로운 항목을 *추가*할 수 있다
remove() 또는 discard()로 항목을 *삭제*할 수 있다
*** 사전
사전은 키와 값을 매핑한다
- 사전은 이름이 있는 필드로 구성된 객체를 정의할 때 유용하다
- 순서가 정해지지 않은 데이터를 빠르게 조회할 수 있는 매핑 용도로 주로 이용

사전에 어떤 키가 들어 있는지는 ~in~ 연산자로 검사한다
사전에서 하나의 요소를 삭제할 때는 ~del~ 문을 사용한다

keys
- 리스트, 집합, 사전과 같이 내용이 바뀔 수 있는 자료구조는 키로 사용할 수 없다
- 키는 항목이 사전에 처음 삽입된 순서와 항상 동일한 순서로 나타난다
- keys()는 사전에 있는 특별한 키뷰(keys view)를 반환하며, 사전에서 이루어진 변경사항도 적극적으로 반영한다
*** 반복과 루프
**** range
range() 함수로 생성된 객체는 검색을 요청하는 시점에 값을 계산한다
*** 함수
함수의 첫 번째 문장으로 문서화 문서열(documentation string)을 작성한다
- 이 문자열은 help() 명령에 제공되고 IDE 또는 기타개발도구에서 사용된다

함수에서 여러 값을 반환하려면 *튜플*을 사용한다
- 여러 개의 반환값은 개별 변수로 언패킹할 수 있다

함수 매개변수에 기본값을 할당하기
#+begin_src python
  def connect(hostname, port, timeout=3000):
      ...
#+end_src
- 함수 정의 과정에서 기본값을 지정하면, 함수호출에서 해당 값은 *생략*할 수 있다
  - 생략한 값은 지정한 기본값을 가지게 된다
- 선택적인 인수가 많으면 가독성이 떨어진다. 그럴 때는 키워드인수(keyword argument)를 사용하여 인수를 지정해준다
  - 이름이 지정되면 매개변수의 나열 순서는 중요하지 않다
*** 예외
*** 프로그램 종료
더이상 실행할 문장이 없거나
잡히지 않는 ~SystemExit~ 예외가 발생하면 프로그램은 종료된다
*** 객체와 클래스
class 문은 새로운 객체 타입 정의에 사용한다


**** dir()
dir() 함수는 객체가 제공하는 메서드의 목록을 나열한다
- IDE를 사용할 수 없는 상황에서 대화식으로 이것저것 실험할 때 유용하게 사용가능
**** 메서드
각 메서드의 첫 번째 인수는 항상 객체 자기 자신을 가리킨다
- 관습적으로 이 인수의 이름은 self이다
- 객체의 속성과 관련된 연산에서는 명시적으로 self 변수를 참조해야한다
*** 모듈
큰 프로그램의 손쉬운 관리를 위해 여러 파일로 나누고 싶다
- 이때 ~import~ 문을 사용

모듈을 생성하려면 모듈과 동일한 이름을 갖는 파일에 관련 정의와 문장을 넣으면 된다

~import~문은 새로운 네임스페이스/환경을 생성하고 해당 .py 파일 안에 있는 문장을 네임스페이스 안에서 모두 실행한다
- 해당 네임스페이스 안에 접근할려면 모듈의 이름으로 접근하면 된다

~ImportError~ 예외
- 해당 모듈 파일이 존재하는지 확인
- ~sys.path~에 나열된 디렉터리 확인

모듈을 다른 이름으로 불러오고 싶으면 ~as~ 한정어(qualifier)를 사용

특정 정의만을 현재 네임스페이스에 불러오고 싶다면, ~from~ 문을 사용

~dir()~ 함수를 쓰면 모듈의 내용을 볼 수 있다
*** 스크립트 작성
**** ~__name__~
python readport.py
- ~__name__~ = ~__main__~

import readport
- ~__name__~ = 'readport'

프로그램이 메인 스크립트로 실행되느냐에 따라 ~__name__~ 의 값이 바뀐다
*** 패키지
패키지는 **계층적인 모듈** 의 모임이다

디렉터리에는 ~__init__.py~ 이 있어야한다
- 중첩 import 문을 만들 수 있다
- e.g. ~import tutorial.readport~

같은 패키지 내에 있는 파일을 불러올 때는
특정 모듈만 불러올 수 있는 ~import~ 문을 사용해야한다
- e.g ~from tutorial import readport~
  ~from . import readport~ 상대경로 import도 사용가능하다
*** 응용 프로그램의 구조화
- 소스코드(코드베이스)는 패키지로 구성하여 관리한다
  - 최상위 디렉터리 이름을 고유한 패키지이름으로 선택
  - 패키지의 목적은 모듈의 네임스페이스와 ~import~ 문을 관리하기 위함이다

기본 프로젝트 외의 테스트, 예제, 스크립트, 문서와 같은 추가자료는 별도의 다른 디렉터리에 둔다
*** 서드파티 패키지의 원리
- 설치된 패키지는 ~sys.path~ 의 값을 살펴보면 알 수 있다
  - ~site-packages~ 디렉터리에 위치한다
- 기존 환경을 망칠 염려 없이 패키지를 설치하고 작업할 수 있는 환경을 만들기 위해서는 가상환경을 만들면 된다
  - `python3 -m venv myproject`
  - 해당 디렉터리 내에서 패키지를 안전하게 설치할 수 있는 인터프리터 실행파일과 라이브러리를 찾을 수 있다
*** 파이써닉한 파이썬: 두뇌에 맞는 언어
** 연산자, 표현식, 데이터 조작
*** 리터럴
- 정수 리터럴은 부호가 있는 임의 크기의 정숫값을 표현한다
- 부동 소수점 수는 IEEE 754 배정밀도(64bit) 로 저장된다
*** 표현식과 위치
- 표현식은 구체적인 값으로 평가하는(되는) 계산을 의미한다
*** 표준 연산자
| 연산                  | 설명                                   |
|-----------------------+----------------------------------------|
| x + y                 | 더하기                                 |
| x - y                 | 빼기                                   |
| x * y                 | 곱하기                                 |
| x / y                 | 나누기                                 |
| x // y                | 끝수를 버리는 나누기                     |
| x @ y                 | 행렬 곱셈                               |
| x ** y                | 제곱                                   |
| x % y                 | 나머지 (x mod y)                       |
| x << y                | 왼쪽 이동(shift)                        |
| x >> y                | 오른쪽 이동(shift)                      |
| x & y                 | 비트 and                               |
| x 1 y                 | 비트 or                                |
| x ^ y                 | 비트 xor                               |
| ~x                    | 비트 negation                          |
| -x                    | 단항 마이너스                           |
| +x                    | 단항 플러스                             |
| abs(x)                | 절댓값                                 |
| divmod(x,y)           | (x // y, x % y)반환                    |
| pow(x, y, [, modulo]) | (x ** y) % modulo                      |
| round(x, [n])         | 10의 -n승의 배수와 가장 가까운 수로 반올림 |


*** 제자리 대입
이 연산자들은 표현식으로 간주하지 않는다
*** 객체 비교
**** 동등연산자(~=~)
x의 값과 y의 값이 같은지 평가한다
- *리스트* 와 *튜플* 은 서로 크기가 같고 동일한 요소가 같은 순서로 있으면 동등하다고 평가한다
- *딕셔너리* 는 x와 y에 동일한 키 집합이 있고, 같은 키를 가지고 있는 객체의 값이 모두 동일하면 참으로 평가한다
- *집합* 은 두 집합이 서로 같은 요소로 이루어져있으면 동등하다고 평가한다
- 서로 호환성이 없는 타입의 객체를 비교할 때는 에러가 발생하지 않고 ~False~ 를 반환한다
  - 호환성 e.g. `2 == 2.0 # True`
**** 식별연산자(~is~)
두 변수가 메모리에 있는 동일한 객체를 가리키고 있는지 검사한다
- ~id~ 함수는 객체 고윳값을 반환한다
*** 순서 비교 연산자
| 연산   | 설명 |
|--------+------|
| x < y  |      |
| x > y  |      |
| x >= y |      |
| x <= y |      |

- *수* 에 대해서는 표준 수학적 해석(mathematical interpretation) 을 갖는다
- *집합* 에서 ~x < y~ 는 x가 y의 진부분집합(strict subset, x가 y의 부분집합이지만 같지 않다는 뜻)인지 평가한다
- *시퀀스* 에서는 순서대로 비교한다. 끝에 도달시 동일한걸로 간주한다
- *문자열*, *바이트* 는 사전식 순서(lexicographical ordering)로 비교된다
- *사전* 타입은 지원하지 않는다
*** 불리언 표현식과 진릿값
**** 참
- True, 0이 아닌 *수*, *비어 있지 않은* 문자열-리쓰트,튜플,사전
**** 거짓
- False, 숫자 0, None, 빈 리스트-튜플-사전
*** 조건 표현식
#+begin_src python
  minvalue = a if a <= b else b
#+end_src
조건 표현식에서는 가운데 있는 조건이 가장 먼저 평가된다
평가 결과가 True면 if 왼쪽에 있는 표현식이 평가되고, 그렇지 않으면 else 다음의 표현식이 평가된다
else 절은 꼭 필요하다
*** 반복 가능한 연산
반복(Iteration) 은 파이썬 컨테이너(리스트, 튜플, 사전, 등), 파일, 제너레이터에서 모두 지원한다

반복을 지원하는 객체에는 다음의 연산이 가능하다
| 연산                               | 설명                                        |
|------------------------------------+---------------------------------------------|
| for vars in s:                     | 반복                                        |
| v1, v2, ... = s                    | 변수 언패킹                                  |
| x in s, x not in s                 | 멤버 검사                                    |
| [a, *s, b], (a, *s, b), {a, *s, b} | 리스트, 튜플, 집합 리터럴에서의 확장(expansion) |

- 필수 연산은 `for` 루프이다. 다른 연산은 모두 이를 기반으로 한다
- *문자열* 은 부분 문자열을 찾을 때도 사용가능하다
  - `'hello' in 'hello world' # True`
- 언패킹의 왼쪽에는 대입시 `l-value` 에 유효한거라면 어느것이든 가능하다
  #+begin_src python
    items = [3, 4, 5]
    d = {}
    d['x'], d['y'], d['z'] = items
  #+end_src
- 값을 위치로 언패킹할 때, 왼쪽의 위치 개수는 오른쪽 반복 가능한 객체의 항목 개수와 정확히 일치해야한다
  - 객체의 항목 개수를 알 수 없으면 별표 변수(starred variable)를 포함할 수 있다
  - 하나의 반복 가능한 객체에서 항목을 언패킹할 때 *두 개 이상의* 별표 변수를 사용할 수 없다
    - 중첩되어 여러 개의 반복 가능한 객체가 있는 곳에서는 별표 변수를 여러 개 사용 가능하다
  - 별표 변수의 값은 항상 리스트이다
**** 스플래티(splatting)
리스트, 튜플, 집합, 사전 리터럴을 작성할 때 반복 가능한 객체는 확장될 수 있다

#+begin_src python
  items = [1, 2, 3]
  a = [10, *items, 11]          # a = [10, 1, 2, 3, 11]
  b = (*items, 10, *items)      # b = (1, 2, 3, 10, 1, 2, 3)
  c = {10, 11, *items}          # c = {1, 2, 3, 10, 11}
#+end_src
**** 반복 가능한 객체를 입력으로 받는 함수
| 함수                | 설명                                     |
|---------------------+------------------------------------------|
| list(s)             | s로부터 리스트 생성                        |
| tuple(s)            | s로부터 튜플 생성                          |
| set(s)              | s로부터 집합 생성                          |
| min(s, [, key])     | s에 있는 가장 작은 항목                    |
| max(s, [, key])     | s에 있는 가장 큰 항목                      |
| any(s)              | s에 속한 항목 중 하나라도 참이면 True를 반환 |
| all(s)              | s에 속한 항목이 모두 참이면 True를 반환      |
| sum(s, [, initial]) | 옵션이 초깃값과 함께 항목을 모두 합한 값      |
| sorted(s, [, key])  | 정렬된 리스트를 생성                       |

*** 시퀀스에 대한 연산
시퀀스는 크기를 가지며,
인덱스로 항목에 접근할 수 있는
반복 가능한 컨테이너다

문자열, 리스트, 튜플이 시퀀스에 포함된다

**** 시퀀스에 적용 가능한 연산
| 연산          | 설명                       |
|---------------+----------------------------|
| s + r         | 연결                       |
| s * n         | s에 대한 n 개의 복사본을 생성 |
| s[i]          | 인덱스                     |
| s[i:j]        | 슬라이스                    |
| s[i:j:stride] | 확장 슬라이스               |
| len(s)        | 길이                           |

- ~s * n~ n 개의 시퀀스 복사본을 생성한다
  - 생성된 복사본은 참조형태로 요소를 복사하는 얕은 복사본이다
- 슬라이스 연산자 ~s[i:j]~
  - 시퀀스 s에서 ~i <= k  j~ 범위 사이에 있는 인덱스 k 에 해당하는 요소들로 구성된 부분 시퀀스를 추출한다
  - 슬라이스는 ~slice()~ 를 사용하여 이름을 붙일 수 있다
*** 변경 가능한 시퀀스에 대한 연산
**** 변경 가능한 시퀀스에 적용할 수 있는 연산
| 연산              | 설명                |
|-------------------+---------------------|
| s[i] = x          | 항목 대입            |
| s[i:j] = r        | 슬라이스에 대입       |
| s[i:j:stride] = r | 확장된 슬라이스에 대입 |
| del s[i]          | 항목 삭제            |
| del s[i:j]        | 슬라이스 삭제        |
| del s[i:j:stride] | 확장 슬라이스 삭제    |

- 슬라이스 대입 ~s[i:j] = r~
  - 슬라이스 대입 연산은 인덱스 k(i <= k < j) 의 위치에 있는 요소들을 시퀀스 r의 요소들로 대체한다
  - 필요에 따라 시퀀스 s는 크기가 확장되거나 축소된다
- 확장된 슬라이스 대입시 오른쪽에 있는 요소의 개수가 대체하려는 요소이 개수와 동일해야한다

*** 집합에 대한 연산

**** 적용할 수 있는 연산
| 연산            | 설명                                    |
|-----------------+-----------------------------------------|
| s l t           | s와 t의 합집합                           |
| s & t           | s와 t의 교집합                           |
| s - t           | 차집합                                  |
| s ^ t           | 대칭 차집합(s와 t 모두 없는 항목)          |
| len(s)          |                                         |
| item in s       |                                         |
| s.add(item)     |                                         |
| s.remove(item)  | s에 item이 없으면 에러가 발생              |
| s.discard(item) | s에 item이 없어도 아무런 일도 발생하지 않음 |

- 집합 연산은 딕셔너리의 키 뷰, 항목 뷰를 가진 객체에서도 동작한다
  #+begin_src python
    a = {'x': 1, 'y': 2, 'z': 3}
    b = {'z': 3, 'w': 4, 'q': 5}
    a.keys() & b.keys()
  #+end_src
*** 매핑 객체의 연산
**** 적용 가능한 연산
| 연산       | 설명                        |
|------------+-----------------------------|
| x = m[k]   | 키를 이용한 인덱스            |
| m[k] = x   | 키를 이용한 할당              |
| del m[k]   | 키를 이용한 항목 삭제         |
| k in m     | 키의 존재 여부 검사           |
| len(m)     | 매핑 객체에 들어있는 항목 개수 |
| m.keys()   |                             |
| m.values() |                             |
| m.items()  | (키, 값) 쌍으로 반환          |

- 변경 불가능한 객체(e.g. 문자열, 숫자, 튜플)를 키 값으로 사용가능하다
*** 리스트, 집합, 사전 컴프리헨션
- 집합, 딕셔너리 생성할 때는 마지막에 들어온 값이 기존 값을 덮어쓴다
- 컴프리헨션 문장 안에서는 어떠한 예외 처리도 포함할 수 없다
  - expression 을 함수로 만들고 예외문으로 감쌀 수 있다
**** 리스트 컴프리헨션
#+begin_src python
  [expression for item1 in iterable1 if condition1
               for item2 in iterable2 if condition2
               ...
               for itemN in iterableN if conditionN

  result = []
  for item1 in iterable1:
   if condition1:
     for item2 in iterable2:
       if condition2:
         ...
           for itemN in iterableN:
             if conditionN:
               result.append(expression)
#+end_src
**** 집합 컴프리헨션
리스트 컴프리헨션에서 대괄호 대신 중괄호를 사용하면 된다
**** 딕셔너리 컴프리헨션
~key:value~ 쌍을 명시하면 된다
*** 제너레이터 표현식
- 제너레이터 표현식은 반복을 통해 필요할 때마다 값을 생성하는 제너레이터 객체를 반환한다
- 제너레이터 표현식은 한 번만 사용할 수 있다. 반복을 두 번 시도하면 아무것도 얻을 수 없을 것이다
- 제너레이터 객체는 시퀀스처럼 동작하지 않는다
  - 인덱스 할 수 없음
  - ~list()~ 함수를 사용하여 제너레이터 객체를 리스트로 변환할 수 있다
*** 속성 연산자
- 속성(~.~) 연산자는 객체의 속성에 접근할 때 사용한다
*** 함수 호출 () 연산자
- 함수가 호출되기 전, 인수 표현식은 모두 왼쪽부터 오른쪽으로 평가된다
  - 이를 적용 순서 평가라고 한다
*** 평가 순서
- 논리 연산자 ~and~, ~or~ 는 사용자가 원하는 대로 바꿀 수 없기에 비트연산자를 대신 사용하곤 한다
  - 비트 and(&) 와 비트 or(|) 연산자를 논리곱(and)와 논리합(or)을 뜻하는 것으로 사용할 수 있다
*** 파이써닉한 파이썬: 데이터의 비밀스러운 삶
** 프로그램 구조와 제어 흐름
** 객체, 타입, 프로토콜
** 함수
** 제너레이터
** 클래스와 객체지향 프로그래밍
** 모듈과 패키지
** 입력과 출력
** 내장 함수와 표준 라이브러리
